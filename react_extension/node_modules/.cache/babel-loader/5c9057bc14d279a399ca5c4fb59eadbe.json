{"ast":null,"code":"import { cubicSubdivide } from '../core/curve';\nimport PathProxy from '../core/PathProxy';\nvar CMD = PathProxy.CMD;\n\nfunction aroundEqual(a, b) {\n  return Math.abs(a - b) < 1e-5;\n}\n\nexport function pathToBezierCurves(path) {\n  var data = path.data;\n  var len = path.len();\n  var bezierArrayGroups = [];\n  var currentSubpath;\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n\n  function createNewSubpath(x, y) {\n    if (currentSubpath && currentSubpath.length > 2) {\n      bezierArrayGroups.push(currentSubpath);\n    }\n\n    currentSubpath = [x, y];\n  }\n\n  function addLine(x0, y0, x1, y1) {\n    if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {\n      currentSubpath.push(x0, y0, x1, y1, x1, y1);\n    }\n  }\n\n  function addArc(startAngle, endAngle, cx, cy, rx, ry) {\n    var delta = Math.abs(endAngle - startAngle);\n    var len = Math.tan(delta / 4) * 4 / 3;\n    var dir = endAngle < startAngle ? -1 : 1;\n    var c1 = Math.cos(startAngle);\n    var s1 = Math.sin(startAngle);\n    var c2 = Math.cos(endAngle);\n    var s2 = Math.sin(endAngle);\n    var x1 = c1 * rx + cx;\n    var y1 = s1 * ry + cy;\n    var x4 = c2 * rx + cx;\n    var y4 = s2 * ry + cy;\n    var hx = rx * len * dir;\n    var hy = ry * len * dir;\n    currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n  }\n\n  var x1;\n  var y1;\n  var x2;\n  var y2;\n\n  for (var i = 0; i < len;) {\n    var cmd = data[i++];\n    var isFirst = i === 1;\n\n    if (isFirst) {\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n\n      if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {\n        currentSubpath = [x0, y0];\n      }\n    }\n\n    switch (cmd) {\n      case CMD.M:\n        xi = x0 = data[i++];\n        yi = y0 = data[i++];\n        createNewSubpath(x0, y0);\n        break;\n\n      case CMD.L:\n        x1 = data[i++];\n        y1 = data[i++];\n        addLine(xi, yi, x1, y1);\n        xi = x1;\n        yi = y1;\n        break;\n\n      case CMD.C:\n        currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);\n        break;\n\n      case CMD.Q:\n        x1 = data[i++];\n        y1 = data[i++];\n        x2 = data[i++];\n        y2 = data[i++];\n        currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);\n        xi = x2;\n        yi = y2;\n        break;\n\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var startAngle = data[i++];\n        var endAngle = data[i++] + startAngle;\n        i += 1;\n        var anticlockwise = !data[i++];\n        x1 = Math.cos(startAngle) * rx + cx;\n        y1 = Math.sin(startAngle) * ry + cy;\n\n        if (isFirst) {\n          x0 = x1;\n          y0 = y1;\n          createNewSubpath(x0, y0);\n        } else {\n          addLine(xi, yi, x1, y1);\n        }\n\n        xi = Math.cos(endAngle) * rx + cx;\n        yi = Math.sin(endAngle) * ry + cy;\n        var step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n\n        for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n          var nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);\n          addArc(angle, nextAngle, cx, cy, rx, ry);\n        }\n\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        x1 = x0 + data[i++];\n        y1 = y0 + data[i++];\n        createNewSubpath(x1, y0);\n        addLine(x1, y0, x1, y1);\n        addLine(x1, y1, x0, y1);\n        addLine(x0, y1, x0, y0);\n        addLine(x0, y0, x1, y0);\n        break;\n\n      case CMD.Z:\n        currentSubpath && addLine(xi, yi, x0, y0);\n        xi = x0;\n        yi = y0;\n        break;\n    }\n  }\n\n  if (currentSubpath && currentSubpath.length > 2) {\n    bezierArrayGroups.push(currentSubpath);\n  }\n\n  return bezierArrayGroups;\n}\n\nfunction adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, out, scale) {\n  if (aroundEqual(x0, x1) && aroundEqual(y0, y1) && aroundEqual(x2, x3) && aroundEqual(y2, y3)) {\n    out.push(x3, y3);\n    return;\n  }\n\n  var PIXEL_DISTANCE = 2 / scale;\n  var PIXEL_DISTANCE_SQR = PIXEL_DISTANCE * PIXEL_DISTANCE;\n  var dx = x3 - x0;\n  var dy = y3 - y0;\n  var d = Math.sqrt(dx * dx + dy * dy);\n  dx /= d;\n  dy /= d;\n  var dx1 = x1 - x0;\n  var dy1 = y1 - y0;\n  var dx2 = x2 - x3;\n  var dy2 = y2 - y3;\n  var cp1LenSqr = dx1 * dx1 + dy1 * dy1;\n  var cp2LenSqr = dx2 * dx2 + dy2 * dy2;\n\n  if (cp1LenSqr < PIXEL_DISTANCE_SQR && cp2LenSqr < PIXEL_DISTANCE_SQR) {\n    out.push(x3, y3);\n    return;\n  }\n\n  var projLen1 = dx * dx1 + dy * dy1;\n  var projLen2 = -dx * dx2 - dy * dy2;\n  var d1Sqr = cp1LenSqr - projLen1 * projLen1;\n  var d2Sqr = cp2LenSqr - projLen2 * projLen2;\n\n  if (d1Sqr < PIXEL_DISTANCE_SQR && projLen1 >= 0 && d2Sqr < PIXEL_DISTANCE_SQR && projLen2 >= 0) {\n    out.push(x3, y3);\n    return;\n  }\n\n  var tmpSegX = [];\n  var tmpSegY = [];\n  cubicSubdivide(x0, x1, x2, x3, 0.5, tmpSegX);\n  cubicSubdivide(y0, y1, y2, y3, 0.5, tmpSegY);\n  adpativeBezier(tmpSegX[0], tmpSegY[0], tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], tmpSegX[3], tmpSegY[3], out, scale);\n  adpativeBezier(tmpSegX[4], tmpSegY[4], tmpSegX[5], tmpSegY[5], tmpSegX[6], tmpSegY[6], tmpSegX[7], tmpSegY[7], out, scale);\n}\n\nexport function pathToPolygons(path, scale) {\n  var bezierArrayGroups = pathToBezierCurves(path);\n  var polygons = [];\n  scale = scale || 1;\n\n  for (var i = 0; i < bezierArrayGroups.length; i++) {\n    var beziers = bezierArrayGroups[i];\n    var polygon = [];\n    var x0 = beziers[0];\n    var y0 = beziers[1];\n    polygon.push(x0, y0);\n\n    for (var k = 2; k < beziers.length;) {\n      var x1 = beziers[k++];\n      var y1 = beziers[k++];\n      var x2 = beziers[k++];\n      var y2 = beziers[k++];\n      var x3 = beziers[k++];\n      var y3 = beziers[k++];\n      adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, polygon, scale);\n      x0 = x3;\n      y0 = y3;\n    }\n\n    polygons.push(polygon);\n  }\n\n  return polygons;\n}","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/zrender/lib/tool/convertPath.js"],"names":["cubicSubdivide","PathProxy","CMD","aroundEqual","a","b","Math","abs","pathToBezierCurves","path","data","len","bezierArrayGroups","currentSubpath","xi","yi","x0","y0","createNewSubpath","x","y","length","push","addLine","x1","y1","addArc","startAngle","endAngle","cx","cy","rx","ry","delta","tan","dir","c1","cos","s1","sin","c2","s2","x4","y4","hx","hy","x2","y2","i","cmd","isFirst","L","C","Q","M","A","anticlockwise","step","PI","angle","nextAngle","max","min","R","Z","adpativeBezier","x3","y3","out","scale","PIXEL_DISTANCE","PIXEL_DISTANCE_SQR","dx","dy","d","sqrt","dx1","dy1","dx2","dy2","cp1LenSqr","cp2LenSqr","projLen1","projLen2","d1Sqr","d2Sqr","tmpSegX","tmpSegY","pathToPolygons","polygons","beziers","polygon","k"],"mappings":"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","sourcesContent":["import { cubicSubdivide } from '../core/curve';\nimport PathProxy from '../core/PathProxy';\nvar CMD = PathProxy.CMD;\nfunction aroundEqual(a, b) {\n    return Math.abs(a - b) < 1e-5;\n}\nexport function pathToBezierCurves(path) {\n    var data = path.data;\n    var len = path.len();\n    var bezierArrayGroups = [];\n    var currentSubpath;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n    function createNewSubpath(x, y) {\n        if (currentSubpath && currentSubpath.length > 2) {\n            bezierArrayGroups.push(currentSubpath);\n        }\n        currentSubpath = [x, y];\n    }\n    function addLine(x0, y0, x1, y1) {\n        if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {\n            currentSubpath.push(x0, y0, x1, y1, x1, y1);\n        }\n    }\n    function addArc(startAngle, endAngle, cx, cy, rx, ry) {\n        var delta = Math.abs(endAngle - startAngle);\n        var len = Math.tan(delta / 4) * 4 / 3;\n        var dir = endAngle < startAngle ? -1 : 1;\n        var c1 = Math.cos(startAngle);\n        var s1 = Math.sin(startAngle);\n        var c2 = Math.cos(endAngle);\n        var s2 = Math.sin(endAngle);\n        var x1 = c1 * rx + cx;\n        var y1 = s1 * ry + cy;\n        var x4 = c2 * rx + cx;\n        var y4 = s2 * ry + cy;\n        var hx = rx * len * dir;\n        var hy = ry * len * dir;\n        currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n    }\n    var x1;\n    var y1;\n    var x2;\n    var y2;\n    for (var i = 0; i < len;) {\n        var cmd = data[i++];\n        var isFirst = i === 1;\n        if (isFirst) {\n            xi = data[i];\n            yi = data[i + 1];\n            x0 = xi;\n            y0 = yi;\n            if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {\n                currentSubpath = [x0, y0];\n            }\n        }\n        switch (cmd) {\n            case CMD.M:\n                xi = x0 = data[i++];\n                yi = y0 = data[i++];\n                createNewSubpath(x0, y0);\n                break;\n            case CMD.L:\n                x1 = data[i++];\n                y1 = data[i++];\n                addLine(xi, yi, x1, y1);\n                xi = x1;\n                yi = y1;\n                break;\n            case CMD.C:\n                currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);\n                break;\n            case CMD.Q:\n                x1 = data[i++];\n                y1 = data[i++];\n                x2 = data[i++];\n                y2 = data[i++];\n                currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);\n                xi = x2;\n                yi = y2;\n                break;\n            case CMD.A:\n                var cx = data[i++];\n                var cy = data[i++];\n                var rx = data[i++];\n                var ry = data[i++];\n                var startAngle = data[i++];\n                var endAngle = data[i++] + startAngle;\n                i += 1;\n                var anticlockwise = !data[i++];\n                x1 = Math.cos(startAngle) * rx + cx;\n                y1 = Math.sin(startAngle) * ry + cy;\n                if (isFirst) {\n                    x0 = x1;\n                    y0 = y1;\n                    createNewSubpath(x0, y0);\n                }\n                else {\n                    addLine(xi, yi, x1, y1);\n                }\n                xi = Math.cos(endAngle) * rx + cx;\n                yi = Math.sin(endAngle) * ry + cy;\n                var step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n                for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n                    var nextAngle = anticlockwise ? Math.max(angle + step, endAngle)\n                        : Math.min(angle + step, endAngle);\n                    addArc(angle, nextAngle, cx, cy, rx, ry);\n                }\n                break;\n            case CMD.R:\n                x0 = xi = data[i++];\n                y0 = yi = data[i++];\n                x1 = x0 + data[i++];\n                y1 = y0 + data[i++];\n                createNewSubpath(x1, y0);\n                addLine(x1, y0, x1, y1);\n                addLine(x1, y1, x0, y1);\n                addLine(x0, y1, x0, y0);\n                addLine(x0, y0, x1, y0);\n                break;\n            case CMD.Z:\n                currentSubpath && addLine(xi, yi, x0, y0);\n                xi = x0;\n                yi = y0;\n                break;\n        }\n    }\n    if (currentSubpath && currentSubpath.length > 2) {\n        bezierArrayGroups.push(currentSubpath);\n    }\n    return bezierArrayGroups;\n}\nfunction adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, out, scale) {\n    if (aroundEqual(x0, x1) && aroundEqual(y0, y1) && aroundEqual(x2, x3) && aroundEqual(y2, y3)) {\n        out.push(x3, y3);\n        return;\n    }\n    var PIXEL_DISTANCE = 2 / scale;\n    var PIXEL_DISTANCE_SQR = PIXEL_DISTANCE * PIXEL_DISTANCE;\n    var dx = x3 - x0;\n    var dy = y3 - y0;\n    var d = Math.sqrt(dx * dx + dy * dy);\n    dx /= d;\n    dy /= d;\n    var dx1 = x1 - x0;\n    var dy1 = y1 - y0;\n    var dx2 = x2 - x3;\n    var dy2 = y2 - y3;\n    var cp1LenSqr = dx1 * dx1 + dy1 * dy1;\n    var cp2LenSqr = dx2 * dx2 + dy2 * dy2;\n    if (cp1LenSqr < PIXEL_DISTANCE_SQR && cp2LenSqr < PIXEL_DISTANCE_SQR) {\n        out.push(x3, y3);\n        return;\n    }\n    var projLen1 = dx * dx1 + dy * dy1;\n    var projLen2 = -dx * dx2 - dy * dy2;\n    var d1Sqr = cp1LenSqr - projLen1 * projLen1;\n    var d2Sqr = cp2LenSqr - projLen2 * projLen2;\n    if (d1Sqr < PIXEL_DISTANCE_SQR && projLen1 >= 0\n        && d2Sqr < PIXEL_DISTANCE_SQR && projLen2 >= 0) {\n        out.push(x3, y3);\n        return;\n    }\n    var tmpSegX = [];\n    var tmpSegY = [];\n    cubicSubdivide(x0, x1, x2, x3, 0.5, tmpSegX);\n    cubicSubdivide(y0, y1, y2, y3, 0.5, tmpSegY);\n    adpativeBezier(tmpSegX[0], tmpSegY[0], tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], tmpSegX[3], tmpSegY[3], out, scale);\n    adpativeBezier(tmpSegX[4], tmpSegY[4], tmpSegX[5], tmpSegY[5], tmpSegX[6], tmpSegY[6], tmpSegX[7], tmpSegY[7], out, scale);\n}\nexport function pathToPolygons(path, scale) {\n    var bezierArrayGroups = pathToBezierCurves(path);\n    var polygons = [];\n    scale = scale || 1;\n    for (var i = 0; i < bezierArrayGroups.length; i++) {\n        var beziers = bezierArrayGroups[i];\n        var polygon = [];\n        var x0 = beziers[0];\n        var y0 = beziers[1];\n        polygon.push(x0, y0);\n        for (var k = 2; k < beziers.length;) {\n            var x1 = beziers[k++];\n            var y1 = beziers[k++];\n            var x2 = beziers[k++];\n            var y2 = beziers[k++];\n            var x3 = beziers[k++];\n            var y3 = beziers[k++];\n            adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, polygon, scale);\n            x0 = x3;\n            y0 = y3;\n        }\n        polygons.push(polygon);\n    }\n    return polygons;\n}\n"]},"metadata":{},"sourceType":"module"}