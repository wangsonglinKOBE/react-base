{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\n/**\n * Caution: If the mechanism should be changed some day, these cases\n * should be considered:\n *\n * (1) In `merge option` mode, if using the same option to call `setOption`\n * many times, the result should be the same (try our best to ensure that).\n * (2) In `merge option` mode, if a component has no id/name specified, it\n * will be merged by index, and the result sequence of the components is\n * consistent to the original sequence.\n * (3) In `replaceMerge` mode, keep the result sequence of the components is\n * consistent to the original sequence, even though there might result in \"hole\".\n * (4) `reset` feature (in toolbox). Find detailed info in comments about\n * `mergeOption` in module:echarts/model/OptionManager.\n */\n\nimport { each, filter, isArray, isObject, isString, createHashMap, assert, clone, merge, extend, mixin, isFunction } from 'zrender/lib/core/util';\nimport * as modelUtil from '../util/model';\nimport Model from './Model';\nimport ComponentModel from './Component';\nimport globalDefault from './globalDefault';\nimport { resetSourceDefaulter } from '../data/helper/sourceHelper';\nimport { concatInternalOptions } from './internalComponentCreator';\nimport { PaletteMixin } from './mixin/palette';\nimport { error } from '../util/log'; // -----------------------\n// Internal method names:\n// -----------------------\n\nvar reCreateSeriesIndices;\nvar assertSeriesInitialized;\nvar initBase;\nvar OPTION_INNER_KEY = '\\0_ec_inner';\nvar OPTION_INNER_VALUE = 1;\nvar BUITIN_COMPONENTS_MAP = {\n  grid: 'GridComponent',\n  polar: 'PolarComponent',\n  geo: 'GeoComponent',\n  singleAxis: 'SingleAxisComponent',\n  parallel: 'ParallelComponent',\n  calendar: 'CalendarComponent',\n  graphic: 'GraphicComponent',\n  toolbox: 'ToolboxComponent',\n  tooltip: 'TooltipComponent',\n  axisPointer: 'AxisPointerComponent',\n  brush: 'BrushComponent',\n  title: 'TitleComponent',\n  timeline: 'TimelineComponent',\n  markPoint: 'MarkPointComponent',\n  markLine: 'MarkLineComponent',\n  markArea: 'MarkAreaComponent',\n  legend: 'LegendComponent',\n  dataZoom: 'DataZoomComponent',\n  visualMap: 'VisualMapComponent',\n  // aria: 'AriaComponent',\n  // dataset: 'DatasetComponent',\n  // Dependencies\n  xAxis: 'GridComponent',\n  yAxis: 'GridComponent',\n  angleAxis: 'PolarComponent',\n  radiusAxis: 'PolarComponent'\n};\nvar BUILTIN_CHARTS_MAP = {\n  line: 'LineChart',\n  bar: 'BarChart',\n  pie: 'PieChart',\n  scatter: 'ScatterChart',\n  radar: 'RadarChart',\n  map: 'MapChart',\n  tree: 'TreeChart',\n  treemap: 'TreemapChart',\n  graph: 'GraphChart',\n  gauge: 'GaugeChart',\n  funnel: 'FunnelChart',\n  parallel: 'ParallelChart',\n  sankey: 'SankeyChart',\n  boxplot: 'BoxplotChart',\n  candlestick: 'CandlestickChart',\n  effectScatter: 'EffectScatterChart',\n  lines: 'LinesChart',\n  heatmap: 'HeatmapChart',\n  pictorialBar: 'PictorialBarChart',\n  themeRiver: 'ThemeRiverChart',\n  sunburst: 'SunburstChart',\n  custom: 'CustomChart'\n};\nvar componetsMissingLogPrinted = {};\n\nfunction checkMissingComponents(option) {\n  each(option, function (componentOption, mainType) {\n    if (!ComponentModel.hasClass(mainType)) {\n      var componentImportName = BUITIN_COMPONENTS_MAP[mainType];\n\n      if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {\n        error(\"Component \" + mainType + \" is used but not imported.\\nimport { \" + componentImportName + \" } from 'echarts/components';\\necharts.use([\" + componentImportName + \"]);\");\n        componetsMissingLogPrinted[componentImportName] = true;\n      }\n    }\n  });\n}\n\nvar GlobalModel =\n/** @class */\nfunction (_super) {\n  __extends(GlobalModel, _super);\n\n  function GlobalModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  GlobalModel.prototype.init = function (option, parentModel, ecModel, theme, locale, optionManager) {\n    theme = theme || {};\n    this.option = null; // Mark as not initialized.\n\n    this._theme = new Model(theme);\n    this._locale = new Model(locale);\n    this._optionManager = optionManager;\n  };\n\n  GlobalModel.prototype.setOption = function (option, opts, optionPreprocessorFuncs) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(option != null, 'option is null/undefined');\n      assert(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, 'please use chart.getOption()');\n    }\n\n    var innerOpt = normalizeSetOptionInput(opts);\n\n    this._optionManager.setOption(option, optionPreprocessorFuncs, innerOpt);\n\n    this._resetOption(null, innerOpt);\n  };\n  /**\n   * @param type null/undefined: reset all.\n   *        'recreate': force recreate all.\n   *        'timeline': only reset timeline option\n   *        'media': only reset media query option\n   * @return Whether option changed.\n   */\n\n\n  GlobalModel.prototype.resetOption = function (type, opt) {\n    return this._resetOption(type, normalizeSetOptionInput(opt));\n  };\n\n  GlobalModel.prototype._resetOption = function (type, opt) {\n    var optionChanged = false;\n    var optionManager = this._optionManager;\n\n    if (!type || type === 'recreate') {\n      var baseOption = optionManager.mountOption(type === 'recreate');\n\n      if (process.env.NODE_ENV !== 'production') {\n        checkMissingComponents(baseOption);\n      }\n\n      if (!this.option || type === 'recreate') {\n        initBase(this, baseOption);\n      } else {\n        this.restoreData();\n\n        this._mergeOption(baseOption, opt);\n      }\n\n      optionChanged = true;\n    }\n\n    if (type === 'timeline' || type === 'media') {\n      this.restoreData();\n    } // By design, if `setOption(option2)` at the second time, and `option2` is a `ECUnitOption`,\n    // it should better not have the same props with `MediaUnit['option']`.\n    // Becuase either `option2` or `MediaUnit['option']` will be always merged to \"current option\"\n    // rather than original \"baseOption\". If they both override a prop, the result might be\n    // unexpected when media state changed after `setOption` called.\n    // If we really need to modify a props in each `MediaUnit['option']`, use the full version\n    // (`{baseOption, media}`) in `setOption`.\n    // For `timeline`, the case is the same.\n\n\n    if (!type || type === 'recreate' || type === 'timeline') {\n      var timelineOption = optionManager.getTimelineOption(this);\n\n      if (timelineOption) {\n        optionChanged = true;\n\n        this._mergeOption(timelineOption, opt);\n      }\n    }\n\n    if (!type || type === 'recreate' || type === 'media') {\n      var mediaOptions = optionManager.getMediaOption(this);\n\n      if (mediaOptions.length) {\n        each(mediaOptions, function (mediaOption) {\n          optionChanged = true;\n\n          this._mergeOption(mediaOption, opt);\n        }, this);\n      }\n    }\n\n    return optionChanged;\n  };\n\n  GlobalModel.prototype.mergeOption = function (option) {\n    this._mergeOption(option, null);\n  };\n\n  GlobalModel.prototype._mergeOption = function (newOption, opt) {\n    var option = this.option;\n    var componentsMap = this._componentsMap;\n    var componentsCount = this._componentsCount;\n    var newCmptTypes = [];\n    var newCmptTypeMap = createHashMap();\n    var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;\n    resetSourceDefaulter(this); // If no component class, merge directly.\n    // For example: color, animaiton options, etc.\n\n    each(newOption, function (componentOption, mainType) {\n      if (componentOption == null) {\n        return;\n      }\n\n      if (!ComponentModel.hasClass(mainType)) {\n        // globalSettingTask.dirty();\n        option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);\n      } else if (mainType) {\n        newCmptTypes.push(mainType);\n        newCmptTypeMap.set(mainType, true);\n      }\n    });\n\n    if (replaceMergeMainTypeMap) {\n      // If there is a mainType `xxx` in `replaceMerge` but not declared in option,\n      // we trade it as it is declared in option as `{xxx: []}`. Because:\n      // (1) for normal merge, `{xxx: null/undefined}` are the same meaning as `{xxx: []}`.\n      // (2) some preprocessor may convert some of `{xxx: null/undefined}` to `{xxx: []}`.\n      replaceMergeMainTypeMap.each(function (val, mainTypeInReplaceMerge) {\n        if (ComponentModel.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {\n          newCmptTypes.push(mainTypeInReplaceMerge);\n          newCmptTypeMap.set(mainTypeInReplaceMerge, true);\n        }\n      });\n    }\n\n    ComponentModel.topologicalTravel(newCmptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n\n    function visitComponent(mainType) {\n      var newCmptOptionList = concatInternalOptions(this, mainType, modelUtil.normalizeToArray(newOption[mainType]));\n      var oldCmptList = componentsMap.get(mainType);\n      var mergeMode = // `!oldCmptList` means init. See the comment in `mappingToExists`\n      !oldCmptList ? 'replaceAll' : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? 'replaceMerge' : 'normalMerge';\n      var mappingResult = modelUtil.mappingToExists(oldCmptList, newCmptOptionList, mergeMode); // Set mainType and complete subType.\n\n      modelUtil.setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel); // Empty it before the travel, in order to prevent `this._componentsMap`\n      // from being used in the `init`/`mergeOption`/`optionUpdated` of some\n      // components, which is probably incorrect logic.\n\n      option[mainType] = null;\n      componentsMap.set(mainType, null);\n      componentsCount.set(mainType, 0);\n      var optionsByMainType = [];\n      var cmptsByMainType = [];\n      var cmptsCountByMainType = 0;\n      each(mappingResult, function (resultItem, index) {\n        var componentModel = resultItem.existing;\n        var newCmptOption = resultItem.newOption;\n\n        if (!newCmptOption) {\n          if (componentModel) {\n            // Consider where is no new option and should be merged using {},\n            // see removeEdgeAndAdd in topologicalTravel and\n            // ComponentModel.getAllClassMainTypes.\n            componentModel.mergeOption({}, this);\n            componentModel.optionUpdated({}, false);\n          } // If no both `resultItem.exist` and `resultItem.option`,\n          // either it is in `replaceMerge` and not matched by any id,\n          // or it has been removed in previous `replaceMerge` and left a \"hole\" in this component index.\n\n        } else {\n          var isSeriesType = mainType === 'series';\n          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType // Give a more detailed warn later if series don't exists\n          );\n\n          if (!ComponentModelClass) {\n            if (process.env.NODE_ENV !== 'production') {\n              var subType = resultItem.keyInfo.subType;\n              var seriesImportName = BUILTIN_CHARTS_MAP[subType];\n\n              if (!componetsMissingLogPrinted[subType]) {\n                componetsMissingLogPrinted[subType] = true;\n\n                if (seriesImportName) {\n                  error(\"Series \" + subType + \" is used but not imported.\\nimport { \" + seriesImportName + \" } from 'echarts/charts';\\necharts.use([\" + seriesImportName + \"]);\");\n                } else {\n                  error(\"Unkown series \" + subType);\n                }\n              }\n            }\n\n            return;\n          }\n\n          if (componentModel && componentModel.constructor === ComponentModelClass) {\n            componentModel.name = resultItem.keyInfo.name; // componentModel.settingTask && componentModel.settingTask.dirty();\n\n            componentModel.mergeOption(newCmptOption, this);\n            componentModel.optionUpdated(newCmptOption, false);\n          } else {\n            // PENDING Global as parent ?\n            var extraOpt = extend({\n              componentIndex: index\n            }, resultItem.keyInfo);\n            componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt); // Assign `keyInfo`\n\n            extend(componentModel, extraOpt);\n\n            if (resultItem.brandNew) {\n              componentModel.__requireNewView = true;\n            }\n\n            componentModel.init(newCmptOption, this, this); // Call optionUpdated after init.\n            // newCmptOption has been used as componentModel.option\n            // and may be merged with theme and default, so pass null\n            // to avoid confusion.\n\n            componentModel.optionUpdated(null, true);\n          }\n        }\n\n        if (componentModel) {\n          optionsByMainType.push(componentModel.option);\n          cmptsByMainType.push(componentModel);\n          cmptsCountByMainType++;\n        } else {\n          // Always do assign to avoid elided item in array.\n          optionsByMainType.push(void 0);\n          cmptsByMainType.push(void 0);\n        }\n      }, this);\n      option[mainType] = optionsByMainType;\n      componentsMap.set(mainType, cmptsByMainType);\n      componentsCount.set(mainType, cmptsCountByMainType); // Backup series for filtering.\n\n      if (mainType === 'series') {\n        reCreateSeriesIndices(this);\n      }\n    } // If no series declared, ensure `_seriesIndices` initialized.\n\n\n    if (!this._seriesIndices) {\n      reCreateSeriesIndices(this);\n    }\n  };\n  /**\n   * Get option for output (cloned option and inner info removed)\n   */\n\n\n  GlobalModel.prototype.getOption = function () {\n    var option = clone(this.option);\n    each(option, function (optInMainType, mainType) {\n      if (ComponentModel.hasClass(mainType)) {\n        var opts = modelUtil.normalizeToArray(optInMainType); // Inner cmpts need to be removed.\n        // Inner cmpts might not be at last since ec5.0, but still\n        // compatible for users: if inner cmpt at last, splice the returned array.\n\n        var realLen = opts.length;\n        var metNonInner = false;\n\n        for (var i = realLen - 1; i >= 0; i--) {\n          // Remove options with inner id.\n          if (opts[i] && !modelUtil.isComponentIdInternal(opts[i])) {\n            metNonInner = true;\n          } else {\n            opts[i] = null;\n            !metNonInner && realLen--;\n          }\n        }\n\n        opts.length = realLen;\n        option[mainType] = opts;\n      }\n    });\n    delete option[OPTION_INNER_KEY];\n    return option;\n  };\n\n  GlobalModel.prototype.getTheme = function () {\n    return this._theme;\n  };\n\n  GlobalModel.prototype.getLocaleModel = function () {\n    return this._locale;\n  };\n\n  GlobalModel.prototype.setUpdatePayload = function (payload) {\n    this._payload = payload;\n  };\n\n  GlobalModel.prototype.getUpdatePayload = function () {\n    return this._payload;\n  };\n  /**\n   * @param idx If not specified, return the first one.\n   */\n\n\n  GlobalModel.prototype.getComponent = function (mainType, idx) {\n    var list = this._componentsMap.get(mainType);\n\n    if (list) {\n      var cmpt = list[idx || 0];\n\n      if (cmpt) {\n        return cmpt;\n      } else if (idx == null) {\n        for (var i = 0; i < list.length; i++) {\n          if (list[i]) {\n            return list[i];\n          }\n        }\n      }\n    }\n  };\n  /**\n   * @return Never be null/undefined.\n   */\n\n\n  GlobalModel.prototype.queryComponents = function (condition) {\n    var mainType = condition.mainType;\n\n    if (!mainType) {\n      return [];\n    }\n\n    var index = condition.index;\n    var id = condition.id;\n    var name = condition.name;\n\n    var cmpts = this._componentsMap.get(mainType);\n\n    if (!cmpts || !cmpts.length) {\n      return [];\n    }\n\n    var result;\n\n    if (index != null) {\n      result = [];\n      each(modelUtil.normalizeToArray(index), function (idx) {\n        cmpts[idx] && result.push(cmpts[idx]);\n      });\n    } else if (id != null) {\n      result = queryByIdOrName('id', id, cmpts);\n    } else if (name != null) {\n      result = queryByIdOrName('name', name, cmpts);\n    } else {\n      // Return all non-empty components in that mainType\n      result = filter(cmpts, function (cmpt) {\n        return !!cmpt;\n      });\n    }\n\n    return filterBySubType(result, condition);\n  };\n  /**\n   * The interface is different from queryComponents,\n   * which is convenient for inner usage.\n   *\n   * @usage\n   * let result = findComponents(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n   * );\n   * let result = findComponents(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n   * );\n   * let result = findComponents(\n   *     {mainType: 'series',\n   *     filter: function (model, index) {...}}\n   * );\n   * // result like [component0, componnet1, ...]\n   */\n\n\n  GlobalModel.prototype.findComponents = function (condition) {\n    var query = condition.query;\n    var mainType = condition.mainType;\n    var queryCond = getQueryCond(query);\n    var result = queryCond ? this.queryComponents(queryCond) // Retrieve all non-empty components.\n    : filter(this._componentsMap.get(mainType), function (cmpt) {\n      return !!cmpt;\n    });\n    return doFilter(filterBySubType(result, condition));\n\n    function getQueryCond(q) {\n      var indexAttr = mainType + 'Index';\n      var idAttr = mainType + 'Id';\n      var nameAttr = mainType + 'Name';\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n        mainType: mainType,\n        // subType will be filtered finally.\n        index: q[indexAttr],\n        id: q[idAttr],\n        name: q[nameAttr]\n      } : null;\n    }\n\n    function doFilter(res) {\n      return condition.filter ? filter(res, condition.filter) : res;\n    }\n  };\n\n  GlobalModel.prototype.eachComponent = function (mainType, cb, context) {\n    var componentsMap = this._componentsMap;\n\n    if (isFunction(mainType)) {\n      var ctxForAll_1 = cb;\n      var cbForAll_1 = mainType;\n      componentsMap.each(function (cmpts, componentType) {\n        for (var i = 0; cmpts && i < cmpts.length; i++) {\n          var cmpt = cmpts[i];\n          cmpt && cbForAll_1.call(ctxForAll_1, componentType, cmpt, cmpt.componentIndex);\n        }\n      });\n    } else {\n      var cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject(mainType) ? this.findComponents(mainType) : null;\n\n      for (var i = 0; cmpts && i < cmpts.length; i++) {\n        var cmpt = cmpts[i];\n        cmpt && cb.call(context, cmpt, cmpt.componentIndex);\n      }\n    }\n  };\n  /**\n   * Get series list before filtered by name.\n   */\n\n\n  GlobalModel.prototype.getSeriesByName = function (name) {\n    var nameStr = modelUtil.convertOptionIdName(name, null);\n    return filter(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries && nameStr != null && oneSeries.name === nameStr;\n    });\n  };\n  /**\n   * Get series list before filtered by index.\n   */\n\n\n  GlobalModel.prototype.getSeriesByIndex = function (seriesIndex) {\n    return this._componentsMap.get('series')[seriesIndex];\n  };\n  /**\n   * Get series list before filtered by type.\n   * FIXME: rename to getRawSeriesByType?\n   */\n\n\n  GlobalModel.prototype.getSeriesByType = function (subType) {\n    return filter(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries && oneSeries.subType === subType;\n    });\n  };\n  /**\n   * Get all series before filtered.\n   */\n\n\n  GlobalModel.prototype.getSeries = function () {\n    return filter(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries;\n    });\n  };\n  /**\n   * Count series before filtered.\n   */\n\n\n  GlobalModel.prototype.getSeriesCount = function () {\n    return this._componentsCount.get('series');\n  };\n  /**\n   * After filtering, series may be different\n   * frome raw series.\n   */\n\n\n  GlobalModel.prototype.eachSeries = function (cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      cb.call(context, series, rawSeriesIndex);\n    }, this);\n  };\n  /**\n   * Iterate raw series before filtered.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n\n\n  GlobalModel.prototype.eachRawSeries = function (cb, context) {\n    each(this._componentsMap.get('series'), function (series) {\n      series && cb.call(context, series, series.componentIndex);\n    });\n  };\n  /**\n   * After filtering, series may be different.\n   * frome raw series.\n   */\n\n\n  GlobalModel.prototype.eachSeriesByType = function (subType, cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      if (series.subType === subType) {\n        cb.call(context, series, rawSeriesIndex);\n      }\n    }, this);\n  };\n  /**\n   * Iterate raw series before filtered of given type.\n   */\n\n\n  GlobalModel.prototype.eachRawSeriesByType = function (subType, cb, context) {\n    return each(this.getSeriesByType(subType), cb, context);\n  };\n\n  GlobalModel.prototype.isSeriesFiltered = function (seriesModel) {\n    assertSeriesInitialized(this);\n    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;\n  };\n\n  GlobalModel.prototype.getCurrentSeriesIndices = function () {\n    return (this._seriesIndices || []).slice();\n  };\n\n  GlobalModel.prototype.filterSeries = function (cb, context) {\n    assertSeriesInitialized(this);\n    var newSeriesIndices = [];\n    each(this._seriesIndices, function (seriesRawIdx) {\n      var series = this._componentsMap.get('series')[seriesRawIdx];\n\n      cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);\n    }, this);\n    this._seriesIndices = newSeriesIndices;\n    this._seriesIndicesMap = createHashMap(newSeriesIndices);\n  };\n\n  GlobalModel.prototype.restoreData = function (payload) {\n    reCreateSeriesIndices(this);\n    var componentsMap = this._componentsMap;\n    var componentTypes = [];\n    componentsMap.each(function (components, componentType) {\n      if (ComponentModel.hasClass(componentType)) {\n        componentTypes.push(componentType);\n      }\n    });\n    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType) {\n      each(componentsMap.get(componentType), function (component) {\n        if (component && (componentType !== 'series' || !isNotTargetSeries(component, payload))) {\n          component.restoreData();\n        }\n      });\n    });\n  };\n\n  GlobalModel.internalField = function () {\n    reCreateSeriesIndices = function (ecModel) {\n      var seriesIndices = ecModel._seriesIndices = [];\n      each(ecModel._componentsMap.get('series'), function (series) {\n        // series may have been removed by `replaceMerge`.\n        series && seriesIndices.push(series.componentIndex);\n      });\n      ecModel._seriesIndicesMap = createHashMap(seriesIndices);\n    };\n\n    assertSeriesInitialized = function (ecModel) {\n      // Components that use _seriesIndices should depends on series component,\n      // which make sure that their initialization is after series.\n      if (process.env.NODE_ENV !== 'production') {\n        if (!ecModel._seriesIndices) {\n          throw new Error('Option should contains series.');\n        }\n      }\n    };\n\n    initBase = function (ecModel, baseOption) {\n      // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n      // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n      ecModel.option = {};\n      ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE; // Init with series: [], in case of calling findSeries method\n      // before series initialized.\n\n      ecModel._componentsMap = createHashMap({\n        series: []\n      });\n      ecModel._componentsCount = createHashMap(); // If user spefied `option.aria`, aria will be enable. This detection should be\n      // performed before theme and globalDefault merge.\n\n      var airaOption = baseOption.aria;\n\n      if (isObject(airaOption) && airaOption.enabled == null) {\n        airaOption.enabled = true;\n      }\n\n      mergeTheme(baseOption, ecModel._theme.option); // TODO Needs clone when merging to the unexisted property\n\n      merge(baseOption, globalDefault, false);\n\n      ecModel._mergeOption(baseOption, null);\n    };\n  }();\n\n  return GlobalModel;\n}(Model);\n\nfunction isNotTargetSeries(seriesModel, payload) {\n  if (payload) {\n    var index = payload.seriesIndex;\n    var id = payload.seriesId;\n    var name_1 = payload.seriesName;\n    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;\n  }\n}\n\nfunction mergeTheme(option, theme) {\n  // PENDING\n  // NOT use `colorLayer` in theme if option has `color`\n  var notMergeColorLayer = option.color && !option.colorLayer;\n  each(theme, function (themeItem, name) {\n    if (name === 'colorLayer' && notMergeColorLayer) {\n      return;\n    } // If it is component model mainType, the model handles that merge later.\n    // otherwise, merge them here.\n\n\n    if (!ComponentModel.hasClass(name)) {\n      if (typeof themeItem === 'object') {\n        option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);\n      } else {\n        if (option[name] == null) {\n          option[name] = themeItem;\n        }\n      }\n    }\n  });\n}\n\nfunction queryByIdOrName(attr, idOrName, cmpts) {\n  // Here is a break from echarts4: string and number are\n  // treated as equal.\n  if (isArray(idOrName)) {\n    var keyMap_1 = createHashMap();\n    each(idOrName, function (idOrNameItem) {\n      if (idOrNameItem != null) {\n        var idName = modelUtil.convertOptionIdName(idOrNameItem, null);\n        idName != null && keyMap_1.set(idOrNameItem, true);\n      }\n    });\n    return filter(cmpts, function (cmpt) {\n      return cmpt && keyMap_1.get(cmpt[attr]);\n    });\n  } else {\n    var idName_1 = modelUtil.convertOptionIdName(idOrName, null);\n    return filter(cmpts, function (cmpt) {\n      return cmpt && idName_1 != null && cmpt[attr] === idName_1;\n    });\n  }\n}\n\nfunction filterBySubType(components, condition) {\n  // Using hasOwnProperty for restrict. Consider\n  // subType is undefined in user payload.\n  return condition.hasOwnProperty('subType') ? filter(components, function (cmpt) {\n    return cmpt && cmpt.subType === condition.subType;\n  }) : components;\n}\n\nfunction normalizeSetOptionInput(opts) {\n  var replaceMergeMainTypeMap = createHashMap();\n  opts && each(modelUtil.normalizeToArray(opts.replaceMerge), function (mainType) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(ComponentModel.hasClass(mainType), '\"' + mainType + '\" is not valid component main type in \"replaceMerge\"');\n    }\n\n    replaceMergeMainTypeMap.set(mainType, true);\n  });\n  return {\n    replaceMergeMainTypeMap: replaceMergeMainTypeMap\n  };\n}\n\nmixin(GlobalModel, PaletteMixin);\nexport default GlobalModel;","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/model/Global.js"],"names":["__extends","each","filter","isArray","isObject","isString","createHashMap","assert","clone","merge","extend","mixin","isFunction","modelUtil","Model","ComponentModel","globalDefault","resetSourceDefaulter","concatInternalOptions","PaletteMixin","error","reCreateSeriesIndices","assertSeriesInitialized","initBase","OPTION_INNER_KEY","OPTION_INNER_VALUE","BUITIN_COMPONENTS_MAP","grid","polar","geo","singleAxis","parallel","calendar","graphic","toolbox","tooltip","axisPointer","brush","title","timeline","markPoint","markLine","markArea","legend","dataZoom","visualMap","xAxis","yAxis","angleAxis","radiusAxis","BUILTIN_CHARTS_MAP","line","bar","pie","scatter","radar","map","tree","treemap","graph","gauge","funnel","sankey","boxplot","candlestick","effectScatter","lines","heatmap","pictorialBar","themeRiver","sunburst","custom","componetsMissingLogPrinted","checkMissingComponents","option","componentOption","mainType","hasClass","componentImportName","GlobalModel","_super","apply","arguments","prototype","init","parentModel","ecModel","theme","locale","optionManager","_theme","_locale","_optionManager","setOption","opts","optionPreprocessorFuncs","process","env","NODE_ENV","innerOpt","normalizeSetOptionInput","_resetOption","resetOption","type","opt","optionChanged","baseOption","mountOption","restoreData","_mergeOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","length","mediaOption","mergeOption","newOption","componentsMap","_componentsMap","componentsCount","_componentsCount","newCmptTypes","newCmptTypeMap","replaceMergeMainTypeMap","push","set","val","mainTypeInReplaceMerge","get","topologicalTravel","getAllClassMainTypes","visitComponent","newCmptOptionList","normalizeToArray","oldCmptList","mergeMode","mappingResult","mappingToExists","setComponentTypeToKeyInfo","optionsByMainType","cmptsByMainType","cmptsCountByMainType","resultItem","index","componentModel","existing","newCmptOption","optionUpdated","isSeriesType","ComponentModelClass","getClass","keyInfo","subType","seriesImportName","constructor","name","extraOpt","componentIndex","brandNew","__requireNewView","_seriesIndices","getOption","optInMainType","realLen","metNonInner","i","isComponentIdInternal","getTheme","getLocaleModel","setUpdatePayload","payload","_payload","getUpdatePayload","getComponent","idx","list","cmpt","queryComponents","condition","id","cmpts","result","queryByIdOrName","filterBySubType","findComponents","query","queryCond","getQueryCond","doFilter","q","indexAttr","idAttr","nameAttr","res","eachComponent","cb","context","ctxForAll_1","cbForAll_1","componentType","call","getSeriesByName","nameStr","convertOptionIdName","oneSeries","getSeriesByIndex","seriesIndex","getSeriesByType","getSeries","getSeriesCount","eachSeries","rawSeriesIndex","series","eachRawSeries","eachSeriesByType","eachRawSeriesByType","isSeriesFiltered","seriesModel","_seriesIndicesMap","getCurrentSeriesIndices","slice","filterSeries","newSeriesIndices","seriesRawIdx","componentTypes","components","component","isNotTargetSeries","internalField","seriesIndices","Error","airaOption","aria","enabled","mergeTheme","seriesId","name_1","seriesName","notMergeColorLayer","color","colorLayer","themeItem","attr","idOrName","keyMap_1","idOrNameItem","idName","idName_1","hasOwnProperty","replaceMerge"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\n/**\n * Caution: If the mechanism should be changed some day, these cases\n * should be considered:\n *\n * (1) In `merge option` mode, if using the same option to call `setOption`\n * many times, the result should be the same (try our best to ensure that).\n * (2) In `merge option` mode, if a component has no id/name specified, it\n * will be merged by index, and the result sequence of the components is\n * consistent to the original sequence.\n * (3) In `replaceMerge` mode, keep the result sequence of the components is\n * consistent to the original sequence, even though there might result in \"hole\".\n * (4) `reset` feature (in toolbox). Find detailed info in comments about\n * `mergeOption` in module:echarts/model/OptionManager.\n */\n\nimport { each, filter, isArray, isObject, isString, createHashMap, assert, clone, merge, extend, mixin, isFunction } from 'zrender/lib/core/util';\nimport * as modelUtil from '../util/model';\nimport Model from './Model';\nimport ComponentModel from './Component';\nimport globalDefault from './globalDefault';\nimport { resetSourceDefaulter } from '../data/helper/sourceHelper';\nimport { concatInternalOptions } from './internalComponentCreator';\nimport { PaletteMixin } from './mixin/palette';\nimport { error } from '../util/log'; // -----------------------\n// Internal method names:\n// -----------------------\n\nvar reCreateSeriesIndices;\nvar assertSeriesInitialized;\nvar initBase;\nvar OPTION_INNER_KEY = '\\0_ec_inner';\nvar OPTION_INNER_VALUE = 1;\nvar BUITIN_COMPONENTS_MAP = {\n  grid: 'GridComponent',\n  polar: 'PolarComponent',\n  geo: 'GeoComponent',\n  singleAxis: 'SingleAxisComponent',\n  parallel: 'ParallelComponent',\n  calendar: 'CalendarComponent',\n  graphic: 'GraphicComponent',\n  toolbox: 'ToolboxComponent',\n  tooltip: 'TooltipComponent',\n  axisPointer: 'AxisPointerComponent',\n  brush: 'BrushComponent',\n  title: 'TitleComponent',\n  timeline: 'TimelineComponent',\n  markPoint: 'MarkPointComponent',\n  markLine: 'MarkLineComponent',\n  markArea: 'MarkAreaComponent',\n  legend: 'LegendComponent',\n  dataZoom: 'DataZoomComponent',\n  visualMap: 'VisualMapComponent',\n  // aria: 'AriaComponent',\n  // dataset: 'DatasetComponent',\n  // Dependencies\n  xAxis: 'GridComponent',\n  yAxis: 'GridComponent',\n  angleAxis: 'PolarComponent',\n  radiusAxis: 'PolarComponent'\n};\nvar BUILTIN_CHARTS_MAP = {\n  line: 'LineChart',\n  bar: 'BarChart',\n  pie: 'PieChart',\n  scatter: 'ScatterChart',\n  radar: 'RadarChart',\n  map: 'MapChart',\n  tree: 'TreeChart',\n  treemap: 'TreemapChart',\n  graph: 'GraphChart',\n  gauge: 'GaugeChart',\n  funnel: 'FunnelChart',\n  parallel: 'ParallelChart',\n  sankey: 'SankeyChart',\n  boxplot: 'BoxplotChart',\n  candlestick: 'CandlestickChart',\n  effectScatter: 'EffectScatterChart',\n  lines: 'LinesChart',\n  heatmap: 'HeatmapChart',\n  pictorialBar: 'PictorialBarChart',\n  themeRiver: 'ThemeRiverChart',\n  sunburst: 'SunburstChart',\n  custom: 'CustomChart'\n};\nvar componetsMissingLogPrinted = {};\n\nfunction checkMissingComponents(option) {\n  each(option, function (componentOption, mainType) {\n    if (!ComponentModel.hasClass(mainType)) {\n      var componentImportName = BUITIN_COMPONENTS_MAP[mainType];\n\n      if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {\n        error(\"Component \" + mainType + \" is used but not imported.\\nimport { \" + componentImportName + \" } from 'echarts/components';\\necharts.use([\" + componentImportName + \"]);\");\n        componetsMissingLogPrinted[componentImportName] = true;\n      }\n    }\n  });\n}\n\nvar GlobalModel =\n/** @class */\nfunction (_super) {\n  __extends(GlobalModel, _super);\n\n  function GlobalModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  GlobalModel.prototype.init = function (option, parentModel, ecModel, theme, locale, optionManager) {\n    theme = theme || {};\n    this.option = null; // Mark as not initialized.\n\n    this._theme = new Model(theme);\n    this._locale = new Model(locale);\n    this._optionManager = optionManager;\n  };\n\n  GlobalModel.prototype.setOption = function (option, opts, optionPreprocessorFuncs) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(option != null, 'option is null/undefined');\n      assert(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, 'please use chart.getOption()');\n    }\n\n    var innerOpt = normalizeSetOptionInput(opts);\n\n    this._optionManager.setOption(option, optionPreprocessorFuncs, innerOpt);\n\n    this._resetOption(null, innerOpt);\n  };\n  /**\n   * @param type null/undefined: reset all.\n   *        'recreate': force recreate all.\n   *        'timeline': only reset timeline option\n   *        'media': only reset media query option\n   * @return Whether option changed.\n   */\n\n\n  GlobalModel.prototype.resetOption = function (type, opt) {\n    return this._resetOption(type, normalizeSetOptionInput(opt));\n  };\n\n  GlobalModel.prototype._resetOption = function (type, opt) {\n    var optionChanged = false;\n    var optionManager = this._optionManager;\n\n    if (!type || type === 'recreate') {\n      var baseOption = optionManager.mountOption(type === 'recreate');\n\n      if (process.env.NODE_ENV !== 'production') {\n        checkMissingComponents(baseOption);\n      }\n\n      if (!this.option || type === 'recreate') {\n        initBase(this, baseOption);\n      } else {\n        this.restoreData();\n\n        this._mergeOption(baseOption, opt);\n      }\n\n      optionChanged = true;\n    }\n\n    if (type === 'timeline' || type === 'media') {\n      this.restoreData();\n    } // By design, if `setOption(option2)` at the second time, and `option2` is a `ECUnitOption`,\n    // it should better not have the same props with `MediaUnit['option']`.\n    // Becuase either `option2` or `MediaUnit['option']` will be always merged to \"current option\"\n    // rather than original \"baseOption\". If they both override a prop, the result might be\n    // unexpected when media state changed after `setOption` called.\n    // If we really need to modify a props in each `MediaUnit['option']`, use the full version\n    // (`{baseOption, media}`) in `setOption`.\n    // For `timeline`, the case is the same.\n\n\n    if (!type || type === 'recreate' || type === 'timeline') {\n      var timelineOption = optionManager.getTimelineOption(this);\n\n      if (timelineOption) {\n        optionChanged = true;\n\n        this._mergeOption(timelineOption, opt);\n      }\n    }\n\n    if (!type || type === 'recreate' || type === 'media') {\n      var mediaOptions = optionManager.getMediaOption(this);\n\n      if (mediaOptions.length) {\n        each(mediaOptions, function (mediaOption) {\n          optionChanged = true;\n\n          this._mergeOption(mediaOption, opt);\n        }, this);\n      }\n    }\n\n    return optionChanged;\n  };\n\n  GlobalModel.prototype.mergeOption = function (option) {\n    this._mergeOption(option, null);\n  };\n\n  GlobalModel.prototype._mergeOption = function (newOption, opt) {\n    var option = this.option;\n    var componentsMap = this._componentsMap;\n    var componentsCount = this._componentsCount;\n    var newCmptTypes = [];\n    var newCmptTypeMap = createHashMap();\n    var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;\n    resetSourceDefaulter(this); // If no component class, merge directly.\n    // For example: color, animaiton options, etc.\n\n    each(newOption, function (componentOption, mainType) {\n      if (componentOption == null) {\n        return;\n      }\n\n      if (!ComponentModel.hasClass(mainType)) {\n        // globalSettingTask.dirty();\n        option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);\n      } else if (mainType) {\n        newCmptTypes.push(mainType);\n        newCmptTypeMap.set(mainType, true);\n      }\n    });\n\n    if (replaceMergeMainTypeMap) {\n      // If there is a mainType `xxx` in `replaceMerge` but not declared in option,\n      // we trade it as it is declared in option as `{xxx: []}`. Because:\n      // (1) for normal merge, `{xxx: null/undefined}` are the same meaning as `{xxx: []}`.\n      // (2) some preprocessor may convert some of `{xxx: null/undefined}` to `{xxx: []}`.\n      replaceMergeMainTypeMap.each(function (val, mainTypeInReplaceMerge) {\n        if (ComponentModel.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {\n          newCmptTypes.push(mainTypeInReplaceMerge);\n          newCmptTypeMap.set(mainTypeInReplaceMerge, true);\n        }\n      });\n    }\n\n    ComponentModel.topologicalTravel(newCmptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n\n    function visitComponent(mainType) {\n      var newCmptOptionList = concatInternalOptions(this, mainType, modelUtil.normalizeToArray(newOption[mainType]));\n      var oldCmptList = componentsMap.get(mainType);\n      var mergeMode = // `!oldCmptList` means init. See the comment in `mappingToExists`\n      !oldCmptList ? 'replaceAll' : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? 'replaceMerge' : 'normalMerge';\n      var mappingResult = modelUtil.mappingToExists(oldCmptList, newCmptOptionList, mergeMode); // Set mainType and complete subType.\n\n      modelUtil.setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel); // Empty it before the travel, in order to prevent `this._componentsMap`\n      // from being used in the `init`/`mergeOption`/`optionUpdated` of some\n      // components, which is probably incorrect logic.\n\n      option[mainType] = null;\n      componentsMap.set(mainType, null);\n      componentsCount.set(mainType, 0);\n      var optionsByMainType = [];\n      var cmptsByMainType = [];\n      var cmptsCountByMainType = 0;\n      each(mappingResult, function (resultItem, index) {\n        var componentModel = resultItem.existing;\n        var newCmptOption = resultItem.newOption;\n\n        if (!newCmptOption) {\n          if (componentModel) {\n            // Consider where is no new option and should be merged using {},\n            // see removeEdgeAndAdd in topologicalTravel and\n            // ComponentModel.getAllClassMainTypes.\n            componentModel.mergeOption({}, this);\n            componentModel.optionUpdated({}, false);\n          } // If no both `resultItem.exist` and `resultItem.option`,\n          // either it is in `replaceMerge` and not matched by any id,\n          // or it has been removed in previous `replaceMerge` and left a \"hole\" in this component index.\n\n        } else {\n          var isSeriesType = mainType === 'series';\n          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType // Give a more detailed warn later if series don't exists\n          );\n\n          if (!ComponentModelClass) {\n            if (process.env.NODE_ENV !== 'production') {\n              var subType = resultItem.keyInfo.subType;\n              var seriesImportName = BUILTIN_CHARTS_MAP[subType];\n\n              if (!componetsMissingLogPrinted[subType]) {\n                componetsMissingLogPrinted[subType] = true;\n\n                if (seriesImportName) {\n                  error(\"Series \" + subType + \" is used but not imported.\\nimport { \" + seriesImportName + \" } from 'echarts/charts';\\necharts.use([\" + seriesImportName + \"]);\");\n                } else {\n                  error(\"Unkown series \" + subType);\n                }\n              }\n            }\n\n            return;\n          }\n\n          if (componentModel && componentModel.constructor === ComponentModelClass) {\n            componentModel.name = resultItem.keyInfo.name; // componentModel.settingTask && componentModel.settingTask.dirty();\n\n            componentModel.mergeOption(newCmptOption, this);\n            componentModel.optionUpdated(newCmptOption, false);\n          } else {\n            // PENDING Global as parent ?\n            var extraOpt = extend({\n              componentIndex: index\n            }, resultItem.keyInfo);\n            componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt); // Assign `keyInfo`\n\n            extend(componentModel, extraOpt);\n\n            if (resultItem.brandNew) {\n              componentModel.__requireNewView = true;\n            }\n\n            componentModel.init(newCmptOption, this, this); // Call optionUpdated after init.\n            // newCmptOption has been used as componentModel.option\n            // and may be merged with theme and default, so pass null\n            // to avoid confusion.\n\n            componentModel.optionUpdated(null, true);\n          }\n        }\n\n        if (componentModel) {\n          optionsByMainType.push(componentModel.option);\n          cmptsByMainType.push(componentModel);\n          cmptsCountByMainType++;\n        } else {\n          // Always do assign to avoid elided item in array.\n          optionsByMainType.push(void 0);\n          cmptsByMainType.push(void 0);\n        }\n      }, this);\n      option[mainType] = optionsByMainType;\n      componentsMap.set(mainType, cmptsByMainType);\n      componentsCount.set(mainType, cmptsCountByMainType); // Backup series for filtering.\n\n      if (mainType === 'series') {\n        reCreateSeriesIndices(this);\n      }\n    } // If no series declared, ensure `_seriesIndices` initialized.\n\n\n    if (!this._seriesIndices) {\n      reCreateSeriesIndices(this);\n    }\n  };\n  /**\n   * Get option for output (cloned option and inner info removed)\n   */\n\n\n  GlobalModel.prototype.getOption = function () {\n    var option = clone(this.option);\n    each(option, function (optInMainType, mainType) {\n      if (ComponentModel.hasClass(mainType)) {\n        var opts = modelUtil.normalizeToArray(optInMainType); // Inner cmpts need to be removed.\n        // Inner cmpts might not be at last since ec5.0, but still\n        // compatible for users: if inner cmpt at last, splice the returned array.\n\n        var realLen = opts.length;\n        var metNonInner = false;\n\n        for (var i = realLen - 1; i >= 0; i--) {\n          // Remove options with inner id.\n          if (opts[i] && !modelUtil.isComponentIdInternal(opts[i])) {\n            metNonInner = true;\n          } else {\n            opts[i] = null;\n            !metNonInner && realLen--;\n          }\n        }\n\n        opts.length = realLen;\n        option[mainType] = opts;\n      }\n    });\n    delete option[OPTION_INNER_KEY];\n    return option;\n  };\n\n  GlobalModel.prototype.getTheme = function () {\n    return this._theme;\n  };\n\n  GlobalModel.prototype.getLocaleModel = function () {\n    return this._locale;\n  };\n\n  GlobalModel.prototype.setUpdatePayload = function (payload) {\n    this._payload = payload;\n  };\n\n  GlobalModel.prototype.getUpdatePayload = function () {\n    return this._payload;\n  };\n  /**\n   * @param idx If not specified, return the first one.\n   */\n\n\n  GlobalModel.prototype.getComponent = function (mainType, idx) {\n    var list = this._componentsMap.get(mainType);\n\n    if (list) {\n      var cmpt = list[idx || 0];\n\n      if (cmpt) {\n        return cmpt;\n      } else if (idx == null) {\n        for (var i = 0; i < list.length; i++) {\n          if (list[i]) {\n            return list[i];\n          }\n        }\n      }\n    }\n  };\n  /**\n   * @return Never be null/undefined.\n   */\n\n\n  GlobalModel.prototype.queryComponents = function (condition) {\n    var mainType = condition.mainType;\n\n    if (!mainType) {\n      return [];\n    }\n\n    var index = condition.index;\n    var id = condition.id;\n    var name = condition.name;\n\n    var cmpts = this._componentsMap.get(mainType);\n\n    if (!cmpts || !cmpts.length) {\n      return [];\n    }\n\n    var result;\n\n    if (index != null) {\n      result = [];\n      each(modelUtil.normalizeToArray(index), function (idx) {\n        cmpts[idx] && result.push(cmpts[idx]);\n      });\n    } else if (id != null) {\n      result = queryByIdOrName('id', id, cmpts);\n    } else if (name != null) {\n      result = queryByIdOrName('name', name, cmpts);\n    } else {\n      // Return all non-empty components in that mainType\n      result = filter(cmpts, function (cmpt) {\n        return !!cmpt;\n      });\n    }\n\n    return filterBySubType(result, condition);\n  };\n  /**\n   * The interface is different from queryComponents,\n   * which is convenient for inner usage.\n   *\n   * @usage\n   * let result = findComponents(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n   * );\n   * let result = findComponents(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n   * );\n   * let result = findComponents(\n   *     {mainType: 'series',\n   *     filter: function (model, index) {...}}\n   * );\n   * // result like [component0, componnet1, ...]\n   */\n\n\n  GlobalModel.prototype.findComponents = function (condition) {\n    var query = condition.query;\n    var mainType = condition.mainType;\n    var queryCond = getQueryCond(query);\n    var result = queryCond ? this.queryComponents(queryCond) // Retrieve all non-empty components.\n    : filter(this._componentsMap.get(mainType), function (cmpt) {\n      return !!cmpt;\n    });\n    return doFilter(filterBySubType(result, condition));\n\n    function getQueryCond(q) {\n      var indexAttr = mainType + 'Index';\n      var idAttr = mainType + 'Id';\n      var nameAttr = mainType + 'Name';\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n        mainType: mainType,\n        // subType will be filtered finally.\n        index: q[indexAttr],\n        id: q[idAttr],\n        name: q[nameAttr]\n      } : null;\n    }\n\n    function doFilter(res) {\n      return condition.filter ? filter(res, condition.filter) : res;\n    }\n  };\n\n  GlobalModel.prototype.eachComponent = function (mainType, cb, context) {\n    var componentsMap = this._componentsMap;\n\n    if (isFunction(mainType)) {\n      var ctxForAll_1 = cb;\n      var cbForAll_1 = mainType;\n      componentsMap.each(function (cmpts, componentType) {\n        for (var i = 0; cmpts && i < cmpts.length; i++) {\n          var cmpt = cmpts[i];\n          cmpt && cbForAll_1.call(ctxForAll_1, componentType, cmpt, cmpt.componentIndex);\n        }\n      });\n    } else {\n      var cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject(mainType) ? this.findComponents(mainType) : null;\n\n      for (var i = 0; cmpts && i < cmpts.length; i++) {\n        var cmpt = cmpts[i];\n        cmpt && cb.call(context, cmpt, cmpt.componentIndex);\n      }\n    }\n  };\n  /**\n   * Get series list before filtered by name.\n   */\n\n\n  GlobalModel.prototype.getSeriesByName = function (name) {\n    var nameStr = modelUtil.convertOptionIdName(name, null);\n    return filter(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries && nameStr != null && oneSeries.name === nameStr;\n    });\n  };\n  /**\n   * Get series list before filtered by index.\n   */\n\n\n  GlobalModel.prototype.getSeriesByIndex = function (seriesIndex) {\n    return this._componentsMap.get('series')[seriesIndex];\n  };\n  /**\n   * Get series list before filtered by type.\n   * FIXME: rename to getRawSeriesByType?\n   */\n\n\n  GlobalModel.prototype.getSeriesByType = function (subType) {\n    return filter(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries && oneSeries.subType === subType;\n    });\n  };\n  /**\n   * Get all series before filtered.\n   */\n\n\n  GlobalModel.prototype.getSeries = function () {\n    return filter(this._componentsMap.get('series'), function (oneSeries) {\n      return !!oneSeries;\n    });\n  };\n  /**\n   * Count series before filtered.\n   */\n\n\n  GlobalModel.prototype.getSeriesCount = function () {\n    return this._componentsCount.get('series');\n  };\n  /**\n   * After filtering, series may be different\n   * frome raw series.\n   */\n\n\n  GlobalModel.prototype.eachSeries = function (cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      cb.call(context, series, rawSeriesIndex);\n    }, this);\n  };\n  /**\n   * Iterate raw series before filtered.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n\n\n  GlobalModel.prototype.eachRawSeries = function (cb, context) {\n    each(this._componentsMap.get('series'), function (series) {\n      series && cb.call(context, series, series.componentIndex);\n    });\n  };\n  /**\n   * After filtering, series may be different.\n   * frome raw series.\n   */\n\n\n  GlobalModel.prototype.eachSeriesByType = function (subType, cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      if (series.subType === subType) {\n        cb.call(context, series, rawSeriesIndex);\n      }\n    }, this);\n  };\n  /**\n   * Iterate raw series before filtered of given type.\n   */\n\n\n  GlobalModel.prototype.eachRawSeriesByType = function (subType, cb, context) {\n    return each(this.getSeriesByType(subType), cb, context);\n  };\n\n  GlobalModel.prototype.isSeriesFiltered = function (seriesModel) {\n    assertSeriesInitialized(this);\n    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;\n  };\n\n  GlobalModel.prototype.getCurrentSeriesIndices = function () {\n    return (this._seriesIndices || []).slice();\n  };\n\n  GlobalModel.prototype.filterSeries = function (cb, context) {\n    assertSeriesInitialized(this);\n    var newSeriesIndices = [];\n    each(this._seriesIndices, function (seriesRawIdx) {\n      var series = this._componentsMap.get('series')[seriesRawIdx];\n\n      cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);\n    }, this);\n    this._seriesIndices = newSeriesIndices;\n    this._seriesIndicesMap = createHashMap(newSeriesIndices);\n  };\n\n  GlobalModel.prototype.restoreData = function (payload) {\n    reCreateSeriesIndices(this);\n    var componentsMap = this._componentsMap;\n    var componentTypes = [];\n    componentsMap.each(function (components, componentType) {\n      if (ComponentModel.hasClass(componentType)) {\n        componentTypes.push(componentType);\n      }\n    });\n    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType) {\n      each(componentsMap.get(componentType), function (component) {\n        if (component && (componentType !== 'series' || !isNotTargetSeries(component, payload))) {\n          component.restoreData();\n        }\n      });\n    });\n  };\n\n  GlobalModel.internalField = function () {\n    reCreateSeriesIndices = function (ecModel) {\n      var seriesIndices = ecModel._seriesIndices = [];\n      each(ecModel._componentsMap.get('series'), function (series) {\n        // series may have been removed by `replaceMerge`.\n        series && seriesIndices.push(series.componentIndex);\n      });\n      ecModel._seriesIndicesMap = createHashMap(seriesIndices);\n    };\n\n    assertSeriesInitialized = function (ecModel) {\n      // Components that use _seriesIndices should depends on series component,\n      // which make sure that their initialization is after series.\n      if (process.env.NODE_ENV !== 'production') {\n        if (!ecModel._seriesIndices) {\n          throw new Error('Option should contains series.');\n        }\n      }\n    };\n\n    initBase = function (ecModel, baseOption) {\n      // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n      // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n      ecModel.option = {};\n      ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE; // Init with series: [], in case of calling findSeries method\n      // before series initialized.\n\n      ecModel._componentsMap = createHashMap({\n        series: []\n      });\n      ecModel._componentsCount = createHashMap(); // If user spefied `option.aria`, aria will be enable. This detection should be\n      // performed before theme and globalDefault merge.\n\n      var airaOption = baseOption.aria;\n\n      if (isObject(airaOption) && airaOption.enabled == null) {\n        airaOption.enabled = true;\n      }\n\n      mergeTheme(baseOption, ecModel._theme.option); // TODO Needs clone when merging to the unexisted property\n\n      merge(baseOption, globalDefault, false);\n\n      ecModel._mergeOption(baseOption, null);\n    };\n  }();\n\n  return GlobalModel;\n}(Model);\n\nfunction isNotTargetSeries(seriesModel, payload) {\n  if (payload) {\n    var index = payload.seriesIndex;\n    var id = payload.seriesId;\n    var name_1 = payload.seriesName;\n    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;\n  }\n}\n\nfunction mergeTheme(option, theme) {\n  // PENDING\n  // NOT use `colorLayer` in theme if option has `color`\n  var notMergeColorLayer = option.color && !option.colorLayer;\n  each(theme, function (themeItem, name) {\n    if (name === 'colorLayer' && notMergeColorLayer) {\n      return;\n    } // If it is component model mainType, the model handles that merge later.\n    // otherwise, merge them here.\n\n\n    if (!ComponentModel.hasClass(name)) {\n      if (typeof themeItem === 'object') {\n        option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);\n      } else {\n        if (option[name] == null) {\n          option[name] = themeItem;\n        }\n      }\n    }\n  });\n}\n\nfunction queryByIdOrName(attr, idOrName, cmpts) {\n  // Here is a break from echarts4: string and number are\n  // treated as equal.\n  if (isArray(idOrName)) {\n    var keyMap_1 = createHashMap();\n    each(idOrName, function (idOrNameItem) {\n      if (idOrNameItem != null) {\n        var idName = modelUtil.convertOptionIdName(idOrNameItem, null);\n        idName != null && keyMap_1.set(idOrNameItem, true);\n      }\n    });\n    return filter(cmpts, function (cmpt) {\n      return cmpt && keyMap_1.get(cmpt[attr]);\n    });\n  } else {\n    var idName_1 = modelUtil.convertOptionIdName(idOrName, null);\n    return filter(cmpts, function (cmpt) {\n      return cmpt && idName_1 != null && cmpt[attr] === idName_1;\n    });\n  }\n}\n\nfunction filterBySubType(components, condition) {\n  // Using hasOwnProperty for restrict. Consider\n  // subType is undefined in user payload.\n  return condition.hasOwnProperty('subType') ? filter(components, function (cmpt) {\n    return cmpt && cmpt.subType === condition.subType;\n  }) : components;\n}\n\nfunction normalizeSetOptionInput(opts) {\n  var replaceMergeMainTypeMap = createHashMap();\n  opts && each(modelUtil.normalizeToArray(opts.replaceMerge), function (mainType) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(ComponentModel.hasClass(mainType), '\"' + mainType + '\" is not valid component main type in \"replaceMerge\"');\n    }\n\n    replaceMergeMainTypeMap.set(mainType, true);\n  });\n  return {\n    replaceMergeMainTypeMap: replaceMergeMainTypeMap\n  };\n}\n\nmixin(GlobalModel, PaletteMixin);\nexport default GlobalModel;"]},"metadata":{},"sourceType":"module"}