{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { keys, isArray, map, isObject, isString, isRegExp, isArrayLike, hasOwn } from 'zrender/lib/core/util';\nimport { throwError, makePrintable } from './log';\nimport { getRawValueParser, createFilterComparator } from '../data/helper/dataValueHelper';\n;\nvar RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {\n  value: 'eq',\n  // PENDING: not good for literal semantic?\n  '<': 'lt',\n  '<=': 'lte',\n  '>': 'gt',\n  '>=': 'gte',\n  '=': 'eq',\n  '!=': 'ne',\n  '<>': 'ne' // Might mileading for sake of the different between '==' and '===',\n  // So dont support them.\n  // '==': 'eq',\n  // '===': 'seq',\n  // '!==': 'sne'\n  // PENDING: Whether support some common alias \"ge\", \"le\", \"neq\"?\n  // ge: 'gte',\n  // le: 'lte',\n  // neq: 'ne',\n\n}; // type RelationalExpressionOpEvaluate = (tarVal: unknown, condVal: unknown) => boolean;\n\nvar RegExpEvaluator =\n/** @class */\nfunction () {\n  function RegExpEvaluator(rVal) {\n    // Support condVal: RegExp | string\n    var condValue = this._condVal = isString(rVal) ? new RegExp(rVal) : isRegExp(rVal) ? rVal : null;\n\n    if (condValue == null) {\n      var errMsg = '';\n\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = makePrintable('Illegal regexp', rVal, 'in');\n      }\n\n      throwError(errMsg);\n    }\n  }\n\n  RegExpEvaluator.prototype.evaluate = function (lVal) {\n    var type = typeof lVal;\n    return type === 'string' ? this._condVal.test(lVal) : type === 'number' ? this._condVal.test(lVal + '') : false;\n  };\n\n  return RegExpEvaluator;\n}();\n\nvar ConstConditionInternal =\n/** @class */\nfunction () {\n  function ConstConditionInternal() {}\n\n  ConstConditionInternal.prototype.evaluate = function () {\n    return this.value;\n  };\n\n  return ConstConditionInternal;\n}();\n\nvar AndConditionInternal =\n/** @class */\nfunction () {\n  function AndConditionInternal() {}\n\n  AndConditionInternal.prototype.evaluate = function () {\n    var children = this.children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (!children[i].evaluate()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return AndConditionInternal;\n}();\n\nvar OrConditionInternal =\n/** @class */\nfunction () {\n  function OrConditionInternal() {}\n\n  OrConditionInternal.prototype.evaluate = function () {\n    var children = this.children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].evaluate()) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  return OrConditionInternal;\n}();\n\nvar NotConditionInternal =\n/** @class */\nfunction () {\n  function NotConditionInternal() {}\n\n  NotConditionInternal.prototype.evaluate = function () {\n    return !this.child.evaluate();\n  };\n\n  return NotConditionInternal;\n}();\n\nvar RelationalConditionInternal =\n/** @class */\nfunction () {\n  function RelationalConditionInternal() {}\n\n  RelationalConditionInternal.prototype.evaluate = function () {\n    var needParse = !!this.valueParser; // Call getValue with no `this`.\n\n    var getValue = this.getValue;\n    var tarValRaw = getValue(this.valueGetterParam);\n    var tarValParsed = needParse ? this.valueParser(tarValRaw) : null; // Relational cond follow \"and\" logic internally.\n\n    for (var i = 0; i < this.subCondList.length; i++) {\n      if (!this.subCondList[i].evaluate(needParse ? tarValParsed : tarValRaw)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return RelationalConditionInternal;\n}();\n\nfunction parseOption(exprOption, getters) {\n  if (exprOption === true || exprOption === false) {\n    var cond = new ConstConditionInternal();\n    cond.value = exprOption;\n    return cond;\n  }\n\n  var errMsg = '';\n\n  if (!isObjectNotArray(exprOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = makePrintable('Illegal config. Expect a plain object but actually', exprOption);\n    }\n\n    throwError(errMsg);\n  }\n\n  if (exprOption.and) {\n    return parseAndOrOption('and', exprOption, getters);\n  } else if (exprOption.or) {\n    return parseAndOrOption('or', exprOption, getters);\n  } else if (exprOption.not) {\n    return parseNotOption(exprOption, getters);\n  }\n\n  return parseRelationalOption(exprOption, getters);\n}\n\nfunction parseAndOrOption(op, exprOption, getters) {\n  var subOptionArr = exprOption[op];\n  var errMsg = '';\n\n  if (process.env.NODE_ENV !== 'production') {\n    errMsg = makePrintable('\"and\"/\"or\" condition should only be `' + op + ': [...]` and must not be empty array.', 'Illegal condition:', exprOption);\n  }\n\n  if (!isArray(subOptionArr)) {\n    throwError(errMsg);\n  }\n\n  if (!subOptionArr.length) {\n    throwError(errMsg);\n  }\n\n  var cond = op === 'and' ? new AndConditionInternal() : new OrConditionInternal();\n  cond.children = map(subOptionArr, function (subOption) {\n    return parseOption(subOption, getters);\n  });\n\n  if (!cond.children.length) {\n    throwError(errMsg);\n  }\n\n  return cond;\n}\n\nfunction parseNotOption(exprOption, getters) {\n  var subOption = exprOption.not;\n  var errMsg = '';\n\n  if (process.env.NODE_ENV !== 'production') {\n    errMsg = makePrintable('\"not\" condition should only be `not: {}`.', 'Illegal condition:', exprOption);\n  }\n\n  if (!isObjectNotArray(subOption)) {\n    throwError(errMsg);\n  }\n\n  var cond = new NotConditionInternal();\n  cond.child = parseOption(subOption, getters);\n\n  if (!cond.child) {\n    throwError(errMsg);\n  }\n\n  return cond;\n}\n\nfunction parseRelationalOption(exprOption, getters) {\n  var errMsg = '';\n  var valueGetterParam = getters.prepareGetValue(exprOption);\n  var subCondList = [];\n  var exprKeys = keys(exprOption);\n  var parserName = exprOption.parser;\n  var valueParser = parserName ? getRawValueParser(parserName) : null;\n\n  for (var i = 0; i < exprKeys.length; i++) {\n    var keyRaw = exprKeys[i];\n\n    if (keyRaw === 'parser' || getters.valueGetterAttrMap.get(keyRaw)) {\n      continue;\n    }\n\n    var op = hasOwn(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, keyRaw) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[keyRaw] : keyRaw;\n    var condValueRaw = exprOption[keyRaw];\n    var condValueParsed = valueParser ? valueParser(condValueRaw) : condValueRaw;\n    var evaluator = createFilterComparator(op, condValueParsed) || op === 'reg' && new RegExpEvaluator(condValueParsed);\n\n    if (!evaluator) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = makePrintable('Illegal relational operation: \"' + keyRaw + '\" in condition:', exprOption);\n      }\n\n      throwError(errMsg);\n    }\n\n    subCondList.push(evaluator);\n  }\n\n  if (!subCondList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = makePrintable('Relational condition must have at least one operator.', 'Illegal condition:', exprOption);\n    } // No relational operator always disabled in case of dangers result.\n\n\n    throwError(errMsg);\n  }\n\n  var cond = new RelationalConditionInternal();\n  cond.valueGetterParam = valueGetterParam;\n  cond.valueParser = valueParser;\n  cond.getValue = getters.getValue;\n  cond.subCondList = subCondList;\n  return cond;\n}\n\nfunction isObjectNotArray(val) {\n  return isObject(val) && !isArrayLike(val);\n}\n\nvar ConditionalExpressionParsed =\n/** @class */\nfunction () {\n  function ConditionalExpressionParsed(exprOption, getters) {\n    this._cond = parseOption(exprOption, getters);\n  }\n\n  ConditionalExpressionParsed.prototype.evaluate = function () {\n    return this._cond.evaluate();\n  };\n\n  return ConditionalExpressionParsed;\n}();\n\n;\nexport function parseConditionalExpression(exprOption, getters) {\n  return new ConditionalExpressionParsed(exprOption, getters);\n}","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/util/conditionalExpression.js"],"names":["keys","isArray","map","isObject","isString","isRegExp","isArrayLike","hasOwn","throwError","makePrintable","getRawValueParser","createFilterComparator","RELATIONAL_EXPRESSION_OP_ALIAS_MAP","value","RegExpEvaluator","rVal","condValue","_condVal","RegExp","errMsg","process","env","NODE_ENV","prototype","evaluate","lVal","type","test","ConstConditionInternal","AndConditionInternal","children","i","length","OrConditionInternal","NotConditionInternal","child","RelationalConditionInternal","needParse","valueParser","getValue","tarValRaw","valueGetterParam","tarValParsed","subCondList","parseOption","exprOption","getters","cond","isObjectNotArray","and","parseAndOrOption","or","not","parseNotOption","parseRelationalOption","op","subOptionArr","subOption","prepareGetValue","exprKeys","parserName","parser","keyRaw","valueGetterAttrMap","get","condValueRaw","condValueParsed","evaluator","push","val","ConditionalExpressionParsed","_cond","parseConditionalExpression"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { keys, isArray, map, isObject, isString, isRegExp, isArrayLike, hasOwn } from 'zrender/lib/core/util';\nimport { throwError, makePrintable } from './log';\nimport { getRawValueParser, createFilterComparator } from '../data/helper/dataValueHelper';\n;\nvar RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {\n  value: 'eq',\n  // PENDING: not good for literal semantic?\n  '<': 'lt',\n  '<=': 'lte',\n  '>': 'gt',\n  '>=': 'gte',\n  '=': 'eq',\n  '!=': 'ne',\n  '<>': 'ne' // Might mileading for sake of the different between '==' and '===',\n  // So dont support them.\n  // '==': 'eq',\n  // '===': 'seq',\n  // '!==': 'sne'\n  // PENDING: Whether support some common alias \"ge\", \"le\", \"neq\"?\n  // ge: 'gte',\n  // le: 'lte',\n  // neq: 'ne',\n\n}; // type RelationalExpressionOpEvaluate = (tarVal: unknown, condVal: unknown) => boolean;\n\nvar RegExpEvaluator =\n/** @class */\nfunction () {\n  function RegExpEvaluator(rVal) {\n    // Support condVal: RegExp | string\n    var condValue = this._condVal = isString(rVal) ? new RegExp(rVal) : isRegExp(rVal) ? rVal : null;\n\n    if (condValue == null) {\n      var errMsg = '';\n\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = makePrintable('Illegal regexp', rVal, 'in');\n      }\n\n      throwError(errMsg);\n    }\n  }\n\n  RegExpEvaluator.prototype.evaluate = function (lVal) {\n    var type = typeof lVal;\n    return type === 'string' ? this._condVal.test(lVal) : type === 'number' ? this._condVal.test(lVal + '') : false;\n  };\n\n  return RegExpEvaluator;\n}();\n\nvar ConstConditionInternal =\n/** @class */\nfunction () {\n  function ConstConditionInternal() {}\n\n  ConstConditionInternal.prototype.evaluate = function () {\n    return this.value;\n  };\n\n  return ConstConditionInternal;\n}();\n\nvar AndConditionInternal =\n/** @class */\nfunction () {\n  function AndConditionInternal() {}\n\n  AndConditionInternal.prototype.evaluate = function () {\n    var children = this.children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (!children[i].evaluate()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return AndConditionInternal;\n}();\n\nvar OrConditionInternal =\n/** @class */\nfunction () {\n  function OrConditionInternal() {}\n\n  OrConditionInternal.prototype.evaluate = function () {\n    var children = this.children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].evaluate()) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  return OrConditionInternal;\n}();\n\nvar NotConditionInternal =\n/** @class */\nfunction () {\n  function NotConditionInternal() {}\n\n  NotConditionInternal.prototype.evaluate = function () {\n    return !this.child.evaluate();\n  };\n\n  return NotConditionInternal;\n}();\n\nvar RelationalConditionInternal =\n/** @class */\nfunction () {\n  function RelationalConditionInternal() {}\n\n  RelationalConditionInternal.prototype.evaluate = function () {\n    var needParse = !!this.valueParser; // Call getValue with no `this`.\n\n    var getValue = this.getValue;\n    var tarValRaw = getValue(this.valueGetterParam);\n    var tarValParsed = needParse ? this.valueParser(tarValRaw) : null; // Relational cond follow \"and\" logic internally.\n\n    for (var i = 0; i < this.subCondList.length; i++) {\n      if (!this.subCondList[i].evaluate(needParse ? tarValParsed : tarValRaw)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return RelationalConditionInternal;\n}();\n\nfunction parseOption(exprOption, getters) {\n  if (exprOption === true || exprOption === false) {\n    var cond = new ConstConditionInternal();\n    cond.value = exprOption;\n    return cond;\n  }\n\n  var errMsg = '';\n\n  if (!isObjectNotArray(exprOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = makePrintable('Illegal config. Expect a plain object but actually', exprOption);\n    }\n\n    throwError(errMsg);\n  }\n\n  if (exprOption.and) {\n    return parseAndOrOption('and', exprOption, getters);\n  } else if (exprOption.or) {\n    return parseAndOrOption('or', exprOption, getters);\n  } else if (exprOption.not) {\n    return parseNotOption(exprOption, getters);\n  }\n\n  return parseRelationalOption(exprOption, getters);\n}\n\nfunction parseAndOrOption(op, exprOption, getters) {\n  var subOptionArr = exprOption[op];\n  var errMsg = '';\n\n  if (process.env.NODE_ENV !== 'production') {\n    errMsg = makePrintable('\"and\"/\"or\" condition should only be `' + op + ': [...]` and must not be empty array.', 'Illegal condition:', exprOption);\n  }\n\n  if (!isArray(subOptionArr)) {\n    throwError(errMsg);\n  }\n\n  if (!subOptionArr.length) {\n    throwError(errMsg);\n  }\n\n  var cond = op === 'and' ? new AndConditionInternal() : new OrConditionInternal();\n  cond.children = map(subOptionArr, function (subOption) {\n    return parseOption(subOption, getters);\n  });\n\n  if (!cond.children.length) {\n    throwError(errMsg);\n  }\n\n  return cond;\n}\n\nfunction parseNotOption(exprOption, getters) {\n  var subOption = exprOption.not;\n  var errMsg = '';\n\n  if (process.env.NODE_ENV !== 'production') {\n    errMsg = makePrintable('\"not\" condition should only be `not: {}`.', 'Illegal condition:', exprOption);\n  }\n\n  if (!isObjectNotArray(subOption)) {\n    throwError(errMsg);\n  }\n\n  var cond = new NotConditionInternal();\n  cond.child = parseOption(subOption, getters);\n\n  if (!cond.child) {\n    throwError(errMsg);\n  }\n\n  return cond;\n}\n\nfunction parseRelationalOption(exprOption, getters) {\n  var errMsg = '';\n  var valueGetterParam = getters.prepareGetValue(exprOption);\n  var subCondList = [];\n  var exprKeys = keys(exprOption);\n  var parserName = exprOption.parser;\n  var valueParser = parserName ? getRawValueParser(parserName) : null;\n\n  for (var i = 0; i < exprKeys.length; i++) {\n    var keyRaw = exprKeys[i];\n\n    if (keyRaw === 'parser' || getters.valueGetterAttrMap.get(keyRaw)) {\n      continue;\n    }\n\n    var op = hasOwn(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, keyRaw) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[keyRaw] : keyRaw;\n    var condValueRaw = exprOption[keyRaw];\n    var condValueParsed = valueParser ? valueParser(condValueRaw) : condValueRaw;\n    var evaluator = createFilterComparator(op, condValueParsed) || op === 'reg' && new RegExpEvaluator(condValueParsed);\n\n    if (!evaluator) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = makePrintable('Illegal relational operation: \"' + keyRaw + '\" in condition:', exprOption);\n      }\n\n      throwError(errMsg);\n    }\n\n    subCondList.push(evaluator);\n  }\n\n  if (!subCondList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = makePrintable('Relational condition must have at least one operator.', 'Illegal condition:', exprOption);\n    } // No relational operator always disabled in case of dangers result.\n\n\n    throwError(errMsg);\n  }\n\n  var cond = new RelationalConditionInternal();\n  cond.valueGetterParam = valueGetterParam;\n  cond.valueParser = valueParser;\n  cond.getValue = getters.getValue;\n  cond.subCondList = subCondList;\n  return cond;\n}\n\nfunction isObjectNotArray(val) {\n  return isObject(val) && !isArrayLike(val);\n}\n\nvar ConditionalExpressionParsed =\n/** @class */\nfunction () {\n  function ConditionalExpressionParsed(exprOption, getters) {\n    this._cond = parseOption(exprOption, getters);\n  }\n\n  ConditionalExpressionParsed.prototype.evaluate = function () {\n    return this._cond.evaluate();\n  };\n\n  return ConditionalExpressionParsed;\n}();\n\n;\nexport function parseConditionalExpression(exprOption, getters) {\n  return new ConditionalExpressionParsed(exprOption, getters);\n}"]},"metadata":{},"sourceType":"module"}