{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Calculate slider move result.\n * Usage:\n * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n *\n * @param delta Move length.\n * @param handleEnds handleEnds[0] can be bigger then handleEnds[1].\n *              handleEnds will be modified in this method.\n * @param extent handleEnds is restricted by extent.\n *              extent[0] should less or equals than extent[1].\n * @param handleIndex Can be 'all', means that both move the two handleEnds.\n * @param minSpan The range of dataZoom can not be smaller than that.\n *              If not set, handle0 and cross handle1. If set as a non-negative\n *              number (including `0`), handles will push each other when reaching\n *              the minSpan.\n * @param maxSpan The range of dataZoom can not be larger than that.\n * @return The input handleEnds.\n */\nexport default function sliderMove(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n  delta = delta || 0;\n  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.\n\n  if (minSpan != null) {\n    minSpan = restrict(minSpan, [0, extentSpan]);\n  }\n\n  if (maxSpan != null) {\n    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n  }\n\n  if (handleIndex === 'all') {\n    var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n    handleSpan = restrict(handleSpan, [0, extentSpan]);\n    minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);\n    handleIndex = 0;\n  }\n\n  handleEnds[0] = restrict(handleEnds[0], extent);\n  handleEnds[1] = restrict(handleEnds[1], extent);\n  var originalDistSign = getSpanSign(handleEnds, handleIndex);\n  handleEnds[handleIndex] += delta; // Restrict in extent.\n\n  var extentMinSpan = minSpan || 0;\n  var realExtent = extent.slice();\n  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;\n  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.\n\n  var currDistSign;\n  currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {\n    // If minSpan exists, 'cross' is forbidden.\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n  } // Shrink span.\n\n\n  currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (maxSpan != null && currDistSign.span > maxSpan) {\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n  }\n\n  return handleEnds;\n}\n\nfunction getSpanSign(handleEnds, handleIndex) {\n  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n  // is at left of handleEnds[1] for non-cross case.\n\n  return {\n    span: Math.abs(dist),\n    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1\n  };\n}\n\nfunction restrict(value, extend) {\n  return Math.min(extend[1] != null ? extend[1] : Infinity, Math.max(extend[0] != null ? extend[0] : -Infinity, value));\n}","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/component/helper/sliderMove.js"],"names":["sliderMove","delta","handleEnds","extent","handleIndex","minSpan","maxSpan","extentSpan","restrict","Math","max","handleSpan","abs","originalDistSign","getSpanSign","extentMinSpan","realExtent","slice","sign","currDistSign","span","dist","value","extend","min","Infinity"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Calculate slider move result.\n * Usage:\n * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as\n * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.\n * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.\n *\n * @param delta Move length.\n * @param handleEnds handleEnds[0] can be bigger then handleEnds[1].\n *              handleEnds will be modified in this method.\n * @param extent handleEnds is restricted by extent.\n *              extent[0] should less or equals than extent[1].\n * @param handleIndex Can be 'all', means that both move the two handleEnds.\n * @param minSpan The range of dataZoom can not be smaller than that.\n *              If not set, handle0 and cross handle1. If set as a non-negative\n *              number (including `0`), handles will push each other when reaching\n *              the minSpan.\n * @param maxSpan The range of dataZoom can not be larger than that.\n * @return The input handleEnds.\n */\nexport default function sliderMove(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n  delta = delta || 0;\n  var extentSpan = extent[1] - extent[0]; // Notice maxSpan and minSpan can be null/undefined.\n\n  if (minSpan != null) {\n    minSpan = restrict(minSpan, [0, extentSpan]);\n  }\n\n  if (maxSpan != null) {\n    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n  }\n\n  if (handleIndex === 'all') {\n    var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n    handleSpan = restrict(handleSpan, [0, extentSpan]);\n    minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);\n    handleIndex = 0;\n  }\n\n  handleEnds[0] = restrict(handleEnds[0], extent);\n  handleEnds[1] = restrict(handleEnds[1], extent);\n  var originalDistSign = getSpanSign(handleEnds, handleIndex);\n  handleEnds[handleIndex] += delta; // Restrict in extent.\n\n  var extentMinSpan = minSpan || 0;\n  var realExtent = extent.slice();\n  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;\n  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent); // Expand span.\n\n  var currDistSign;\n  currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {\n    // If minSpan exists, 'cross' is forbidden.\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n  } // Shrink span.\n\n\n  currDistSign = getSpanSign(handleEnds, handleIndex);\n\n  if (maxSpan != null && currDistSign.span > maxSpan) {\n    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n  }\n\n  return handleEnds;\n}\n\nfunction getSpanSign(handleEnds, handleIndex) {\n  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex]; // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]\n  // is at left of handleEnds[1] for non-cross case.\n\n  return {\n    span: Math.abs(dist),\n    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1\n  };\n}\n\nfunction restrict(value, extend) {\n  return Math.min(extend[1] != null ? extend[1] : Infinity, Math.max(extend[0] != null ? extend[0] : -Infinity, value));\n}"]},"metadata":{},"sourceType":"module"}