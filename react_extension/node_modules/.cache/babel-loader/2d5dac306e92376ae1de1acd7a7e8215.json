{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport BoundingRect from 'zrender/lib/core/BoundingRect';\nimport * as bbox from 'zrender/lib/core/bbox';\nimport * as vec2 from 'zrender/lib/core/vector';\nimport * as polygonContain from 'zrender/lib/contain/polygon';\nimport * as matrix from 'zrender/lib/core/matrix';\nvar TMP_TRANSFORM = [];\n\nvar Region =\n/** @class */\nfunction () {\n  function Region(name) {\n    this.name = name;\n  }\n  /**\n   * Get center point in data unit. That is,\n   * for GeoJSONRegion, the unit is lat/lng,\n   * for GeoSVGRegion, the unit is SVG local coord.\n   */\n\n\n  Region.prototype.getCenter = function () {\n    return;\n  };\n\n  return Region;\n}();\n\nexport { Region };\n\nvar GeoJSONRegion =\n/** @class */\nfunction (_super) {\n  __extends(GeoJSONRegion, _super);\n\n  function GeoJSONRegion(name, geometries, cp) {\n    var _this = _super.call(this, name) || this;\n\n    _this.type = 'geoJSON';\n    _this.geometries = geometries;\n\n    if (!cp) {\n      var rect = _this.getBoundingRect();\n\n      cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n    } else {\n      cp = [cp[0], cp[1]];\n    }\n\n    _this._center = cp;\n    return _this;\n  }\n\n  GeoJSONRegion.prototype.getBoundingRect = function () {\n    var rect = this._rect;\n\n    if (rect) {\n      return rect;\n    }\n\n    var MAX_NUMBER = Number.MAX_VALUE;\n    var min = [MAX_NUMBER, MAX_NUMBER];\n    var max = [-MAX_NUMBER, -MAX_NUMBER];\n    var min2 = [];\n    var max2 = [];\n    var geometries = this.geometries;\n    var i = 0;\n\n    for (; i < geometries.length; i++) {\n      // Only support polygon\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      } // Doesn't consider hole\n\n\n      var exterior = geometries[i].exterior;\n      bbox.fromPoints(exterior, min2, max2);\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    return this._rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  };\n\n  GeoJSONRegion.prototype.contain = function (coord) {\n    var rect = this.getBoundingRect();\n    var geometries = this.geometries;\n\n    if (!rect.contain(coord[0], coord[1])) {\n      return false;\n    }\n\n    loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {\n      // Only support polygon.\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      }\n\n      var exterior = geometries[i].exterior;\n      var interiors = geometries[i].interiors;\n\n      if (polygonContain.contain(exterior, coord[0], coord[1])) {\n        // Not in the region if point is in the hole.\n        for (var k = 0; k < (interiors ? interiors.length : 0); k++) {\n          if (polygonContain.contain(interiors[k], coord[0], coord[1])) {\n            continue loopGeo;\n          }\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  GeoJSONRegion.prototype.transformTo = function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    var aspect = rect.width / rect.height;\n\n    if (!width) {\n      width = aspect * height;\n    } else if (!height) {\n      height = width / aspect;\n    }\n\n    var target = new BoundingRect(x, y, width, height);\n    var transform = rect.calculateTransform(target);\n    var geometries = this.geometries;\n\n    for (var i = 0; i < geometries.length; i++) {\n      // Only support polygon.\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      }\n\n      var exterior = geometries[i].exterior;\n      var interiors = geometries[i].interiors;\n\n      for (var p = 0; p < exterior.length; p++) {\n        vec2.applyTransform(exterior[p], exterior[p], transform);\n      }\n\n      for (var h = 0; h < (interiors ? interiors.length : 0); h++) {\n        for (var p = 0; p < interiors[h].length; p++) {\n          vec2.applyTransform(interiors[h][p], interiors[h][p], transform);\n        }\n      }\n    }\n\n    rect = this._rect;\n    rect.copy(target); // Update center\n\n    this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  };\n\n  GeoJSONRegion.prototype.cloneShallow = function (name) {\n    name == null && (name = this.name);\n    var newRegion = new GeoJSONRegion(name, this.geometries, this._center);\n    newRegion._rect = this._rect;\n    newRegion.transformTo = null; // Simply avoid to be called.\n\n    return newRegion;\n  };\n\n  GeoJSONRegion.prototype.getCenter = function () {\n    return this._center;\n  };\n\n  GeoJSONRegion.prototype.setCenter = function (center) {\n    this._center = center;\n  };\n\n  return GeoJSONRegion;\n}(Region);\n\nexport { GeoJSONRegion };\n\nvar GeoSVGRegion =\n/** @class */\nfunction (_super) {\n  __extends(GeoSVGRegion, _super);\n\n  function GeoSVGRegion(name, elOnlyForCalculate) {\n    var _this = _super.call(this, name) || this;\n\n    _this.type = 'geoSVG';\n    _this._elOnlyForCalculate = elOnlyForCalculate;\n    return _this;\n  }\n\n  GeoSVGRegion.prototype.getCenter = function () {\n    var center = this._center;\n\n    if (!center) {\n      // In most cases there are no need to calculate this center.\n      // So calculate only when called.\n      center = this._center = this._calculateCenter();\n    }\n\n    return center;\n  };\n\n  GeoSVGRegion.prototype._calculateCenter = function () {\n    var el = this._elOnlyForCalculate;\n    var rect = el.getBoundingRect();\n    var center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n    var mat = matrix.identity(TMP_TRANSFORM);\n    var target = el;\n\n    while (target && !target.isGeoSVGGraphicRoot) {\n      matrix.mul(mat, target.getLocalTransform(), mat);\n      target = target.parent;\n    }\n\n    matrix.invert(mat, mat);\n    vec2.applyTransform(center, center, mat);\n    return center;\n  };\n\n  return GeoSVGRegion;\n}(Region);\n\nexport { GeoSVGRegion };","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/coord/geo/Region.js"],"names":["__extends","BoundingRect","bbox","vec2","polygonContain","matrix","TMP_TRANSFORM","Region","name","prototype","getCenter","GeoJSONRegion","_super","geometries","cp","_this","call","type","rect","getBoundingRect","x","width","y","height","_center","_rect","MAX_NUMBER","Number","MAX_VALUE","min","max","min2","max2","i","length","exterior","fromPoints","contain","coord","loopGeo","len","interiors","k","transformTo","aspect","target","transform","calculateTransform","p","applyTransform","h","copy","cloneShallow","newRegion","setCenter","center","GeoSVGRegion","elOnlyForCalculate","_elOnlyForCalculate","_calculateCenter","el","mat","identity","isGeoSVGGraphicRoot","mul","getLocalTransform","parent","invert"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport BoundingRect from 'zrender/lib/core/BoundingRect';\nimport * as bbox from 'zrender/lib/core/bbox';\nimport * as vec2 from 'zrender/lib/core/vector';\nimport * as polygonContain from 'zrender/lib/contain/polygon';\nimport * as matrix from 'zrender/lib/core/matrix';\nvar TMP_TRANSFORM = [];\n\nvar Region =\n/** @class */\nfunction () {\n  function Region(name) {\n    this.name = name;\n  }\n  /**\n   * Get center point in data unit. That is,\n   * for GeoJSONRegion, the unit is lat/lng,\n   * for GeoSVGRegion, the unit is SVG local coord.\n   */\n\n\n  Region.prototype.getCenter = function () {\n    return;\n  };\n\n  return Region;\n}();\n\nexport { Region };\n\nvar GeoJSONRegion =\n/** @class */\nfunction (_super) {\n  __extends(GeoJSONRegion, _super);\n\n  function GeoJSONRegion(name, geometries, cp) {\n    var _this = _super.call(this, name) || this;\n\n    _this.type = 'geoJSON';\n    _this.geometries = geometries;\n\n    if (!cp) {\n      var rect = _this.getBoundingRect();\n\n      cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n    } else {\n      cp = [cp[0], cp[1]];\n    }\n\n    _this._center = cp;\n    return _this;\n  }\n\n  GeoJSONRegion.prototype.getBoundingRect = function () {\n    var rect = this._rect;\n\n    if (rect) {\n      return rect;\n    }\n\n    var MAX_NUMBER = Number.MAX_VALUE;\n    var min = [MAX_NUMBER, MAX_NUMBER];\n    var max = [-MAX_NUMBER, -MAX_NUMBER];\n    var min2 = [];\n    var max2 = [];\n    var geometries = this.geometries;\n    var i = 0;\n\n    for (; i < geometries.length; i++) {\n      // Only support polygon\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      } // Doesn't consider hole\n\n\n      var exterior = geometries[i].exterior;\n      bbox.fromPoints(exterior, min2, max2);\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    return this._rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  };\n\n  GeoJSONRegion.prototype.contain = function (coord) {\n    var rect = this.getBoundingRect();\n    var geometries = this.geometries;\n\n    if (!rect.contain(coord[0], coord[1])) {\n      return false;\n    }\n\n    loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {\n      // Only support polygon.\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      }\n\n      var exterior = geometries[i].exterior;\n      var interiors = geometries[i].interiors;\n\n      if (polygonContain.contain(exterior, coord[0], coord[1])) {\n        // Not in the region if point is in the hole.\n        for (var k = 0; k < (interiors ? interiors.length : 0); k++) {\n          if (polygonContain.contain(interiors[k], coord[0], coord[1])) {\n            continue loopGeo;\n          }\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  GeoJSONRegion.prototype.transformTo = function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    var aspect = rect.width / rect.height;\n\n    if (!width) {\n      width = aspect * height;\n    } else if (!height) {\n      height = width / aspect;\n    }\n\n    var target = new BoundingRect(x, y, width, height);\n    var transform = rect.calculateTransform(target);\n    var geometries = this.geometries;\n\n    for (var i = 0; i < geometries.length; i++) {\n      // Only support polygon.\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      }\n\n      var exterior = geometries[i].exterior;\n      var interiors = geometries[i].interiors;\n\n      for (var p = 0; p < exterior.length; p++) {\n        vec2.applyTransform(exterior[p], exterior[p], transform);\n      }\n\n      for (var h = 0; h < (interiors ? interiors.length : 0); h++) {\n        for (var p = 0; p < interiors[h].length; p++) {\n          vec2.applyTransform(interiors[h][p], interiors[h][p], transform);\n        }\n      }\n    }\n\n    rect = this._rect;\n    rect.copy(target); // Update center\n\n    this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  };\n\n  GeoJSONRegion.prototype.cloneShallow = function (name) {\n    name == null && (name = this.name);\n    var newRegion = new GeoJSONRegion(name, this.geometries, this._center);\n    newRegion._rect = this._rect;\n    newRegion.transformTo = null; // Simply avoid to be called.\n\n    return newRegion;\n  };\n\n  GeoJSONRegion.prototype.getCenter = function () {\n    return this._center;\n  };\n\n  GeoJSONRegion.prototype.setCenter = function (center) {\n    this._center = center;\n  };\n\n  return GeoJSONRegion;\n}(Region);\n\nexport { GeoJSONRegion };\n\nvar GeoSVGRegion =\n/** @class */\nfunction (_super) {\n  __extends(GeoSVGRegion, _super);\n\n  function GeoSVGRegion(name, elOnlyForCalculate) {\n    var _this = _super.call(this, name) || this;\n\n    _this.type = 'geoSVG';\n    _this._elOnlyForCalculate = elOnlyForCalculate;\n    return _this;\n  }\n\n  GeoSVGRegion.prototype.getCenter = function () {\n    var center = this._center;\n\n    if (!center) {\n      // In most cases there are no need to calculate this center.\n      // So calculate only when called.\n      center = this._center = this._calculateCenter();\n    }\n\n    return center;\n  };\n\n  GeoSVGRegion.prototype._calculateCenter = function () {\n    var el = this._elOnlyForCalculate;\n    var rect = el.getBoundingRect();\n    var center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n    var mat = matrix.identity(TMP_TRANSFORM);\n    var target = el;\n\n    while (target && !target.isGeoSVGGraphicRoot) {\n      matrix.mul(mat, target.getLocalTransform(), mat);\n      target = target.parent;\n    }\n\n    matrix.invert(mat, mat);\n    vec2.applyTransform(center, center, mat);\n    return center;\n  };\n\n  return GeoSVGRegion;\n}(Region);\n\nexport { GeoSVGRegion };"]},"metadata":{},"sourceType":"module"}