{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport { curry, each, map, bind, merge, clone, defaults, assert } from 'zrender/lib/core/util';\nimport Eventful from 'zrender/lib/core/Eventful';\nimport * as graphic from '../../util/graphic';\nimport * as interactionMutex from './interactionMutex';\nimport DataDiffer from '../../data/DataDiffer';\nvar BRUSH_PANEL_GLOBAL = true;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathPow = Math.pow;\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\nvar DIRECTION_MAP = {\n  w: [0, 0],\n  e: [0, 1],\n  n: [1, 0],\n  s: [1, 1]\n};\nvar CURSOR_MAP = {\n  w: 'ew',\n  e: 'ew',\n  n: 'ns',\n  s: 'ns',\n  ne: 'nesw',\n  sw: 'nesw',\n  nw: 'nwse',\n  se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n  brushStyle: {\n    lineWidth: 2,\n    stroke: 'rgba(210,219,238,0.3)',\n    fill: '#D2DBEE'\n  },\n  transformable: true,\n  brushMode: 'single',\n  removeOnClick: false\n};\nvar baseUID = 0;\n/**\n * params:\n *     areas: Array.<Array>, coord relates to container group,\n *                             If no container specified, to global.\n *     opt {\n *         isEnd: boolean,\n *         removeOnClick: boolean\n *     }\n */\n\nvar BrushController =\n/** @class */\nfunction (_super) {\n  __extends(BrushController, _super);\n\n  function BrushController(zr) {\n    var _this = _super.call(this) || this;\n    /**\n     * @internal\n     */\n\n\n    _this._track = [];\n    /**\n     * @internal\n     */\n\n    _this._covers = [];\n    _this._handlers = {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(zr);\n    }\n\n    _this._zr = zr;\n    _this.group = new graphic.Group();\n    _this._uid = 'brushController_' + baseUID++;\n    each(pointerHandlers, function (handler, eventName) {\n      this._handlers[eventName] = bind(handler, this);\n    }, _this);\n    return _this;\n  }\n  /**\n   * If set to `false`, select disabled.\n   */\n\n\n  BrushController.prototype.enableBrush = function (brushOption) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(this._mounted);\n    }\n\n    this._brushType && this._doDisableBrush();\n    brushOption.brushType && this._doEnableBrush(brushOption);\n    return this;\n  };\n\n  BrushController.prototype._doEnableBrush = function (brushOption) {\n    var zr = this._zr; // Consider roam, which takes globalPan too.\n\n    if (!this._enableGlobalPan) {\n      interactionMutex.take(zr, MUTEX_RESOURCE_KEY, this._uid);\n    }\n\n    each(this._handlers, function (handler, eventName) {\n      zr.on(eventName, handler);\n    });\n    this._brushType = brushOption.brushType;\n    this._brushOption = merge(clone(DEFAULT_BRUSH_OPT), brushOption, true);\n  };\n\n  BrushController.prototype._doDisableBrush = function () {\n    var zr = this._zr;\n    interactionMutex.release(zr, MUTEX_RESOURCE_KEY, this._uid);\n    each(this._handlers, function (handler, eventName) {\n      zr.off(eventName, handler);\n    });\n    this._brushType = this._brushOption = null;\n  };\n  /**\n   * @param panelOpts If not pass, it is global brush.\n   */\n\n\n  BrushController.prototype.setPanels = function (panelOpts) {\n    if (panelOpts && panelOpts.length) {\n      var panels_1 = this._panels = {};\n      each(panelOpts, function (panelOpts) {\n        panels_1[panelOpts.panelId] = clone(panelOpts);\n      });\n    } else {\n      this._panels = null;\n    }\n\n    return this;\n  };\n\n  BrushController.prototype.mount = function (opt) {\n    opt = opt || {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      this._mounted = true; // should be at first.\n    }\n\n    this._enableGlobalPan = opt.enableGlobalPan;\n    var thisGroup = this.group;\n\n    this._zr.add(thisGroup);\n\n    thisGroup.attr({\n      x: opt.x || 0,\n      y: opt.y || 0,\n      rotation: opt.rotation || 0,\n      scaleX: opt.scaleX || 1,\n      scaleY: opt.scaleY || 1\n    });\n    this._transform = thisGroup.getLocalTransform();\n    return this;\n  }; // eachCover(cb, context): void {\n  //     each(this._covers, cb, context);\n  // }\n\n  /**\n   * Update covers.\n   * @param coverConfigList\n   *        If coverConfigList is null/undefined, all covers removed.\n   */\n\n\n  BrushController.prototype.updateCovers = function (coverConfigList) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(this._mounted);\n    }\n\n    coverConfigList = map(coverConfigList, function (coverConfig) {\n      return merge(clone(DEFAULT_BRUSH_OPT), coverConfig, true);\n    });\n    var tmpIdPrefix = '\\0-brush-index-';\n    var oldCovers = this._covers;\n    var newCovers = this._covers = [];\n    var controller = this;\n    var creatingCover = this._creatingCover;\n    new DataDiffer(oldCovers, coverConfigList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n    return this;\n\n    function getKey(brushOption, index) {\n      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n    }\n\n    function oldGetKey(cover, index) {\n      return getKey(cover.__brushOption, index);\n    }\n\n    function addOrUpdate(newIndex, oldIndex) {\n      var newBrushInternal = coverConfigList[newIndex]; // Consider setOption in event listener of brushSelect,\n      // where updating cover when creating should be forbiden.\n\n      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n        newCovers[newIndex] = oldCovers[oldIndex];\n      } else {\n        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushInternal, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushInternal));\n        updateCoverAfterCreation(controller, cover);\n      }\n    }\n\n    function remove(oldIndex) {\n      if (oldCovers[oldIndex] !== creatingCover) {\n        controller.group.remove(oldCovers[oldIndex]);\n      }\n    }\n  };\n\n  BrushController.prototype.unmount = function () {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!this._mounted) {\n        return;\n      }\n    }\n\n    this.enableBrush(false); // container may 'removeAll' outside.\n\n    clearCovers(this);\n\n    this._zr.remove(this.group);\n\n    if (process.env.NODE_ENV !== 'production') {\n      this._mounted = false; // should be at last.\n    }\n\n    return this;\n  };\n\n  BrushController.prototype.dispose = function () {\n    this.unmount();\n    this.off();\n  };\n\n  return BrushController;\n}(Eventful);\n\nfunction createCover(controller, brushOption) {\n  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n  cover.__brushOption = brushOption;\n  updateZ(cover, brushOption);\n  controller.group.add(cover);\n  return cover;\n}\n\nfunction endCreating(controller, creatingCover) {\n  var coverRenderer = getCoverRenderer(creatingCover);\n\n  if (coverRenderer.endCreating) {\n    coverRenderer.endCreating(controller, creatingCover);\n    updateZ(creatingCover, creatingCover.__brushOption);\n  }\n\n  return creatingCover;\n}\n\nfunction updateCoverShape(controller, cover) {\n  var brushOption = cover.__brushOption;\n  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n}\n\nfunction updateZ(cover, brushOption) {\n  var z = brushOption.z;\n  z == null && (z = COVER_Z);\n  cover.traverse(function (el) {\n    el.z = z;\n    el.z2 = z; // Consider in given container.\n  });\n}\n\nfunction updateCoverAfterCreation(controller, cover) {\n  getCoverRenderer(cover).updateCommon(controller, cover);\n  updateCoverShape(controller, cover);\n}\n\nfunction getCoverRenderer(cover) {\n  return coverRenderers[cover.__brushOption.brushType];\n} // return target panel or `true` (means global panel)\n\n\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return BRUSH_PANEL_GLOBAL; // Global panel\n  }\n\n  var panel;\n  var transform = controller._transform;\n  each(panels, function (pn) {\n    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n  });\n  return panel;\n} // Return a panel or true\n\n\nfunction getPanelByCover(controller, cover) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return BRUSH_PANEL_GLOBAL; // Global panel\n  }\n\n  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,\n  // which is then treated as global panel.\n\n  return panelId != null ? panels[panelId] : BRUSH_PANEL_GLOBAL;\n}\n\nfunction clearCovers(controller) {\n  var covers = controller._covers;\n  var originalLength = covers.length;\n  each(covers, function (cover) {\n    controller.group.remove(cover);\n  }, controller);\n  covers.length = 0;\n  return !!originalLength;\n}\n\nfunction trigger(controller, opt) {\n  var areas = map(controller._covers, function (cover) {\n    var brushOption = cover.__brushOption;\n    var range = clone(brushOption.range);\n    return {\n      brushType: brushOption.brushType,\n      panelId: brushOption.panelId,\n      range: range\n    };\n  });\n  controller.trigger('brush', {\n    areas: areas,\n    isEnd: !!opt.isEnd,\n    removeOnClick: !!opt.removeOnClick\n  });\n}\n\nfunction shouldShowCover(controller) {\n  var track = controller._track;\n\n  if (!track.length) {\n    return false;\n  }\n\n  var p2 = track[track.length - 1];\n  var p1 = track[0];\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var dist = mathPow(dx * dx + dy * dy, 0.5);\n  return dist > UNSELECT_THRESHOLD;\n}\n\nfunction getTrackEnds(track) {\n  var tail = track.length - 1;\n  tail < 0 && (tail = 0);\n  return [track[0], track[tail]];\n}\n\n;\n\nfunction createBaseRectCover(rectRangeConverter, controller, brushOption, edgeNameSequences) {\n  var cover = new graphic.Group();\n  cover.add(new graphic.Rect({\n    name: 'main',\n    style: makeStyle(brushOption),\n    silent: true,\n    draggable: true,\n    cursor: 'move',\n    drift: curry(driftRect, rectRangeConverter, controller, cover, ['n', 's', 'w', 'e']),\n    ondragend: curry(trigger, controller, {\n      isEnd: true\n    })\n  }));\n  each(edgeNameSequences, function (nameSequence) {\n    cover.add(new graphic.Rect({\n      name: nameSequence.join(''),\n      style: {\n        opacity: 0\n      },\n      draggable: true,\n      silent: true,\n      invisible: true,\n      drift: curry(driftRect, rectRangeConverter, controller, cover, nameSequence),\n      ondragend: curry(trigger, controller, {\n        isEnd: true\n      })\n    }));\n  });\n  return cover;\n}\n\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n  var lineWidth = brushOption.brushStyle.lineWidth || 0;\n  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n  var x = localRange[0][0];\n  var y = localRange[1][0];\n  var xa = x - lineWidth / 2;\n  var ya = y - lineWidth / 2;\n  var x2 = localRange[0][1];\n  var y2 = localRange[1][1];\n  var x2a = x2 - handleSize + lineWidth / 2;\n  var y2a = y2 - handleSize + lineWidth / 2;\n  var width = x2 - x;\n  var height = y2 - y;\n  var widtha = width + lineWidth;\n  var heighta = height + lineWidth;\n  updateRectShape(controller, cover, 'main', x, y, width, height);\n\n  if (brushOption.transformable) {\n    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n  }\n}\n\nfunction updateCommon(controller, cover) {\n  var brushOption = cover.__brushOption;\n  var transformable = brushOption.transformable;\n  var mainEl = cover.childAt(0);\n  mainEl.useStyle(makeStyle(brushOption));\n  mainEl.attr({\n    silent: !transformable,\n    cursor: transformable ? 'move' : 'default'\n  });\n  each([['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']], function (nameSequence) {\n    var el = cover.childOfName(nameSequence.join(''));\n    var globalDir = nameSequence.length === 1 ? getGlobalDirection1(controller, nameSequence[0]) : getGlobalDirection2(controller, nameSequence);\n    el && el.attr({\n      silent: !transformable,\n      invisible: !transformable,\n      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n    });\n  });\n}\n\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n  var el = cover.childOfName(name);\n  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n}\n\nfunction makeStyle(brushOption) {\n  return defaults({\n    strokeNoScale: true\n  }, brushOption.brushStyle);\n}\n\nfunction formatRectRange(x, y, x2, y2) {\n  var min = [mathMin(x, x2), mathMin(y, y2)];\n  var max = [mathMax(x, x2), mathMax(y, y2)];\n  return [[min[0], max[0]], [min[1], max[1]] // y range\n  ];\n}\n\nfunction getTransform(controller) {\n  return graphic.getTransform(controller.group);\n}\n\nfunction getGlobalDirection1(controller, localDirName) {\n  var map = {\n    w: 'left',\n    e: 'right',\n    n: 'top',\n    s: 'bottom'\n  };\n  var inverseMap = {\n    left: 'w',\n    right: 'e',\n    top: 'n',\n    bottom: 's'\n  };\n  var dir = graphic.transformDirection(map[localDirName], getTransform(controller));\n  return inverseMap[dir];\n}\n\nfunction getGlobalDirection2(controller, localDirNameSeq) {\n  var globalDir = [getGlobalDirection1(controller, localDirNameSeq[0]), getGlobalDirection1(controller, localDirNameSeq[1])];\n  (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n  return globalDir.join('');\n}\n\nfunction driftRect(rectRangeConverter, controller, cover, dirNameSequence, dx, dy) {\n  var brushOption = cover.__brushOption;\n  var rectRange = rectRangeConverter.toRectRange(brushOption.range);\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(dirNameSequence, function (dirName) {\n    var ind = DIRECTION_MAP[dirName];\n    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n  });\n  brushOption.range = rectRangeConverter.fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction driftPolygon(controller, cover, dx, dy) {\n  var range = cover.__brushOption.range;\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(range, function (point) {\n    point[0] += localDelta[0];\n    point[1] += localDelta[1];\n  });\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction toLocalDelta(controller, dx, dy) {\n  var thisGroup = controller.group;\n  var localD = thisGroup.transformCoordToLocal(dx, dy);\n  var localZero = thisGroup.transformCoordToLocal(0, 0);\n  return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\n\nfunction clipByPanel(controller, cover, data) {\n  var panel = getPanelByCover(controller, cover);\n  return panel && panel !== BRUSH_PANEL_GLOBAL ? panel.clipPath(data, controller._transform) : clone(data);\n}\n\nfunction pointsToRect(points) {\n  var xmin = mathMin(points[0][0], points[1][0]);\n  var ymin = mathMin(points[0][1], points[1][1]);\n  var xmax = mathMax(points[0][0], points[1][0]);\n  var ymax = mathMax(points[0][1], points[1][1]);\n  return {\n    x: xmin,\n    y: ymin,\n    width: xmax - xmin,\n    height: ymax - ymin\n  };\n}\n\nfunction resetCursor(controller, e, localCursorPoint) {\n  if ( // Check active\n  !controller._brushType // resetCursor should be always called when mouse is in zr area,\n  // but not called when mouse is out of zr area to avoid bad influence\n  // if `mousemove`, `mouseup` are triggered from `document` event.\n  || isOutsideZrArea(controller, e.offsetX, e.offsetY)) {\n    return;\n  }\n\n  var zr = controller._zr;\n  var covers = controller._covers;\n  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.\n\n  if (!controller._dragging) {\n    for (var i = 0; i < covers.length; i++) {\n      var brushOption = covers[i].__brushOption;\n\n      if (currPanel && (currPanel === BRUSH_PANEL_GLOBAL || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n        // Use cursor style set on cover.\n        return;\n      }\n    }\n  }\n\n  currPanel && zr.setCursorStyle('crosshair');\n}\n\nfunction preventDefault(e) {\n  var rawE = e.event;\n  rawE.preventDefault && rawE.preventDefault();\n}\n\nfunction mainShapeContain(cover, x, y) {\n  return cover.childOfName('main').contain(x, y);\n}\n\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n  var creatingCover = controller._creatingCover;\n  var panel = controller._creatingPanel;\n  var thisBrushOption = controller._brushOption;\n  var eventParams;\n\n  controller._track.push(localCursorPoint.slice());\n\n  if (shouldShowCover(controller) || creatingCover) {\n    if (panel && !creatingCover) {\n      thisBrushOption.brushMode === 'single' && clearCovers(controller);\n      var brushOption = clone(thisBrushOption);\n      brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n      brushOption.panelId = panel === BRUSH_PANEL_GLOBAL ? null : panel.panelId;\n      creatingCover = controller._creatingCover = createCover(controller, brushOption);\n\n      controller._covers.push(creatingCover);\n    }\n\n    if (creatingCover) {\n      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n      var coverBrushOption = creatingCover.__brushOption;\n      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n\n      if (isEnd) {\n        endCreating(controller, creatingCover);\n        coverRenderer.updateCommon(controller, creatingCover);\n      }\n\n      updateCoverShape(controller, creatingCover);\n      eventParams = {\n        isEnd: isEnd\n      };\n    }\n  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n    // But a single click do not clear covers, because user may have casual\n    // clicks (for example, click on other component and do not expect covers\n    // disappear).\n    // Only some cover removed, trigger action, but not every click trigger action.\n    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n      eventParams = {\n        isEnd: isEnd,\n        removeOnClick: true\n      };\n    }\n  }\n\n  return eventParams;\n}\n\nfunction determineBrushType(brushType, panel) {\n  if (brushType === 'auto') {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(panel && panel.defaultBrushType, 'MUST have defaultBrushType when brushType is \"atuo\"');\n    }\n\n    return panel.defaultBrushType;\n  }\n\n  return brushType;\n}\n\nvar pointerHandlers = {\n  mousedown: function (e) {\n    if (this._dragging) {\n      // In case some browser do not support globalOut,\n      // and release mouse out side the browser.\n      handleDragEnd(this, e);\n    } else if (!e.target || !e.target.draggable) {\n      preventDefault(e);\n      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n      this._creatingCover = null;\n      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n      if (panel) {\n        this._dragging = true;\n        this._track = [localCursorPoint.slice()];\n      }\n    }\n  },\n  mousemove: function (e) {\n    var x = e.offsetX;\n    var y = e.offsetY;\n    var localCursorPoint = this.group.transformCoordToLocal(x, y);\n    resetCursor(this, e, localCursorPoint);\n\n    if (this._dragging) {\n      preventDefault(e);\n      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n      eventParams && trigger(this, eventParams);\n    }\n  },\n  mouseup: function (e) {\n    handleDragEnd(this, e);\n  }\n};\n\nfunction handleDragEnd(controller, e) {\n  if (controller._dragging) {\n    preventDefault(e);\n    var x = e.offsetX;\n    var y = e.offsetY;\n    var localCursorPoint = controller.group.transformCoordToLocal(x, y);\n    var eventParams = updateCoverByMouse(controller, e, localCursorPoint, true);\n    controller._dragging = false;\n    controller._track = [];\n    controller._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.\n\n    eventParams && trigger(controller, eventParams);\n  }\n}\n\nfunction isOutsideZrArea(controller, x, y) {\n  var zr = controller._zr;\n  return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();\n}\n/**\n * key: brushType\n */\n\n\nvar coverRenderers = {\n  lineX: getLineRenderer(0),\n  lineY: getLineRenderer(1),\n  rect: {\n    createCover: function (controller, brushOption) {\n      function returnInput(range) {\n        return range;\n      }\n\n      return createBaseRectCover({\n        toRectRange: returnInput,\n        fromRectRange: returnInput\n      }, controller, brushOption, [['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      updateBaseRect(controller, cover, localRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  },\n  polygon: {\n    createCover: function (controller, brushOption) {\n      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the\n      // border of the shape when drawing, which is a better experience for user.\n\n      cover.add(new graphic.Polyline({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true\n      }));\n      return cover;\n    },\n    getCreatingRange: function (localTrack) {\n      return localTrack;\n    },\n    endCreating: function (controller, cover) {\n      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.\n\n      cover.add(new graphic.Polygon({\n        name: 'main',\n        draggable: true,\n        drift: curry(driftPolygon, controller, cover),\n        ondragend: curry(trigger, controller, {\n          isEnd: true\n        })\n      }));\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      cover.childAt(0).setShape({\n        points: clipByPanel(controller, cover, localRange)\n      });\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  }\n};\n\nfunction getLineRenderer(xyIndex) {\n  return {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover({\n        toRectRange: function (range) {\n          var rectRange = [range, [0, 100]];\n          xyIndex && rectRange.reverse();\n          return rectRange;\n        },\n        fromRectRange: function (rectRange) {\n          return rectRange[xyIndex];\n        }\n      }, controller, brushOption, [[['w'], ['e']], [['n'], ['s']]][xyIndex]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n      return [min, max];\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      var otherExtent; // If brushWidth not specified, fit the panel.\n\n      var panel = getPanelByCover(controller, cover);\n\n      if (panel !== BRUSH_PANEL_GLOBAL && panel.getLinearBrushOtherExtent) {\n        otherExtent = panel.getLinearBrushOtherExtent(xyIndex);\n      } else {\n        var zr = controller._zr;\n        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n      }\n\n      var rectRange = [localRange, otherExtent];\n      xyIndex && rectRange.reverse();\n      updateBaseRect(controller, cover, rectRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  };\n}\n\nexport default BrushController;","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/component/helper/BrushController.js"],"names":["__extends","curry","each","map","bind","merge","clone","defaults","assert","Eventful","graphic","interactionMutex","DataDiffer","BRUSH_PANEL_GLOBAL","mathMin","Math","min","mathMax","max","mathPow","pow","COVER_Z","UNSELECT_THRESHOLD","MIN_RESIZE_LINE_WIDTH","MUTEX_RESOURCE_KEY","DIRECTION_MAP","w","e","n","s","CURSOR_MAP","ne","sw","nw","se","DEFAULT_BRUSH_OPT","brushStyle","lineWidth","stroke","fill","transformable","brushMode","removeOnClick","baseUID","BrushController","_super","zr","_this","call","_track","_covers","_handlers","process","env","NODE_ENV","_zr","group","Group","_uid","pointerHandlers","handler","eventName","prototype","enableBrush","brushOption","_mounted","_brushType","_doDisableBrush","brushType","_doEnableBrush","_enableGlobalPan","take","on","_brushOption","release","off","setPanels","panelOpts","length","panels_1","_panels","panelId","mount","opt","enableGlobalPan","thisGroup","add","attr","x","y","rotation","scaleX","scaleY","_transform","getLocalTransform","updateCovers","coverConfigList","coverConfig","tmpIdPrefix","oldCovers","newCovers","controller","creatingCover","_creatingCover","oldGetKey","getKey","addOrUpdate","update","remove","execute","index","id","cover","__brushOption","newIndex","oldIndex","newBrushInternal","endCreating","createCover","updateCoverAfterCreation","unmount","clearCovers","dispose","coverRenderers","updateZ","coverRenderer","getCoverRenderer","updateCoverShape","range","z","traverse","el","z2","updateCommon","getPanelByPoint","localCursorPoint","panels","panel","transform","pn","isTargetByCursor","getPanelByCover","covers","originalLength","trigger","areas","isEnd","shouldShowCover","track","p2","p1","dx","dy","dist","getTrackEnds","tail","createBaseRectCover","rectRangeConverter","edgeNameSequences","Rect","name","style","makeStyle","silent","draggable","cursor","drift","driftRect","ondragend","nameSequence","join","opacity","invisible","updateBaseRect","localRange","handleSize","xa","ya","x2","y2","x2a","y2a","width","height","widtha","heighta","updateRectShape","mainEl","childAt","useStyle","childOfName","globalDir","getGlobalDirection1","getGlobalDirection2","h","setShape","pointsToRect","clipByPanel","strokeNoScale","formatRectRange","getTransform","localDirName","inverseMap","left","right","top","bottom","dir","transformDirection","localDirNameSeq","reverse","dirNameSequence","rectRange","toRectRange","localDelta","toLocalDelta","dirName","ind","fromRectRange","driftPolygon","point","localD","transformCoordToLocal","localZero","data","clipPath","points","xmin","ymin","xmax","ymax","resetCursor","isOutsideZrArea","offsetX","offsetY","currPanel","_dragging","i","contain","setCursorStyle","preventDefault","rawE","event","mainShapeContain","updateCoverByMouse","_creatingPanel","thisBrushOption","eventParams","push","slice","determineBrushType","coverBrushOption","getCreatingRange","defaultBrushType","mousedown","handleDragEnd","target","mousemove","mouseup","getWidth","getHeight","lineX","getLineRenderer","lineY","rect","returnInput","localTrack","ends","polygon","Polyline","Polygon","xyIndex","otherExtent","getLinearBrushOtherExtent"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport { curry, each, map, bind, merge, clone, defaults, assert } from 'zrender/lib/core/util';\nimport Eventful from 'zrender/lib/core/Eventful';\nimport * as graphic from '../../util/graphic';\nimport * as interactionMutex from './interactionMutex';\nimport DataDiffer from '../../data/DataDiffer';\nvar BRUSH_PANEL_GLOBAL = true;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathPow = Math.pow;\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\nvar DIRECTION_MAP = {\n  w: [0, 0],\n  e: [0, 1],\n  n: [1, 0],\n  s: [1, 1]\n};\nvar CURSOR_MAP = {\n  w: 'ew',\n  e: 'ew',\n  n: 'ns',\n  s: 'ns',\n  ne: 'nesw',\n  sw: 'nesw',\n  nw: 'nwse',\n  se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n  brushStyle: {\n    lineWidth: 2,\n    stroke: 'rgba(210,219,238,0.3)',\n    fill: '#D2DBEE'\n  },\n  transformable: true,\n  brushMode: 'single',\n  removeOnClick: false\n};\nvar baseUID = 0;\n/**\n * params:\n *     areas: Array.<Array>, coord relates to container group,\n *                             If no container specified, to global.\n *     opt {\n *         isEnd: boolean,\n *         removeOnClick: boolean\n *     }\n */\n\nvar BrushController =\n/** @class */\nfunction (_super) {\n  __extends(BrushController, _super);\n\n  function BrushController(zr) {\n    var _this = _super.call(this) || this;\n    /**\n     * @internal\n     */\n\n\n    _this._track = [];\n    /**\n     * @internal\n     */\n\n    _this._covers = [];\n    _this._handlers = {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(zr);\n    }\n\n    _this._zr = zr;\n    _this.group = new graphic.Group();\n    _this._uid = 'brushController_' + baseUID++;\n    each(pointerHandlers, function (handler, eventName) {\n      this._handlers[eventName] = bind(handler, this);\n    }, _this);\n    return _this;\n  }\n  /**\n   * If set to `false`, select disabled.\n   */\n\n\n  BrushController.prototype.enableBrush = function (brushOption) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(this._mounted);\n    }\n\n    this._brushType && this._doDisableBrush();\n    brushOption.brushType && this._doEnableBrush(brushOption);\n    return this;\n  };\n\n  BrushController.prototype._doEnableBrush = function (brushOption) {\n    var zr = this._zr; // Consider roam, which takes globalPan too.\n\n    if (!this._enableGlobalPan) {\n      interactionMutex.take(zr, MUTEX_RESOURCE_KEY, this._uid);\n    }\n\n    each(this._handlers, function (handler, eventName) {\n      zr.on(eventName, handler);\n    });\n    this._brushType = brushOption.brushType;\n    this._brushOption = merge(clone(DEFAULT_BRUSH_OPT), brushOption, true);\n  };\n\n  BrushController.prototype._doDisableBrush = function () {\n    var zr = this._zr;\n    interactionMutex.release(zr, MUTEX_RESOURCE_KEY, this._uid);\n    each(this._handlers, function (handler, eventName) {\n      zr.off(eventName, handler);\n    });\n    this._brushType = this._brushOption = null;\n  };\n  /**\n   * @param panelOpts If not pass, it is global brush.\n   */\n\n\n  BrushController.prototype.setPanels = function (panelOpts) {\n    if (panelOpts && panelOpts.length) {\n      var panels_1 = this._panels = {};\n      each(panelOpts, function (panelOpts) {\n        panels_1[panelOpts.panelId] = clone(panelOpts);\n      });\n    } else {\n      this._panels = null;\n    }\n\n    return this;\n  };\n\n  BrushController.prototype.mount = function (opt) {\n    opt = opt || {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      this._mounted = true; // should be at first.\n    }\n\n    this._enableGlobalPan = opt.enableGlobalPan;\n    var thisGroup = this.group;\n\n    this._zr.add(thisGroup);\n\n    thisGroup.attr({\n      x: opt.x || 0,\n      y: opt.y || 0,\n      rotation: opt.rotation || 0,\n      scaleX: opt.scaleX || 1,\n      scaleY: opt.scaleY || 1\n    });\n    this._transform = thisGroup.getLocalTransform();\n    return this;\n  }; // eachCover(cb, context): void {\n  //     each(this._covers, cb, context);\n  // }\n\n  /**\n   * Update covers.\n   * @param coverConfigList\n   *        If coverConfigList is null/undefined, all covers removed.\n   */\n\n\n  BrushController.prototype.updateCovers = function (coverConfigList) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(this._mounted);\n    }\n\n    coverConfigList = map(coverConfigList, function (coverConfig) {\n      return merge(clone(DEFAULT_BRUSH_OPT), coverConfig, true);\n    });\n    var tmpIdPrefix = '\\0-brush-index-';\n    var oldCovers = this._covers;\n    var newCovers = this._covers = [];\n    var controller = this;\n    var creatingCover = this._creatingCover;\n    new DataDiffer(oldCovers, coverConfigList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n    return this;\n\n    function getKey(brushOption, index) {\n      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n    }\n\n    function oldGetKey(cover, index) {\n      return getKey(cover.__brushOption, index);\n    }\n\n    function addOrUpdate(newIndex, oldIndex) {\n      var newBrushInternal = coverConfigList[newIndex]; // Consider setOption in event listener of brushSelect,\n      // where updating cover when creating should be forbiden.\n\n      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n        newCovers[newIndex] = oldCovers[oldIndex];\n      } else {\n        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushInternal, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushInternal));\n        updateCoverAfterCreation(controller, cover);\n      }\n    }\n\n    function remove(oldIndex) {\n      if (oldCovers[oldIndex] !== creatingCover) {\n        controller.group.remove(oldCovers[oldIndex]);\n      }\n    }\n  };\n\n  BrushController.prototype.unmount = function () {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!this._mounted) {\n        return;\n      }\n    }\n\n    this.enableBrush(false); // container may 'removeAll' outside.\n\n    clearCovers(this);\n\n    this._zr.remove(this.group);\n\n    if (process.env.NODE_ENV !== 'production') {\n      this._mounted = false; // should be at last.\n    }\n\n    return this;\n  };\n\n  BrushController.prototype.dispose = function () {\n    this.unmount();\n    this.off();\n  };\n\n  return BrushController;\n}(Eventful);\n\nfunction createCover(controller, brushOption) {\n  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n  cover.__brushOption = brushOption;\n  updateZ(cover, brushOption);\n  controller.group.add(cover);\n  return cover;\n}\n\nfunction endCreating(controller, creatingCover) {\n  var coverRenderer = getCoverRenderer(creatingCover);\n\n  if (coverRenderer.endCreating) {\n    coverRenderer.endCreating(controller, creatingCover);\n    updateZ(creatingCover, creatingCover.__brushOption);\n  }\n\n  return creatingCover;\n}\n\nfunction updateCoverShape(controller, cover) {\n  var brushOption = cover.__brushOption;\n  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n}\n\nfunction updateZ(cover, brushOption) {\n  var z = brushOption.z;\n  z == null && (z = COVER_Z);\n  cover.traverse(function (el) {\n    el.z = z;\n    el.z2 = z; // Consider in given container.\n  });\n}\n\nfunction updateCoverAfterCreation(controller, cover) {\n  getCoverRenderer(cover).updateCommon(controller, cover);\n  updateCoverShape(controller, cover);\n}\n\nfunction getCoverRenderer(cover) {\n  return coverRenderers[cover.__brushOption.brushType];\n} // return target panel or `true` (means global panel)\n\n\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return BRUSH_PANEL_GLOBAL; // Global panel\n  }\n\n  var panel;\n  var transform = controller._transform;\n  each(panels, function (pn) {\n    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n  });\n  return panel;\n} // Return a panel or true\n\n\nfunction getPanelByCover(controller, cover) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return BRUSH_PANEL_GLOBAL; // Global panel\n  }\n\n  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,\n  // which is then treated as global panel.\n\n  return panelId != null ? panels[panelId] : BRUSH_PANEL_GLOBAL;\n}\n\nfunction clearCovers(controller) {\n  var covers = controller._covers;\n  var originalLength = covers.length;\n  each(covers, function (cover) {\n    controller.group.remove(cover);\n  }, controller);\n  covers.length = 0;\n  return !!originalLength;\n}\n\nfunction trigger(controller, opt) {\n  var areas = map(controller._covers, function (cover) {\n    var brushOption = cover.__brushOption;\n    var range = clone(brushOption.range);\n    return {\n      brushType: brushOption.brushType,\n      panelId: brushOption.panelId,\n      range: range\n    };\n  });\n  controller.trigger('brush', {\n    areas: areas,\n    isEnd: !!opt.isEnd,\n    removeOnClick: !!opt.removeOnClick\n  });\n}\n\nfunction shouldShowCover(controller) {\n  var track = controller._track;\n\n  if (!track.length) {\n    return false;\n  }\n\n  var p2 = track[track.length - 1];\n  var p1 = track[0];\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var dist = mathPow(dx * dx + dy * dy, 0.5);\n  return dist > UNSELECT_THRESHOLD;\n}\n\nfunction getTrackEnds(track) {\n  var tail = track.length - 1;\n  tail < 0 && (tail = 0);\n  return [track[0], track[tail]];\n}\n\n;\n\nfunction createBaseRectCover(rectRangeConverter, controller, brushOption, edgeNameSequences) {\n  var cover = new graphic.Group();\n  cover.add(new graphic.Rect({\n    name: 'main',\n    style: makeStyle(brushOption),\n    silent: true,\n    draggable: true,\n    cursor: 'move',\n    drift: curry(driftRect, rectRangeConverter, controller, cover, ['n', 's', 'w', 'e']),\n    ondragend: curry(trigger, controller, {\n      isEnd: true\n    })\n  }));\n  each(edgeNameSequences, function (nameSequence) {\n    cover.add(new graphic.Rect({\n      name: nameSequence.join(''),\n      style: {\n        opacity: 0\n      },\n      draggable: true,\n      silent: true,\n      invisible: true,\n      drift: curry(driftRect, rectRangeConverter, controller, cover, nameSequence),\n      ondragend: curry(trigger, controller, {\n        isEnd: true\n      })\n    }));\n  });\n  return cover;\n}\n\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n  var lineWidth = brushOption.brushStyle.lineWidth || 0;\n  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n  var x = localRange[0][0];\n  var y = localRange[1][0];\n  var xa = x - lineWidth / 2;\n  var ya = y - lineWidth / 2;\n  var x2 = localRange[0][1];\n  var y2 = localRange[1][1];\n  var x2a = x2 - handleSize + lineWidth / 2;\n  var y2a = y2 - handleSize + lineWidth / 2;\n  var width = x2 - x;\n  var height = y2 - y;\n  var widtha = width + lineWidth;\n  var heighta = height + lineWidth;\n  updateRectShape(controller, cover, 'main', x, y, width, height);\n\n  if (brushOption.transformable) {\n    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n  }\n}\n\nfunction updateCommon(controller, cover) {\n  var brushOption = cover.__brushOption;\n  var transformable = brushOption.transformable;\n  var mainEl = cover.childAt(0);\n  mainEl.useStyle(makeStyle(brushOption));\n  mainEl.attr({\n    silent: !transformable,\n    cursor: transformable ? 'move' : 'default'\n  });\n  each([['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']], function (nameSequence) {\n    var el = cover.childOfName(nameSequence.join(''));\n    var globalDir = nameSequence.length === 1 ? getGlobalDirection1(controller, nameSequence[0]) : getGlobalDirection2(controller, nameSequence);\n    el && el.attr({\n      silent: !transformable,\n      invisible: !transformable,\n      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n    });\n  });\n}\n\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n  var el = cover.childOfName(name);\n  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n}\n\nfunction makeStyle(brushOption) {\n  return defaults({\n    strokeNoScale: true\n  }, brushOption.brushStyle);\n}\n\nfunction formatRectRange(x, y, x2, y2) {\n  var min = [mathMin(x, x2), mathMin(y, y2)];\n  var max = [mathMax(x, x2), mathMax(y, y2)];\n  return [[min[0], max[0]], [min[1], max[1]] // y range\n  ];\n}\n\nfunction getTransform(controller) {\n  return graphic.getTransform(controller.group);\n}\n\nfunction getGlobalDirection1(controller, localDirName) {\n  var map = {\n    w: 'left',\n    e: 'right',\n    n: 'top',\n    s: 'bottom'\n  };\n  var inverseMap = {\n    left: 'w',\n    right: 'e',\n    top: 'n',\n    bottom: 's'\n  };\n  var dir = graphic.transformDirection(map[localDirName], getTransform(controller));\n  return inverseMap[dir];\n}\n\nfunction getGlobalDirection2(controller, localDirNameSeq) {\n  var globalDir = [getGlobalDirection1(controller, localDirNameSeq[0]), getGlobalDirection1(controller, localDirNameSeq[1])];\n  (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n  return globalDir.join('');\n}\n\nfunction driftRect(rectRangeConverter, controller, cover, dirNameSequence, dx, dy) {\n  var brushOption = cover.__brushOption;\n  var rectRange = rectRangeConverter.toRectRange(brushOption.range);\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(dirNameSequence, function (dirName) {\n    var ind = DIRECTION_MAP[dirName];\n    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n  });\n  brushOption.range = rectRangeConverter.fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction driftPolygon(controller, cover, dx, dy) {\n  var range = cover.__brushOption.range;\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(range, function (point) {\n    point[0] += localDelta[0];\n    point[1] += localDelta[1];\n  });\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction toLocalDelta(controller, dx, dy) {\n  var thisGroup = controller.group;\n  var localD = thisGroup.transformCoordToLocal(dx, dy);\n  var localZero = thisGroup.transformCoordToLocal(0, 0);\n  return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\n\nfunction clipByPanel(controller, cover, data) {\n  var panel = getPanelByCover(controller, cover);\n  return panel && panel !== BRUSH_PANEL_GLOBAL ? panel.clipPath(data, controller._transform) : clone(data);\n}\n\nfunction pointsToRect(points) {\n  var xmin = mathMin(points[0][0], points[1][0]);\n  var ymin = mathMin(points[0][1], points[1][1]);\n  var xmax = mathMax(points[0][0], points[1][0]);\n  var ymax = mathMax(points[0][1], points[1][1]);\n  return {\n    x: xmin,\n    y: ymin,\n    width: xmax - xmin,\n    height: ymax - ymin\n  };\n}\n\nfunction resetCursor(controller, e, localCursorPoint) {\n  if ( // Check active\n  !controller._brushType // resetCursor should be always called when mouse is in zr area,\n  // but not called when mouse is out of zr area to avoid bad influence\n  // if `mousemove`, `mouseup` are triggered from `document` event.\n  || isOutsideZrArea(controller, e.offsetX, e.offsetY)) {\n    return;\n  }\n\n  var zr = controller._zr;\n  var covers = controller._covers;\n  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.\n\n  if (!controller._dragging) {\n    for (var i = 0; i < covers.length; i++) {\n      var brushOption = covers[i].__brushOption;\n\n      if (currPanel && (currPanel === BRUSH_PANEL_GLOBAL || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n        // Use cursor style set on cover.\n        return;\n      }\n    }\n  }\n\n  currPanel && zr.setCursorStyle('crosshair');\n}\n\nfunction preventDefault(e) {\n  var rawE = e.event;\n  rawE.preventDefault && rawE.preventDefault();\n}\n\nfunction mainShapeContain(cover, x, y) {\n  return cover.childOfName('main').contain(x, y);\n}\n\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n  var creatingCover = controller._creatingCover;\n  var panel = controller._creatingPanel;\n  var thisBrushOption = controller._brushOption;\n  var eventParams;\n\n  controller._track.push(localCursorPoint.slice());\n\n  if (shouldShowCover(controller) || creatingCover) {\n    if (panel && !creatingCover) {\n      thisBrushOption.brushMode === 'single' && clearCovers(controller);\n      var brushOption = clone(thisBrushOption);\n      brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n      brushOption.panelId = panel === BRUSH_PANEL_GLOBAL ? null : panel.panelId;\n      creatingCover = controller._creatingCover = createCover(controller, brushOption);\n\n      controller._covers.push(creatingCover);\n    }\n\n    if (creatingCover) {\n      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n      var coverBrushOption = creatingCover.__brushOption;\n      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n\n      if (isEnd) {\n        endCreating(controller, creatingCover);\n        coverRenderer.updateCommon(controller, creatingCover);\n      }\n\n      updateCoverShape(controller, creatingCover);\n      eventParams = {\n        isEnd: isEnd\n      };\n    }\n  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n    // But a single click do not clear covers, because user may have casual\n    // clicks (for example, click on other component and do not expect covers\n    // disappear).\n    // Only some cover removed, trigger action, but not every click trigger action.\n    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n      eventParams = {\n        isEnd: isEnd,\n        removeOnClick: true\n      };\n    }\n  }\n\n  return eventParams;\n}\n\nfunction determineBrushType(brushType, panel) {\n  if (brushType === 'auto') {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(panel && panel.defaultBrushType, 'MUST have defaultBrushType when brushType is \"atuo\"');\n    }\n\n    return panel.defaultBrushType;\n  }\n\n  return brushType;\n}\n\nvar pointerHandlers = {\n  mousedown: function (e) {\n    if (this._dragging) {\n      // In case some browser do not support globalOut,\n      // and release mouse out side the browser.\n      handleDragEnd(this, e);\n    } else if (!e.target || !e.target.draggable) {\n      preventDefault(e);\n      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n      this._creatingCover = null;\n      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n      if (panel) {\n        this._dragging = true;\n        this._track = [localCursorPoint.slice()];\n      }\n    }\n  },\n  mousemove: function (e) {\n    var x = e.offsetX;\n    var y = e.offsetY;\n    var localCursorPoint = this.group.transformCoordToLocal(x, y);\n    resetCursor(this, e, localCursorPoint);\n\n    if (this._dragging) {\n      preventDefault(e);\n      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n      eventParams && trigger(this, eventParams);\n    }\n  },\n  mouseup: function (e) {\n    handleDragEnd(this, e);\n  }\n};\n\nfunction handleDragEnd(controller, e) {\n  if (controller._dragging) {\n    preventDefault(e);\n    var x = e.offsetX;\n    var y = e.offsetY;\n    var localCursorPoint = controller.group.transformCoordToLocal(x, y);\n    var eventParams = updateCoverByMouse(controller, e, localCursorPoint, true);\n    controller._dragging = false;\n    controller._track = [];\n    controller._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.\n\n    eventParams && trigger(controller, eventParams);\n  }\n}\n\nfunction isOutsideZrArea(controller, x, y) {\n  var zr = controller._zr;\n  return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();\n}\n/**\n * key: brushType\n */\n\n\nvar coverRenderers = {\n  lineX: getLineRenderer(0),\n  lineY: getLineRenderer(1),\n  rect: {\n    createCover: function (controller, brushOption) {\n      function returnInput(range) {\n        return range;\n      }\n\n      return createBaseRectCover({\n        toRectRange: returnInput,\n        fromRectRange: returnInput\n      }, controller, brushOption, [['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      updateBaseRect(controller, cover, localRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  },\n  polygon: {\n    createCover: function (controller, brushOption) {\n      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the\n      // border of the shape when drawing, which is a better experience for user.\n\n      cover.add(new graphic.Polyline({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true\n      }));\n      return cover;\n    },\n    getCreatingRange: function (localTrack) {\n      return localTrack;\n    },\n    endCreating: function (controller, cover) {\n      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.\n\n      cover.add(new graphic.Polygon({\n        name: 'main',\n        draggable: true,\n        drift: curry(driftPolygon, controller, cover),\n        ondragend: curry(trigger, controller, {\n          isEnd: true\n        })\n      }));\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      cover.childAt(0).setShape({\n        points: clipByPanel(controller, cover, localRange)\n      });\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  }\n};\n\nfunction getLineRenderer(xyIndex) {\n  return {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover({\n        toRectRange: function (range) {\n          var rectRange = [range, [0, 100]];\n          xyIndex && rectRange.reverse();\n          return rectRange;\n        },\n        fromRectRange: function (rectRange) {\n          return rectRange[xyIndex];\n        }\n      }, controller, brushOption, [[['w'], ['e']], [['n'], ['s']]][xyIndex]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n      return [min, max];\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      var otherExtent; // If brushWidth not specified, fit the panel.\n\n      var panel = getPanelByCover(controller, cover);\n\n      if (panel !== BRUSH_PANEL_GLOBAL && panel.getLinearBrushOtherExtent) {\n        otherExtent = panel.getLinearBrushOtherExtent(xyIndex);\n      } else {\n        var zr = controller._zr;\n        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n      }\n\n      var rectRange = [localRange, otherExtent];\n      xyIndex && rectRange.reverse();\n      updateBaseRect(controller, cover, rectRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  };\n}\n\nexport default BrushController;"]},"metadata":{},"sourceType":"module"}