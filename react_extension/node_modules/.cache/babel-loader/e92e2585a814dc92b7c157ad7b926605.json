{"ast":null,"code":"import Point from './Point';\nvar extent = [0, 0];\nvar extent2 = [0, 0];\nvar minTv = new Point();\nvar maxTv = new Point();\n\nvar OrientedBoundingRect = function () {\n  function OrientedBoundingRect(rect, transform) {\n    this._corners = [];\n    this._axes = [];\n    this._origin = [0, 0];\n\n    for (var i = 0; i < 4; i++) {\n      this._corners[i] = new Point();\n    }\n\n    for (var i = 0; i < 2; i++) {\n      this._axes[i] = new Point();\n    }\n\n    if (rect) {\n      this.fromBoundingRect(rect, transform);\n    }\n  }\n\n  OrientedBoundingRect.prototype.fromBoundingRect = function (rect, transform) {\n    var corners = this._corners;\n    var axes = this._axes;\n    var x = rect.x;\n    var y = rect.y;\n    var x2 = x + rect.width;\n    var y2 = y + rect.height;\n    corners[0].set(x, y);\n    corners[1].set(x2, y);\n    corners[2].set(x2, y2);\n    corners[3].set(x, y2);\n\n    if (transform) {\n      for (var i = 0; i < 4; i++) {\n        corners[i].transform(transform);\n      }\n    }\n\n    Point.sub(axes[0], corners[1], corners[0]);\n    Point.sub(axes[1], corners[3], corners[0]);\n    axes[0].normalize();\n    axes[1].normalize();\n\n    for (var i = 0; i < 2; i++) {\n      this._origin[i] = axes[i].dot(corners[0]);\n    }\n  };\n\n  OrientedBoundingRect.prototype.intersect = function (other, mtv) {\n    var overlapped = true;\n    var noMtv = !mtv;\n    minTv.set(Infinity, Infinity);\n    maxTv.set(0, 0);\n\n    if (!this._intersectCheckOneSide(this, other, minTv, maxTv, noMtv, 1)) {\n      overlapped = false;\n\n      if (noMtv) {\n        return overlapped;\n      }\n    }\n\n    if (!this._intersectCheckOneSide(other, this, minTv, maxTv, noMtv, -1)) {\n      overlapped = false;\n\n      if (noMtv) {\n        return overlapped;\n      }\n    }\n\n    if (!noMtv) {\n      Point.copy(mtv, overlapped ? minTv : maxTv);\n    }\n\n    return overlapped;\n  };\n\n  OrientedBoundingRect.prototype._intersectCheckOneSide = function (self, other, minTv, maxTv, noMtv, inverse) {\n    var overlapped = true;\n\n    for (var i = 0; i < 2; i++) {\n      var axis = this._axes[i];\n\n      this._getProjMinMaxOnAxis(i, self._corners, extent);\n\n      this._getProjMinMaxOnAxis(i, other._corners, extent2);\n\n      if (extent[1] < extent2[0] || extent[0] > extent2[1]) {\n        overlapped = false;\n\n        if (noMtv) {\n          return overlapped;\n        }\n\n        var dist0 = Math.abs(extent2[0] - extent[1]);\n        var dist1 = Math.abs(extent[0] - extent2[1]);\n\n        if (Math.min(dist0, dist1) > maxTv.len()) {\n          if (dist0 < dist1) {\n            Point.scale(maxTv, axis, -dist0 * inverse);\n          } else {\n            Point.scale(maxTv, axis, dist1 * inverse);\n          }\n        }\n      } else if (minTv) {\n        var dist0 = Math.abs(extent2[0] - extent[1]);\n        var dist1 = Math.abs(extent[0] - extent2[1]);\n\n        if (Math.min(dist0, dist1) < minTv.len()) {\n          if (dist0 < dist1) {\n            Point.scale(minTv, axis, dist0 * inverse);\n          } else {\n            Point.scale(minTv, axis, -dist1 * inverse);\n          }\n        }\n      }\n    }\n\n    return overlapped;\n  };\n\n  OrientedBoundingRect.prototype._getProjMinMaxOnAxis = function (dim, corners, out) {\n    var axis = this._axes[dim];\n    var origin = this._origin;\n    var proj = corners[0].dot(axis) + origin[dim];\n    var min = proj;\n    var max = proj;\n\n    for (var i = 1; i < corners.length; i++) {\n      var proj_1 = corners[i].dot(axis) + origin[dim];\n      min = Math.min(proj_1, min);\n      max = Math.max(proj_1, max);\n    }\n\n    out[0] = min;\n    out[1] = max;\n  };\n\n  return OrientedBoundingRect;\n}();\n\nexport default OrientedBoundingRect;","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/zrender/lib/core/OrientedBoundingRect.js"],"names":["Point","extent","extent2","minTv","maxTv","OrientedBoundingRect","rect","transform","_corners","_axes","_origin","i","fromBoundingRect","prototype","corners","axes","x","y","x2","width","y2","height","set","sub","normalize","dot","intersect","other","mtv","overlapped","noMtv","Infinity","_intersectCheckOneSide","copy","self","inverse","axis","_getProjMinMaxOnAxis","dist0","Math","abs","dist1","min","len","scale","dim","out","origin","proj","max","length","proj_1"],"mappings":"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","sourcesContent":["import Point from './Point';\nvar extent = [0, 0];\nvar extent2 = [0, 0];\nvar minTv = new Point();\nvar maxTv = new Point();\nvar OrientedBoundingRect = (function () {\n    function OrientedBoundingRect(rect, transform) {\n        this._corners = [];\n        this._axes = [];\n        this._origin = [0, 0];\n        for (var i = 0; i < 4; i++) {\n            this._corners[i] = new Point();\n        }\n        for (var i = 0; i < 2; i++) {\n            this._axes[i] = new Point();\n        }\n        if (rect) {\n            this.fromBoundingRect(rect, transform);\n        }\n    }\n    OrientedBoundingRect.prototype.fromBoundingRect = function (rect, transform) {\n        var corners = this._corners;\n        var axes = this._axes;\n        var x = rect.x;\n        var y = rect.y;\n        var x2 = x + rect.width;\n        var y2 = y + rect.height;\n        corners[0].set(x, y);\n        corners[1].set(x2, y);\n        corners[2].set(x2, y2);\n        corners[3].set(x, y2);\n        if (transform) {\n            for (var i = 0; i < 4; i++) {\n                corners[i].transform(transform);\n            }\n        }\n        Point.sub(axes[0], corners[1], corners[0]);\n        Point.sub(axes[1], corners[3], corners[0]);\n        axes[0].normalize();\n        axes[1].normalize();\n        for (var i = 0; i < 2; i++) {\n            this._origin[i] = axes[i].dot(corners[0]);\n        }\n    };\n    OrientedBoundingRect.prototype.intersect = function (other, mtv) {\n        var overlapped = true;\n        var noMtv = !mtv;\n        minTv.set(Infinity, Infinity);\n        maxTv.set(0, 0);\n        if (!this._intersectCheckOneSide(this, other, minTv, maxTv, noMtv, 1)) {\n            overlapped = false;\n            if (noMtv) {\n                return overlapped;\n            }\n        }\n        if (!this._intersectCheckOneSide(other, this, minTv, maxTv, noMtv, -1)) {\n            overlapped = false;\n            if (noMtv) {\n                return overlapped;\n            }\n        }\n        if (!noMtv) {\n            Point.copy(mtv, overlapped ? minTv : maxTv);\n        }\n        return overlapped;\n    };\n    OrientedBoundingRect.prototype._intersectCheckOneSide = function (self, other, minTv, maxTv, noMtv, inverse) {\n        var overlapped = true;\n        for (var i = 0; i < 2; i++) {\n            var axis = this._axes[i];\n            this._getProjMinMaxOnAxis(i, self._corners, extent);\n            this._getProjMinMaxOnAxis(i, other._corners, extent2);\n            if (extent[1] < extent2[0] || extent[0] > extent2[1]) {\n                overlapped = false;\n                if (noMtv) {\n                    return overlapped;\n                }\n                var dist0 = Math.abs(extent2[0] - extent[1]);\n                var dist1 = Math.abs(extent[0] - extent2[1]);\n                if (Math.min(dist0, dist1) > maxTv.len()) {\n                    if (dist0 < dist1) {\n                        Point.scale(maxTv, axis, -dist0 * inverse);\n                    }\n                    else {\n                        Point.scale(maxTv, axis, dist1 * inverse);\n                    }\n                }\n            }\n            else if (minTv) {\n                var dist0 = Math.abs(extent2[0] - extent[1]);\n                var dist1 = Math.abs(extent[0] - extent2[1]);\n                if (Math.min(dist0, dist1) < minTv.len()) {\n                    if (dist0 < dist1) {\n                        Point.scale(minTv, axis, dist0 * inverse);\n                    }\n                    else {\n                        Point.scale(minTv, axis, -dist1 * inverse);\n                    }\n                }\n            }\n        }\n        return overlapped;\n    };\n    OrientedBoundingRect.prototype._getProjMinMaxOnAxis = function (dim, corners, out) {\n        var axis = this._axes[dim];\n        var origin = this._origin;\n        var proj = corners[0].dot(axis) + origin[dim];\n        var min = proj;\n        var max = proj;\n        for (var i = 1; i < corners.length; i++) {\n            var proj_1 = corners[i].dot(axis) + origin[dim];\n            min = Math.min(proj_1, min);\n            max = Math.max(proj_1, max);\n        }\n        out[0] = min;\n        out[1] = max;\n    };\n    return OrientedBoundingRect;\n}());\nexport default OrientedBoundingRect;\n"]},"metadata":{},"sourceType":"module"}