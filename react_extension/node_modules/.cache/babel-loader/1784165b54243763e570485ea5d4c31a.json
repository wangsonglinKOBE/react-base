{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { SERIES_LAYOUT_BY_COLUMN, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_ARRAY_ROWS } from '../../util/types';\nimport { normalizeToArray } from '../../util/model';\nimport { createHashMap, bind, each, hasOwn, map, clone, isObject, extend } from 'zrender/lib/core/util';\nimport { getRawSourceItemGetter, getRawSourceDataCounter, getRawSourceValueGetter } from './dataProvider';\nimport { parseDataValue } from './dataValueHelper';\nimport { consoleLog, makePrintable, throwError } from '../../util/log';\nimport { createSource, detectSourceFormat } from '../Source';\n/**\n * TODO: disable writable.\n * This structure will be exposed to users.\n */\n\nvar ExternalSource =\n/** @class */\nfunction () {\n  function ExternalSource() {}\n\n  ExternalSource.prototype.getRawData = function () {\n    // Only built-in transform available.\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.getRawDataItem = function (dataIndex) {\n    // Only built-in transform available.\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.cloneRawData = function () {\n    return;\n  };\n  /**\n   * @return If dimension not found, return null/undefined.\n   */\n\n\n  ExternalSource.prototype.getDimensionInfo = function (dim) {\n    return;\n  };\n  /**\n   * dimensions defined if and only if either:\n   * (a) dataset.dimensions are declared.\n   * (b) dataset data include dimensions definitions in data (detected or via specified `sourceHeader`).\n   * If dimensions are defined, `dimensionInfoAll` is corresponding to\n   * the defined dimensions.\n   * Otherwise, `dimensionInfoAll` is determined by data columns.\n   * @return Always return an array (even empty array).\n   */\n\n\n  ExternalSource.prototype.cloneAllDimensionInfo = function () {\n    return;\n  };\n\n  ExternalSource.prototype.count = function () {\n    return;\n  };\n  /**\n   * Only support by dimension index.\n   * No need to support by dimension name in transform function,\n   * becuase transform function is not case-specific, no need to use name literally.\n   */\n\n\n  ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {\n    return parseDataValue(rawVal, dimInfo);\n  };\n\n  return ExternalSource;\n}();\n\nexport { ExternalSource };\n\nfunction createExternalSource(internalSource, externalTransform) {\n  var extSource = new ExternalSource();\n  var data = internalSource.data;\n  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;\n  var sourceHeaderCount = internalSource.startIndex;\n  var errMsg = '';\n\n  if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {\n    // For the logic simplicity in transformer, only 'culumn' is\n    // supported in data transform. Otherwise, the `dimensionsDefine`\n    // might be detected by 'row', which probably confuses users.\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`seriesLayoutBy` of upstream dataset can only be \"column\" in data transform.';\n    }\n\n    throwError(errMsg);\n  } // [MEMO]\n  // Create a new dimensions structure for exposing.\n  // Do not expose all dimension info to users directly.\n  // Becuase the dimension is probably auto detected from data and not might reliable.\n  // Should not lead the transformers to think that is relialbe and return it.\n  // See [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.\n\n\n  var dimensions = [];\n  var dimsByName = {};\n  var dimsDef = internalSource.dimensionsDefine;\n\n  if (dimsDef) {\n    each(dimsDef, function (dimDef, idx) {\n      var name = dimDef.name;\n      var dimDefExt = {\n        index: idx,\n        name: name,\n        displayName: dimDef.displayName\n      };\n      dimensions.push(dimDefExt); // Users probably not sepcify dimension name. For simplicity, data transform\n      // do not generate dimension name.\n\n      if (name != null) {\n        // Dimension name should not be duplicated.\n        // For simplicity, data transform forbid name duplication, do not generate\n        // new name like module `completeDimensions.ts` did, but just tell users.\n        var errMsg_1 = '';\n\n        if (hasOwn(dimsByName, name)) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg_1 = 'dimension name \"' + name + '\" duplicated.';\n          }\n\n          throwError(errMsg_1);\n        }\n\n        dimsByName[name] = dimDefExt;\n      }\n    });\n  } // If dimension definitions are not defined and can not be detected.\n  // e.g., pure data `[[11, 22], ...]`.\n  else {\n    for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {\n      // Do not generete name or anything others. The consequence process in\n      // `transform` or `series` probably have there own name generation strategry.\n      dimensions.push({\n        index: i\n      });\n    }\n  } // Implement public methods:\n\n\n  var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n\n  if (externalTransform.__isBuiltIn) {\n    extSource.getRawDataItem = function (dataIndex) {\n      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    };\n\n    extSource.getRawData = bind(getRawData, null, internalSource);\n  }\n\n  extSource.cloneRawData = bind(cloneRawData, null, internalSource);\n  var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n  extSource.count = bind(rawCounter, null, data, sourceHeaderCount, dimensions);\n  var rawValueGetter = getRawSourceValueGetter(sourceFormat);\n\n  extSource.retrieveValue = function (dataIndex, dimIndex) {\n    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    return retrieveValueFromItem(rawItem, dimIndex);\n  };\n\n  var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {\n    if (dataItem == null) {\n      return;\n    }\n\n    var dimDef = dimensions[dimIndex]; // When `dimIndex` is `null`, `rawValueGetter` return the whole item.\n\n    if (dimDef) {\n      return rawValueGetter(dataItem, dimIndex, dimDef.name);\n    }\n  };\n\n  extSource.getDimensionInfo = bind(getDimensionInfo, null, dimensions, dimsByName);\n  extSource.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, dimensions);\n  return extSource;\n}\n\nfunction getRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n\n  if (!isSupportedSourceFormat(sourceFormat)) {\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`getRawData` is not supported in source format ' + sourceFormat;\n    }\n\n    throwError(errMsg);\n  }\n\n  return upstream.data;\n}\n\nfunction cloneRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n\n  if (!isSupportedSourceFormat(sourceFormat)) {\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`cloneRawData` is not supported in source format ' + sourceFormat;\n    }\n\n    throwError(errMsg);\n  }\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      // Not strictly clone for performance\n      result.push(data[i].slice());\n    }\n\n    return result;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      // Not strictly clone for performance\n      result.push(extend({}, data[i]));\n    }\n\n    return result;\n  }\n}\n\nfunction getDimensionInfo(dimensions, dimsByName, dim) {\n  if (dim == null) {\n    return;\n  } // Keep the same logic as `List::getDimension` did.\n\n\n  if (typeof dim === 'number' // If being a number-like string but not being defined a dimension name.\n  || !isNaN(dim) && !hasOwn(dimsByName, dim)) {\n    return dimensions[dim];\n  } else if (hasOwn(dimsByName, dim)) {\n    return dimsByName[dim];\n  }\n}\n\nfunction cloneAllDimensionInfo(dimensions) {\n  return clone(dimensions);\n}\n\nvar externalTransformMap = createHashMap();\nexport function registerExternalTransform(externalTransform) {\n  externalTransform = clone(externalTransform);\n  var type = externalTransform.type;\n  var errMsg = '';\n\n  if (!type) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have a `type` when `registerTransform`.';\n    }\n\n    throwError(errMsg);\n  }\n\n  var typeParsed = type.split(':');\n\n  if (typeParsed.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Name must include namespace like \"ns:regression\".';\n    }\n\n    throwError(errMsg);\n  } // Namespace 'echarts:xxx' is official namespace, where the transforms should\n  // be called directly via 'xxx' rather than 'echarts:xxx'.\n\n\n  var isBuiltIn = false;\n\n  if (typeParsed[0] === 'echarts') {\n    type = typeParsed[1];\n    isBuiltIn = true;\n  }\n\n  externalTransform.__isBuiltIn = isBuiltIn;\n  externalTransformMap.set(type, externalTransform);\n}\nexport function applyDataTransform(rawTransOption, sourceList, infoForPrint) {\n  var pipedTransOption = normalizeToArray(rawTransOption);\n  var pipeLen = pipedTransOption.length;\n  var errMsg = '';\n\n  if (!pipeLen) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'If `transform` declared, it should at least contain one transform.';\n    }\n\n    throwError(errMsg);\n  }\n\n  for (var i = 0, len = pipeLen; i < len; i++) {\n    var transOption = pipedTransOption[i];\n    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i); // piped transform only support single input, except the fist one.\n    // piped transform only support single output, except the last one.\n\n    if (i !== len - 1) {\n      sourceList.length = Math.max(sourceList.length, 1);\n    }\n  }\n\n  return sourceList;\n}\n\nfunction applySingleDataTransform(transOption, upSourceList, infoForPrint, // If `pipeIndex` is null/undefined, no piped transform.\npipeIndex) {\n  var errMsg = '';\n\n  if (!upSourceList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have at least one upstream dataset.';\n    }\n\n    throwError(errMsg);\n  }\n\n  if (!isObject(transOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.';\n    }\n\n    throwError(errMsg);\n  }\n\n  var transType = transOption.type;\n  var externalTransform = externalTransformMap.get(transType);\n\n  if (!externalTransform) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Can not find transform on type \"' + transType + '\".';\n    }\n\n    throwError(errMsg);\n  } // Prepare source\n\n\n  var extUpSourceList = map(upSourceList, function (upSource) {\n    return createExternalSource(upSource, externalTransform);\n  });\n  var resultList = normalizeToArray(externalTransform.transform({\n    upstream: extUpSourceList[0],\n    upstreamList: extUpSourceList,\n    config: clone(transOption.config)\n  }));\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (transOption.print) {\n      var printStrArr = map(resultList, function (extSource) {\n        var pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : '';\n        return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', makePrintable(extSource.data), '- transform result dimensions:', makePrintable(extSource.dimensions)].join('\\n');\n      }).join('\\n');\n      consoleLog(printStrArr);\n    }\n  }\n\n  return map(resultList, function (result, resultIndex) {\n    var errMsg = '';\n\n    if (!isObject(result)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'A transform should not return some empty results.';\n      }\n\n      throwError(errMsg);\n    }\n\n    if (!result.data) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'Transform result data should be not be null or undefined';\n      }\n\n      throwError(errMsg);\n    }\n\n    var sourceFormat = detectSourceFormat(result.data);\n\n    if (!isSupportedSourceFormat(sourceFormat)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'Transform result data should be array rows or object rows.';\n      }\n\n      throwError(errMsg);\n    }\n\n    var resultMetaRawOption;\n    var firstUpSource = upSourceList[0];\n    /**\n     * Intuitively, the end users known the content of the original `dataset.source`,\n     * calucating the transform result in mind.\n     * Suppose the original `dataset.source` is:\n     * ```js\n     * [\n     *     ['product', '2012', '2013', '2014', '2015'],\n     *     ['AAA', 41.1, 30.4, 65.1, 53.3],\n     *     ['BBB', 86.5, 92.1, 85.7, 83.1],\n     *     ['CCC', 24.1, 67.2, 79.5, 86.4]\n     * ]\n     * ```\n     * The dimension info have to be detected from the source data.\n     * Some of the transformers (like filter, sort) will follow the dimension info\n     * of upstream, while others use new dimensions (like aggregate).\n     * Transformer can output a field `dimensions` to define the its own output dimensions.\n     * We also allow transformers to ignore the output `dimensions` field, and\n     * inherit the upstream dimensions definition. It can reduce the burden of handling\n     * dimensions in transformers.\n     *\n     * See also [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.\n     */\n\n    if (firstUpSource && resultIndex === 0 // If transformer returns `dimensions`, it means that the transformer has different\n    // dimensions definitions. We do not inherit anything from upstream.\n    && !result.dimensions) {\n      var startIndex = firstUpSource.startIndex; // We copy the header of upstream to the result becuase:\n      // (1) The returned data always does not contain header line and can not be used\n      // as dimension-detection. In this case we can not use \"detected dimensions\" of\n      // upstream directly, because it might be detected based on different `seriesLayoutBy`.\n      // (2) We should support that the series read the upstream source in `seriesLayoutBy: 'row'`.\n      // So the original detected header should be add to the result, otherwise they can not be read.\n\n      if (startIndex) {\n        result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);\n      }\n\n      resultMetaRawOption = {\n        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,\n        sourceHeader: startIndex,\n        dimensions: firstUpSource.metaRawOption.dimensions\n      };\n    } else {\n      resultMetaRawOption = {\n        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,\n        sourceHeader: 0,\n        dimensions: result.dimensions\n      };\n    }\n\n    return createSource(result.data, resultMetaRawOption, null);\n  });\n}\n\nfunction isSupportedSourceFormat(sourceFormat) {\n  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;\n}","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/data/helper/transform.js"],"names":["SERIES_LAYOUT_BY_COLUMN","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_ARRAY_ROWS","normalizeToArray","createHashMap","bind","each","hasOwn","map","clone","isObject","extend","getRawSourceItemGetter","getRawSourceDataCounter","getRawSourceValueGetter","parseDataValue","consoleLog","makePrintable","throwError","createSource","detectSourceFormat","ExternalSource","prototype","getRawData","Error","getRawDataItem","dataIndex","cloneRawData","getDimensionInfo","dim","cloneAllDimensionInfo","count","retrieveValue","dimIndex","retrieveValueFromItem","dataItem","convertValue","rawVal","dimInfo","createExternalSource","internalSource","externalTransform","extSource","data","sourceFormat","sourceHeaderCount","startIndex","errMsg","seriesLayoutBy","process","env","NODE_ENV","dimensions","dimsByName","dimsDef","dimensionsDefine","dimDef","idx","name","dimDefExt","index","displayName","push","errMsg_1","i","dimensionsDetectedCount","rawItemGetter","__isBuiltIn","rawCounter","rawValueGetter","rawItem","upstream","isSupportedSourceFormat","result","len","length","slice","isNaN","externalTransformMap","registerExternalTransform","type","typeParsed","split","isBuiltIn","set","applyDataTransform","rawTransOption","sourceList","infoForPrint","pipedTransOption","pipeLen","transOption","applySingleDataTransform","Math","max","upSourceList","pipeIndex","transType","get","extUpSourceList","upSource","resultList","transform","upstreamList","config","print","printStrArr","pipeIndexStr","datasetIndex","join","resultIndex","resultMetaRawOption","firstUpSource","concat","sourceHeader","metaRawOption"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { SERIES_LAYOUT_BY_COLUMN, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_ARRAY_ROWS } from '../../util/types';\nimport { normalizeToArray } from '../../util/model';\nimport { createHashMap, bind, each, hasOwn, map, clone, isObject, extend } from 'zrender/lib/core/util';\nimport { getRawSourceItemGetter, getRawSourceDataCounter, getRawSourceValueGetter } from './dataProvider';\nimport { parseDataValue } from './dataValueHelper';\nimport { consoleLog, makePrintable, throwError } from '../../util/log';\nimport { createSource, detectSourceFormat } from '../Source';\n/**\n * TODO: disable writable.\n * This structure will be exposed to users.\n */\n\nvar ExternalSource =\n/** @class */\nfunction () {\n  function ExternalSource() {}\n\n  ExternalSource.prototype.getRawData = function () {\n    // Only built-in transform available.\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.getRawDataItem = function (dataIndex) {\n    // Only built-in transform available.\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.cloneRawData = function () {\n    return;\n  };\n  /**\n   * @return If dimension not found, return null/undefined.\n   */\n\n\n  ExternalSource.prototype.getDimensionInfo = function (dim) {\n    return;\n  };\n  /**\n   * dimensions defined if and only if either:\n   * (a) dataset.dimensions are declared.\n   * (b) dataset data include dimensions definitions in data (detected or via specified `sourceHeader`).\n   * If dimensions are defined, `dimensionInfoAll` is corresponding to\n   * the defined dimensions.\n   * Otherwise, `dimensionInfoAll` is determined by data columns.\n   * @return Always return an array (even empty array).\n   */\n\n\n  ExternalSource.prototype.cloneAllDimensionInfo = function () {\n    return;\n  };\n\n  ExternalSource.prototype.count = function () {\n    return;\n  };\n  /**\n   * Only support by dimension index.\n   * No need to support by dimension name in transform function,\n   * becuase transform function is not case-specific, no need to use name literally.\n   */\n\n\n  ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {\n    return parseDataValue(rawVal, dimInfo);\n  };\n\n  return ExternalSource;\n}();\n\nexport { ExternalSource };\n\nfunction createExternalSource(internalSource, externalTransform) {\n  var extSource = new ExternalSource();\n  var data = internalSource.data;\n  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;\n  var sourceHeaderCount = internalSource.startIndex;\n  var errMsg = '';\n\n  if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {\n    // For the logic simplicity in transformer, only 'culumn' is\n    // supported in data transform. Otherwise, the `dimensionsDefine`\n    // might be detected by 'row', which probably confuses users.\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`seriesLayoutBy` of upstream dataset can only be \"column\" in data transform.';\n    }\n\n    throwError(errMsg);\n  } // [MEMO]\n  // Create a new dimensions structure for exposing.\n  // Do not expose all dimension info to users directly.\n  // Becuase the dimension is probably auto detected from data and not might reliable.\n  // Should not lead the transformers to think that is relialbe and return it.\n  // See [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.\n\n\n  var dimensions = [];\n  var dimsByName = {};\n  var dimsDef = internalSource.dimensionsDefine;\n\n  if (dimsDef) {\n    each(dimsDef, function (dimDef, idx) {\n      var name = dimDef.name;\n      var dimDefExt = {\n        index: idx,\n        name: name,\n        displayName: dimDef.displayName\n      };\n      dimensions.push(dimDefExt); // Users probably not sepcify dimension name. For simplicity, data transform\n      // do not generate dimension name.\n\n      if (name != null) {\n        // Dimension name should not be duplicated.\n        // For simplicity, data transform forbid name duplication, do not generate\n        // new name like module `completeDimensions.ts` did, but just tell users.\n        var errMsg_1 = '';\n\n        if (hasOwn(dimsByName, name)) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg_1 = 'dimension name \"' + name + '\" duplicated.';\n          }\n\n          throwError(errMsg_1);\n        }\n\n        dimsByName[name] = dimDefExt;\n      }\n    });\n  } // If dimension definitions are not defined and can not be detected.\n  // e.g., pure data `[[11, 22], ...]`.\n  else {\n      for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {\n        // Do not generete name or anything others. The consequence process in\n        // `transform` or `series` probably have there own name generation strategry.\n        dimensions.push({\n          index: i\n        });\n      }\n    } // Implement public methods:\n\n\n  var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n\n  if (externalTransform.__isBuiltIn) {\n    extSource.getRawDataItem = function (dataIndex) {\n      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    };\n\n    extSource.getRawData = bind(getRawData, null, internalSource);\n  }\n\n  extSource.cloneRawData = bind(cloneRawData, null, internalSource);\n  var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n  extSource.count = bind(rawCounter, null, data, sourceHeaderCount, dimensions);\n  var rawValueGetter = getRawSourceValueGetter(sourceFormat);\n\n  extSource.retrieveValue = function (dataIndex, dimIndex) {\n    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    return retrieveValueFromItem(rawItem, dimIndex);\n  };\n\n  var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {\n    if (dataItem == null) {\n      return;\n    }\n\n    var dimDef = dimensions[dimIndex]; // When `dimIndex` is `null`, `rawValueGetter` return the whole item.\n\n    if (dimDef) {\n      return rawValueGetter(dataItem, dimIndex, dimDef.name);\n    }\n  };\n\n  extSource.getDimensionInfo = bind(getDimensionInfo, null, dimensions, dimsByName);\n  extSource.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, dimensions);\n  return extSource;\n}\n\nfunction getRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n\n  if (!isSupportedSourceFormat(sourceFormat)) {\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`getRawData` is not supported in source format ' + sourceFormat;\n    }\n\n    throwError(errMsg);\n  }\n\n  return upstream.data;\n}\n\nfunction cloneRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n\n  if (!isSupportedSourceFormat(sourceFormat)) {\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '`cloneRawData` is not supported in source format ' + sourceFormat;\n    }\n\n    throwError(errMsg);\n  }\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      // Not strictly clone for performance\n      result.push(data[i].slice());\n    }\n\n    return result;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      // Not strictly clone for performance\n      result.push(extend({}, data[i]));\n    }\n\n    return result;\n  }\n}\n\nfunction getDimensionInfo(dimensions, dimsByName, dim) {\n  if (dim == null) {\n    return;\n  } // Keep the same logic as `List::getDimension` did.\n\n\n  if (typeof dim === 'number' // If being a number-like string but not being defined a dimension name.\n  || !isNaN(dim) && !hasOwn(dimsByName, dim)) {\n    return dimensions[dim];\n  } else if (hasOwn(dimsByName, dim)) {\n    return dimsByName[dim];\n  }\n}\n\nfunction cloneAllDimensionInfo(dimensions) {\n  return clone(dimensions);\n}\n\nvar externalTransformMap = createHashMap();\nexport function registerExternalTransform(externalTransform) {\n  externalTransform = clone(externalTransform);\n  var type = externalTransform.type;\n  var errMsg = '';\n\n  if (!type) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have a `type` when `registerTransform`.';\n    }\n\n    throwError(errMsg);\n  }\n\n  var typeParsed = type.split(':');\n\n  if (typeParsed.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Name must include namespace like \"ns:regression\".';\n    }\n\n    throwError(errMsg);\n  } // Namespace 'echarts:xxx' is official namespace, where the transforms should\n  // be called directly via 'xxx' rather than 'echarts:xxx'.\n\n\n  var isBuiltIn = false;\n\n  if (typeParsed[0] === 'echarts') {\n    type = typeParsed[1];\n    isBuiltIn = true;\n  }\n\n  externalTransform.__isBuiltIn = isBuiltIn;\n  externalTransformMap.set(type, externalTransform);\n}\nexport function applyDataTransform(rawTransOption, sourceList, infoForPrint) {\n  var pipedTransOption = normalizeToArray(rawTransOption);\n  var pipeLen = pipedTransOption.length;\n  var errMsg = '';\n\n  if (!pipeLen) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'If `transform` declared, it should at least contain one transform.';\n    }\n\n    throwError(errMsg);\n  }\n\n  for (var i = 0, len = pipeLen; i < len; i++) {\n    var transOption = pipedTransOption[i];\n    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i); // piped transform only support single input, except the fist one.\n    // piped transform only support single output, except the last one.\n\n    if (i !== len - 1) {\n      sourceList.length = Math.max(sourceList.length, 1);\n    }\n  }\n\n  return sourceList;\n}\n\nfunction applySingleDataTransform(transOption, upSourceList, infoForPrint, // If `pipeIndex` is null/undefined, no piped transform.\npipeIndex) {\n  var errMsg = '';\n\n  if (!upSourceList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have at least one upstream dataset.';\n    }\n\n    throwError(errMsg);\n  }\n\n  if (!isObject(transOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.';\n    }\n\n    throwError(errMsg);\n  }\n\n  var transType = transOption.type;\n  var externalTransform = externalTransformMap.get(transType);\n\n  if (!externalTransform) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Can not find transform on type \"' + transType + '\".';\n    }\n\n    throwError(errMsg);\n  } // Prepare source\n\n\n  var extUpSourceList = map(upSourceList, function (upSource) {\n    return createExternalSource(upSource, externalTransform);\n  });\n  var resultList = normalizeToArray(externalTransform.transform({\n    upstream: extUpSourceList[0],\n    upstreamList: extUpSourceList,\n    config: clone(transOption.config)\n  }));\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (transOption.print) {\n      var printStrArr = map(resultList, function (extSource) {\n        var pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : '';\n        return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', makePrintable(extSource.data), '- transform result dimensions:', makePrintable(extSource.dimensions)].join('\\n');\n      }).join('\\n');\n      consoleLog(printStrArr);\n    }\n  }\n\n  return map(resultList, function (result, resultIndex) {\n    var errMsg = '';\n\n    if (!isObject(result)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'A transform should not return some empty results.';\n      }\n\n      throwError(errMsg);\n    }\n\n    if (!result.data) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'Transform result data should be not be null or undefined';\n      }\n\n      throwError(errMsg);\n    }\n\n    var sourceFormat = detectSourceFormat(result.data);\n\n    if (!isSupportedSourceFormat(sourceFormat)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'Transform result data should be array rows or object rows.';\n      }\n\n      throwError(errMsg);\n    }\n\n    var resultMetaRawOption;\n    var firstUpSource = upSourceList[0];\n    /**\n     * Intuitively, the end users known the content of the original `dataset.source`,\n     * calucating the transform result in mind.\n     * Suppose the original `dataset.source` is:\n     * ```js\n     * [\n     *     ['product', '2012', '2013', '2014', '2015'],\n     *     ['AAA', 41.1, 30.4, 65.1, 53.3],\n     *     ['BBB', 86.5, 92.1, 85.7, 83.1],\n     *     ['CCC', 24.1, 67.2, 79.5, 86.4]\n     * ]\n     * ```\n     * The dimension info have to be detected from the source data.\n     * Some of the transformers (like filter, sort) will follow the dimension info\n     * of upstream, while others use new dimensions (like aggregate).\n     * Transformer can output a field `dimensions` to define the its own output dimensions.\n     * We also allow transformers to ignore the output `dimensions` field, and\n     * inherit the upstream dimensions definition. It can reduce the burden of handling\n     * dimensions in transformers.\n     *\n     * See also [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.\n     */\n\n    if (firstUpSource && resultIndex === 0 // If transformer returns `dimensions`, it means that the transformer has different\n    // dimensions definitions. We do not inherit anything from upstream.\n    && !result.dimensions) {\n      var startIndex = firstUpSource.startIndex; // We copy the header of upstream to the result becuase:\n      // (1) The returned data always does not contain header line and can not be used\n      // as dimension-detection. In this case we can not use \"detected dimensions\" of\n      // upstream directly, because it might be detected based on different `seriesLayoutBy`.\n      // (2) We should support that the series read the upstream source in `seriesLayoutBy: 'row'`.\n      // So the original detected header should be add to the result, otherwise they can not be read.\n\n      if (startIndex) {\n        result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);\n      }\n\n      resultMetaRawOption = {\n        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,\n        sourceHeader: startIndex,\n        dimensions: firstUpSource.metaRawOption.dimensions\n      };\n    } else {\n      resultMetaRawOption = {\n        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,\n        sourceHeader: 0,\n        dimensions: result.dimensions\n      };\n    }\n\n    return createSource(result.data, resultMetaRawOption, null);\n  });\n}\n\nfunction isSupportedSourceFormat(sourceFormat) {\n  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;\n}"]},"metadata":{},"sourceType":"module"}