{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Link lists and struct (graph or tree)\n */\nimport { curry, each, assert, extend, map, keys } from 'zrender/lib/core/util';\nimport { makeInner } from '../../util/model';\nvar inner = makeInner();\n\nfunction linkSeriesData(opt) {\n  var mainData = opt.mainData;\n  var datas = opt.datas;\n\n  if (!datas) {\n    datas = {\n      main: mainData\n    };\n    opt.datasAttr = {\n      main: 'data'\n    };\n  }\n\n  opt.datas = opt.mainData = null;\n  linkAll(mainData, datas, opt); // Porxy data original methods.\n\n  each(datas, function (data) {\n    each(mainData.TRANSFERABLE_METHODS, function (methodName) {\n      data.wrapMethod(methodName, curry(transferInjection, opt));\n    });\n  }); // Beyond transfer, additional features should be added to `cloneShallow`.\n\n  mainData.wrapMethod('cloneShallow', curry(cloneShallowInjection, opt)); // Only mainData trigger change, because struct.update may trigger\n  // another changable methods, which may bring about dead lock.\n\n  each(mainData.CHANGABLE_METHODS, function (methodName) {\n    mainData.wrapMethod(methodName, curry(changeInjection, opt));\n  }); // Make sure datas contains mainData.\n\n  assert(datas[mainData.dataType] === mainData);\n}\n\nfunction transferInjection(opt, res) {\n  if (isMainData(this)) {\n    // Transfer datas to new main data.\n    var datas = extend({}, inner(this).datas);\n    datas[this.dataType] = res;\n    linkAll(res, datas, opt);\n  } else {\n    // Modify the reference in main data to point newData.\n    linkSingle(res, this.dataType, inner(this).mainData, opt);\n  }\n\n  return res;\n}\n\nfunction changeInjection(opt, res) {\n  opt.struct && opt.struct.update();\n  return res;\n}\n\nfunction cloneShallowInjection(opt, res) {\n  // cloneShallow, which brings about some fragilities, may be inappropriate\n  // to be exposed as an API. So for implementation simplicity we can make\n  // the restriction that cloneShallow of not-mainData should not be invoked\n  // outside, but only be invoked here.\n  each(inner(res).datas, function (data, dataType) {\n    data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);\n  });\n  return res;\n}\n/**\n * Supplement method to List.\n *\n * @public\n * @param [dataType] If not specified, return mainData.\n */\n\n\nfunction getLinkedData(dataType) {\n  var mainData = inner(this).mainData;\n  return dataType == null || mainData == null ? mainData : inner(mainData).datas[dataType];\n}\n/**\n * Get list of all linked data\n */\n\n\nfunction getLinkedDataAll() {\n  var mainData = inner(this).mainData;\n  return mainData == null ? [{\n    data: mainData\n  }] : map(keys(inner(mainData).datas), function (type) {\n    return {\n      type: type,\n      data: inner(mainData).datas[type]\n    };\n  });\n}\n\nfunction isMainData(data) {\n  return inner(data).mainData === data;\n}\n\nfunction linkAll(mainData, datas, opt) {\n  inner(mainData).datas = {};\n  each(datas, function (data, dataType) {\n    linkSingle(data, dataType, mainData, opt);\n  });\n}\n\nfunction linkSingle(data, dataType, mainData, opt) {\n  inner(mainData).datas[dataType] = data;\n  inner(data).mainData = mainData;\n  data.dataType = dataType;\n\n  if (opt.struct) {\n    data[opt.structAttr] = opt.struct;\n    opt.struct[opt.datasAttr[dataType]] = data;\n  } // Supplement method.\n\n\n  data.getLinkedData = getLinkedData;\n  data.getLinkedDataAll = getLinkedDataAll;\n}\n\nexport default linkSeriesData;","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/data/helper/linkSeriesData.js"],"names":["curry","each","assert","extend","map","keys","makeInner","inner","linkSeriesData","opt","mainData","datas","main","datasAttr","linkAll","data","TRANSFERABLE_METHODS","methodName","wrapMethod","transferInjection","cloneShallowInjection","CHANGABLE_METHODS","changeInjection","dataType","res","isMainData","linkSingle","struct","update","cloneShallow","getLinkedData","getLinkedDataAll","type","structAttr"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Link lists and struct (graph or tree)\n */\nimport { curry, each, assert, extend, map, keys } from 'zrender/lib/core/util';\nimport { makeInner } from '../../util/model';\nvar inner = makeInner();\n\nfunction linkSeriesData(opt) {\n  var mainData = opt.mainData;\n  var datas = opt.datas;\n\n  if (!datas) {\n    datas = {\n      main: mainData\n    };\n    opt.datasAttr = {\n      main: 'data'\n    };\n  }\n\n  opt.datas = opt.mainData = null;\n  linkAll(mainData, datas, opt); // Porxy data original methods.\n\n  each(datas, function (data) {\n    each(mainData.TRANSFERABLE_METHODS, function (methodName) {\n      data.wrapMethod(methodName, curry(transferInjection, opt));\n    });\n  }); // Beyond transfer, additional features should be added to `cloneShallow`.\n\n  mainData.wrapMethod('cloneShallow', curry(cloneShallowInjection, opt)); // Only mainData trigger change, because struct.update may trigger\n  // another changable methods, which may bring about dead lock.\n\n  each(mainData.CHANGABLE_METHODS, function (methodName) {\n    mainData.wrapMethod(methodName, curry(changeInjection, opt));\n  }); // Make sure datas contains mainData.\n\n  assert(datas[mainData.dataType] === mainData);\n}\n\nfunction transferInjection(opt, res) {\n  if (isMainData(this)) {\n    // Transfer datas to new main data.\n    var datas = extend({}, inner(this).datas);\n    datas[this.dataType] = res;\n    linkAll(res, datas, opt);\n  } else {\n    // Modify the reference in main data to point newData.\n    linkSingle(res, this.dataType, inner(this).mainData, opt);\n  }\n\n  return res;\n}\n\nfunction changeInjection(opt, res) {\n  opt.struct && opt.struct.update();\n  return res;\n}\n\nfunction cloneShallowInjection(opt, res) {\n  // cloneShallow, which brings about some fragilities, may be inappropriate\n  // to be exposed as an API. So for implementation simplicity we can make\n  // the restriction that cloneShallow of not-mainData should not be invoked\n  // outside, but only be invoked here.\n  each(inner(res).datas, function (data, dataType) {\n    data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);\n  });\n  return res;\n}\n/**\n * Supplement method to List.\n *\n * @public\n * @param [dataType] If not specified, return mainData.\n */\n\n\nfunction getLinkedData(dataType) {\n  var mainData = inner(this).mainData;\n  return dataType == null || mainData == null ? mainData : inner(mainData).datas[dataType];\n}\n/**\n * Get list of all linked data\n */\n\n\nfunction getLinkedDataAll() {\n  var mainData = inner(this).mainData;\n  return mainData == null ? [{\n    data: mainData\n  }] : map(keys(inner(mainData).datas), function (type) {\n    return {\n      type: type,\n      data: inner(mainData).datas[type]\n    };\n  });\n}\n\nfunction isMainData(data) {\n  return inner(data).mainData === data;\n}\n\nfunction linkAll(mainData, datas, opt) {\n  inner(mainData).datas = {};\n  each(datas, function (data, dataType) {\n    linkSingle(data, dataType, mainData, opt);\n  });\n}\n\nfunction linkSingle(data, dataType, mainData, opt) {\n  inner(mainData).datas[dataType] = data;\n  inner(data).mainData = mainData;\n  data.dataType = dataType;\n\n  if (opt.struct) {\n    data[opt.structAttr] = opt.struct;\n    opt.struct[opt.datasAttr[dataType]] = data;\n  } // Supplement method.\n\n\n  data.getLinkedData = getLinkedData;\n  data.getLinkedDataAll = getLinkedDataAll;\n}\n\nexport default linkSeriesData;"]},"metadata":{},"sourceType":"module"}