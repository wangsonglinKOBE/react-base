{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { parseSVG, makeViewBoxTransform } from 'zrender/lib/tool/parseSVG';\nimport Group from 'zrender/lib/graphic/Group';\nimport Rect from 'zrender/lib/graphic/shape/Rect';\nimport { assert, createHashMap, each } from 'zrender/lib/core/util';\nimport BoundingRect from 'zrender/lib/core/BoundingRect';\nimport { parseXML } from 'zrender/lib/tool/parseXML';\nimport { GeoSVGRegion } from './Region';\n/**\n * \"region available\" means that: enable users to set attribute `name=\"xxx\"` on those tags\n * to make it be a region.\n * 1. region styles and its label styles can be defined in echarts opton:\n * ```js\n * geo: {\n *     regions: [{\n *         name: 'xxx',\n *         itemStyle: { ... },\n *         label: { ... }\n *     }, {\n *         ...\n *     },\n *     ...]\n * };\n * ```\n * 2. name can be duplicated in different SVG tag. All of the tags with the same name share\n * a region option. For exampel if there are two <path> representing two lung lobes. They have\n * no common parents but both of them need to display label \"lung\" inside.\n */\n\nvar REGION_AVAILABLE_SVG_TAG_MAP = createHashMap(['rect', 'circle', 'line', 'ellipse', 'polygon', 'polyline', 'path', // <text> <tspan> are also enabled becuase some SVG might paint text itself,\n// but still need to trigger events or tooltip.\n'text', 'tspan', // <g> is also enabled because this case: if multiple tags share one name\n// and need label displayed, every tags will display the name, which is not\n// expected. So we can put them into a <g name=\"xxx\">. Thereby only one label\n// displayed and located based on the bounding rect of the <g>.\n'g']);\n\nvar GeoSVGResource =\n/** @class */\nfunction () {\n  function GeoSVGResource(mapName, svg) {\n    this.type = 'geoSVG'; // All used graphics. key: hostKey, value: root\n\n    this._usedGraphicMap = createHashMap(); // All unused graphics.\n\n    this._freedGraphics = [];\n    this._mapName = mapName; // Only perform parse to XML object here, which might be time\n    // consiming for large SVG.\n    // Although convert XML to zrender element is also time consiming,\n    // if we do it here, the clone of zrender elements has to be\n    // required. So we do it once for each geo instance, util real\n    // performance issues call for optimizing it.\n\n    this._parsedXML = parseXML(svg);\n  }\n\n  GeoSVGResource.prototype.load = function ()\n  /* nameMap: NameMap */\n  {\n    // In the \"load\" stage, graphic need to be built to\n    // get boundingRect for geo coordinate system.\n    var firstGraphic = this._firstGraphic; // Create the return data structure only when first graphic created.\n    // Because they will be used in geo coordinate system update stage,\n    // and `regions` will be mounted at `geo` coordinate system,\n    // in which there is no \"view\" info, so that it should better not to\n    // make references to graphic elements.\n\n    if (!firstGraphic) {\n      firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML);\n\n      this._freedGraphics.push(firstGraphic);\n\n      this._boundingRect = this._firstGraphic.boundingRect.clone(); // PENDING: `nameMap` will not be supported until some real requirement come.\n      // if (nameMap) {\n      //     named = applyNameMap(named, nameMap);\n      // }\n\n      var _a = createRegions(firstGraphic.named),\n          regions = _a.regions,\n          regionsMap = _a.regionsMap;\n\n      this._regions = regions;\n      this._regionsMap = regionsMap;\n    }\n\n    return {\n      boundingRect: this._boundingRect,\n      regions: this._regions,\n      regionsMap: this._regionsMap\n    };\n  };\n\n  GeoSVGResource.prototype._buildGraphic = function (svgXML) {\n    var result;\n    var rootFromParse;\n\n    try {\n      result = svgXML && parseSVG(svgXML, {\n        ignoreViewBox: true,\n        ignoreRootClip: true\n      }) || {};\n      rootFromParse = result.root;\n      assert(rootFromParse != null);\n    } catch (e) {\n      throw new Error('Invalid svg format\\n' + e.message);\n    } // Note: we keep the covenant that the root has no transform. So always add an extra root.\n\n\n    var root = new Group();\n    root.add(rootFromParse);\n    root.isGeoSVGGraphicRoot = true; // [THE_RULE_OF_VIEWPORT_AND_VIEWBOX]\n    //\n    // Consider: `<svg width=\"...\" height=\"...\" viewBox=\"...\">`\n    // - the `width/height` we call it `svgWidth/svgHeight` for short.\n    // - `(0, 0, svgWidth, svgHeight)` defines the viewport of the SVG, or say,\n    //   \"viewport boundingRect\", or `boundingRect` for short.\n    // - `viewBox` defines the transform from the real content ot the viewport.\n    //   `viewBox` has the same unit as the content of SVG.\n    //   If `viewBox` exists, a transform is defined, so the unit of `svgWidth/svgHeight` become\n    //   different from the content of SVG. Otherwise, they are the same.\n    //\n    // If both `svgWidth/svgHeight/viewBox` are specified in a SVG file, the transform rule will be:\n    // 0. `boundingRect` is `(0, 0, svgWidth, svgHeight)`. Set it to Geo['_rect'] (View['_rect']).\n    // 1. Make a transform from `viewBox` to `boundingRect`.\n    //    Note: only suport `preserveAspectRatio 'xMidYMid'` here. That is, this transform will preserve\n    //    the aspect ratio.\n    // 2. Make a transform from boundingRect to Geo['_viewRect'] (View['_viewRect'])\n    //    (`Geo`/`View` will do this job).\n    //    Note: this transform might not preserve aspect radio, which depending on how users specify\n    //    viewRect in echarts option (e.g., `geo.left/top/width/height` will not preserve aspect ratio,\n    //    but `geo.layoutCenter/layoutSize` will preserve aspect ratio).\n    //\n    // If `svgWidth/svgHeight` not specified, we use `viewBox` as the `boundingRect` to make the SVG\n    // layout look good.\n    //\n    // If neither `svgWidth/svgHeight` nor `viewBox` are not specified, we calculate the boundingRect\n    // of the SVG content and use them to make SVG layout look good.\n\n    var svgWidth = result.width;\n    var svgHeight = result.height;\n    var viewBoxRect = result.viewBoxRect;\n    var boundingRect = this._boundingRect;\n\n    if (!boundingRect) {\n      var bRectX = void 0;\n      var bRectY = void 0;\n      var bRectWidth = void 0;\n      var bRectHeight = void 0;\n\n      if (svgWidth != null) {\n        bRectX = 0;\n        bRectWidth = svgWidth;\n      } else if (viewBoxRect) {\n        bRectX = viewBoxRect.x;\n        bRectWidth = viewBoxRect.width;\n      }\n\n      if (svgHeight != null) {\n        bRectY = 0;\n        bRectHeight = svgHeight;\n      } else if (viewBoxRect) {\n        bRectY = viewBoxRect.y;\n        bRectHeight = viewBoxRect.height;\n      } // If both viewBox and svgWidth/svgHeight not specified,\n      // we have to determine how to layout those element to make them look good.\n\n\n      if (bRectX == null || bRectY == null) {\n        var calculatedBoundingRect = rootFromParse.getBoundingRect();\n\n        if (bRectX == null) {\n          bRectX = calculatedBoundingRect.x;\n          bRectWidth = calculatedBoundingRect.width;\n        }\n\n        if (bRectY == null) {\n          bRectY = calculatedBoundingRect.y;\n          bRectHeight = calculatedBoundingRect.height;\n        }\n      }\n\n      boundingRect = this._boundingRect = new BoundingRect(bRectX, bRectY, bRectWidth, bRectHeight);\n    }\n\n    if (viewBoxRect) {\n      var viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect); // Only support `preserveAspectRatio 'xMidYMid'`\n\n      rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale;\n      rootFromParse.x = viewBoxTransform.x;\n      rootFromParse.y = viewBoxTransform.y;\n    } // SVG needs to clip based on `viewBox`. And some SVG files really rely on this feature.\n    // They do not strictly confine all of the content inside a display rect, but deliberately\n    // use a `viewBox` to define a displayable rect.\n    // PENDING:\n    // The drawback of the `setClipPath` here is: the region label (genereted by echarts) near the\n    // edge might also be clipped, because region labels are put as `textContent` of the SVG path.\n\n\n    root.setClipPath(new Rect({\n      shape: boundingRect.plain()\n    }));\n    var named = [];\n    each(result.named, function (namedItem) {\n      if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {\n        named.push(namedItem);\n        setSilent(namedItem.el);\n      }\n    });\n    return {\n      root: root,\n      boundingRect: boundingRect,\n      named: named\n    };\n  };\n  /**\n   * Consider:\n   * (1) One graphic element can not be shared by different `geoView` running simultaneously.\n   *     Notice, also need to consider multiple echarts instances share a `mapRecord`.\n   * (2) Converting SVG to graphic elements is time consuming.\n   * (3) In the current architecture, `load` should be called frequently to get boundingRect,\n   *     and it is called without view info.\n   * So we maintain graphic elements in this module, and enables `view` to use/return these\n   * graphics from/to the pool with it's uid.\n   */\n\n\n  GeoSVGResource.prototype.useGraphic = function (hostKey\n  /*, nameMap: NameMap */\n  ) {\n    var usedRootMap = this._usedGraphicMap;\n    var svgGraphic = usedRootMap.get(hostKey);\n\n    if (svgGraphic) {\n      return svgGraphic;\n    }\n\n    svgGraphic = this._freedGraphics.pop() // use the first boundingRect to avoid duplicated boundingRect calculation.\n    || this._buildGraphic(this._parsedXML);\n    usedRootMap.set(hostKey, svgGraphic); // PENDING: `nameMap` will not be supported until some real requirement come.\n    // `nameMap` can only be obtained from echarts option.\n    // The original `named` must not be modified.\n    // if (nameMap) {\n    //     svgGraphic = extend({}, svgGraphic);\n    //     svgGraphic.named = applyNameMap(svgGraphic.named, nameMap);\n    // }\n\n    return svgGraphic;\n  };\n\n  GeoSVGResource.prototype.freeGraphic = function (hostKey) {\n    var usedRootMap = this._usedGraphicMap;\n    var svgGraphic = usedRootMap.get(hostKey);\n\n    if (svgGraphic) {\n      usedRootMap.removeKey(hostKey);\n\n      this._freedGraphics.push(svgGraphic);\n    }\n  };\n\n  return GeoSVGResource;\n}();\n\nexport { GeoSVGResource };\n\nfunction setSilent(el) {\n  // Only named element has silent: false, other elements should\n  // act as background and has no user interaction.\n  el.silent = false; // text|tspan will be converted to group.\n\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.silent = false;\n    });\n  }\n}\n\nfunction createRegions(named) {\n  var regions = [];\n  var regionsMap = createHashMap(); // Create resions only for the first graphic.\n\n  each(named, function (namedItem) {\n    // Region has feature to calculate center for tooltip or other features.\n    // If there is a <g name=\"xxx\">, the center should be the center of the\n    // bounding rect of the g.\n    if (namedItem.namedFrom != null) {\n      return;\n    }\n\n    var region = new GeoSVGRegion(namedItem.name, namedItem.el); // PENDING: if `nameMap` supported, this region can not be mounted on\n    // `this`, but can only be created each time `load()` called.\n\n    regions.push(region); // PENDING: if multiple tag named with the same name, only one will be\n    // found by `_regionsMap`. `_regionsMap` is used to find a coordinate\n    // by name. We use `region.getCenter()` as the coordinate.\n\n    regionsMap.set(namedItem.name, region);\n  });\n  return {\n    regions: regions,\n    regionsMap: regionsMap\n  };\n} // PENDING: `nameMap` will not be supported until some real requirement come.\n// /**\n//  * Use the alias in geoNameMap.\n//  * The input `named` must not be modified.\n//  */\n// function applyNameMap(\n//     named: GeoSVGGraphicRecord['named'],\n//     nameMap: NameMap\n// ): GeoSVGGraphicRecord['named'] {\n//     const result = [] as GeoSVGGraphicRecord['named'];\n//     for (let i = 0; i < named.length; i++) {\n//         let regionGraphic = named[i];\n//         const name = regionGraphic.name;\n//         if (nameMap && nameMap.hasOwnProperty(name)) {\n//             regionGraphic = extend({}, regionGraphic);\n//             regionGraphic.name = name;\n//         }\n//         result.push(regionGraphic);\n//     }\n//     return result;\n// }","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/coord/geo/GeoSVGResource.js"],"names":["parseSVG","makeViewBoxTransform","Group","Rect","assert","createHashMap","each","BoundingRect","parseXML","GeoSVGRegion","REGION_AVAILABLE_SVG_TAG_MAP","GeoSVGResource","mapName","svg","type","_usedGraphicMap","_freedGraphics","_mapName","_parsedXML","prototype","load","firstGraphic","_firstGraphic","_buildGraphic","push","_boundingRect","boundingRect","clone","_a","createRegions","named","regions","regionsMap","_regions","_regionsMap","svgXML","result","rootFromParse","ignoreViewBox","ignoreRootClip","root","e","Error","message","add","isGeoSVGGraphicRoot","svgWidth","width","svgHeight","height","viewBoxRect","bRectX","bRectY","bRectWidth","bRectHeight","x","y","calculatedBoundingRect","getBoundingRect","viewBoxTransform","scaleX","scaleY","scale","setClipPath","shape","plain","namedItem","get","svgNodeTagLower","setSilent","el","useGraphic","hostKey","usedRootMap","svgGraphic","pop","set","freeGraphic","removeKey","silent","isGroup","traverse","child","namedFrom","region","name"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { parseSVG, makeViewBoxTransform } from 'zrender/lib/tool/parseSVG';\nimport Group from 'zrender/lib/graphic/Group';\nimport Rect from 'zrender/lib/graphic/shape/Rect';\nimport { assert, createHashMap, each } from 'zrender/lib/core/util';\nimport BoundingRect from 'zrender/lib/core/BoundingRect';\nimport { parseXML } from 'zrender/lib/tool/parseXML';\nimport { GeoSVGRegion } from './Region';\n/**\n * \"region available\" means that: enable users to set attribute `name=\"xxx\"` on those tags\n * to make it be a region.\n * 1. region styles and its label styles can be defined in echarts opton:\n * ```js\n * geo: {\n *     regions: [{\n *         name: 'xxx',\n *         itemStyle: { ... },\n *         label: { ... }\n *     }, {\n *         ...\n *     },\n *     ...]\n * };\n * ```\n * 2. name can be duplicated in different SVG tag. All of the tags with the same name share\n * a region option. For exampel if there are two <path> representing two lung lobes. They have\n * no common parents but both of them need to display label \"lung\" inside.\n */\n\nvar REGION_AVAILABLE_SVG_TAG_MAP = createHashMap(['rect', 'circle', 'line', 'ellipse', 'polygon', 'polyline', 'path', // <text> <tspan> are also enabled becuase some SVG might paint text itself,\n// but still need to trigger events or tooltip.\n'text', 'tspan', // <g> is also enabled because this case: if multiple tags share one name\n// and need label displayed, every tags will display the name, which is not\n// expected. So we can put them into a <g name=\"xxx\">. Thereby only one label\n// displayed and located based on the bounding rect of the <g>.\n'g']);\n\nvar GeoSVGResource =\n/** @class */\nfunction () {\n  function GeoSVGResource(mapName, svg) {\n    this.type = 'geoSVG'; // All used graphics. key: hostKey, value: root\n\n    this._usedGraphicMap = createHashMap(); // All unused graphics.\n\n    this._freedGraphics = [];\n    this._mapName = mapName; // Only perform parse to XML object here, which might be time\n    // consiming for large SVG.\n    // Although convert XML to zrender element is also time consiming,\n    // if we do it here, the clone of zrender elements has to be\n    // required. So we do it once for each geo instance, util real\n    // performance issues call for optimizing it.\n\n    this._parsedXML = parseXML(svg);\n  }\n\n  GeoSVGResource.prototype.load = function ()\n  /* nameMap: NameMap */\n  {\n    // In the \"load\" stage, graphic need to be built to\n    // get boundingRect for geo coordinate system.\n    var firstGraphic = this._firstGraphic; // Create the return data structure only when first graphic created.\n    // Because they will be used in geo coordinate system update stage,\n    // and `regions` will be mounted at `geo` coordinate system,\n    // in which there is no \"view\" info, so that it should better not to\n    // make references to graphic elements.\n\n    if (!firstGraphic) {\n      firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML);\n\n      this._freedGraphics.push(firstGraphic);\n\n      this._boundingRect = this._firstGraphic.boundingRect.clone(); // PENDING: `nameMap` will not be supported until some real requirement come.\n      // if (nameMap) {\n      //     named = applyNameMap(named, nameMap);\n      // }\n\n      var _a = createRegions(firstGraphic.named),\n          regions = _a.regions,\n          regionsMap = _a.regionsMap;\n\n      this._regions = regions;\n      this._regionsMap = regionsMap;\n    }\n\n    return {\n      boundingRect: this._boundingRect,\n      regions: this._regions,\n      regionsMap: this._regionsMap\n    };\n  };\n\n  GeoSVGResource.prototype._buildGraphic = function (svgXML) {\n    var result;\n    var rootFromParse;\n\n    try {\n      result = svgXML && parseSVG(svgXML, {\n        ignoreViewBox: true,\n        ignoreRootClip: true\n      }) || {};\n      rootFromParse = result.root;\n      assert(rootFromParse != null);\n    } catch (e) {\n      throw new Error('Invalid svg format\\n' + e.message);\n    } // Note: we keep the covenant that the root has no transform. So always add an extra root.\n\n\n    var root = new Group();\n    root.add(rootFromParse);\n    root.isGeoSVGGraphicRoot = true; // [THE_RULE_OF_VIEWPORT_AND_VIEWBOX]\n    //\n    // Consider: `<svg width=\"...\" height=\"...\" viewBox=\"...\">`\n    // - the `width/height` we call it `svgWidth/svgHeight` for short.\n    // - `(0, 0, svgWidth, svgHeight)` defines the viewport of the SVG, or say,\n    //   \"viewport boundingRect\", or `boundingRect` for short.\n    // - `viewBox` defines the transform from the real content ot the viewport.\n    //   `viewBox` has the same unit as the content of SVG.\n    //   If `viewBox` exists, a transform is defined, so the unit of `svgWidth/svgHeight` become\n    //   different from the content of SVG. Otherwise, they are the same.\n    //\n    // If both `svgWidth/svgHeight/viewBox` are specified in a SVG file, the transform rule will be:\n    // 0. `boundingRect` is `(0, 0, svgWidth, svgHeight)`. Set it to Geo['_rect'] (View['_rect']).\n    // 1. Make a transform from `viewBox` to `boundingRect`.\n    //    Note: only suport `preserveAspectRatio 'xMidYMid'` here. That is, this transform will preserve\n    //    the aspect ratio.\n    // 2. Make a transform from boundingRect to Geo['_viewRect'] (View['_viewRect'])\n    //    (`Geo`/`View` will do this job).\n    //    Note: this transform might not preserve aspect radio, which depending on how users specify\n    //    viewRect in echarts option (e.g., `geo.left/top/width/height` will not preserve aspect ratio,\n    //    but `geo.layoutCenter/layoutSize` will preserve aspect ratio).\n    //\n    // If `svgWidth/svgHeight` not specified, we use `viewBox` as the `boundingRect` to make the SVG\n    // layout look good.\n    //\n    // If neither `svgWidth/svgHeight` nor `viewBox` are not specified, we calculate the boundingRect\n    // of the SVG content and use them to make SVG layout look good.\n\n    var svgWidth = result.width;\n    var svgHeight = result.height;\n    var viewBoxRect = result.viewBoxRect;\n    var boundingRect = this._boundingRect;\n\n    if (!boundingRect) {\n      var bRectX = void 0;\n      var bRectY = void 0;\n      var bRectWidth = void 0;\n      var bRectHeight = void 0;\n\n      if (svgWidth != null) {\n        bRectX = 0;\n        bRectWidth = svgWidth;\n      } else if (viewBoxRect) {\n        bRectX = viewBoxRect.x;\n        bRectWidth = viewBoxRect.width;\n      }\n\n      if (svgHeight != null) {\n        bRectY = 0;\n        bRectHeight = svgHeight;\n      } else if (viewBoxRect) {\n        bRectY = viewBoxRect.y;\n        bRectHeight = viewBoxRect.height;\n      } // If both viewBox and svgWidth/svgHeight not specified,\n      // we have to determine how to layout those element to make them look good.\n\n\n      if (bRectX == null || bRectY == null) {\n        var calculatedBoundingRect = rootFromParse.getBoundingRect();\n\n        if (bRectX == null) {\n          bRectX = calculatedBoundingRect.x;\n          bRectWidth = calculatedBoundingRect.width;\n        }\n\n        if (bRectY == null) {\n          bRectY = calculatedBoundingRect.y;\n          bRectHeight = calculatedBoundingRect.height;\n        }\n      }\n\n      boundingRect = this._boundingRect = new BoundingRect(bRectX, bRectY, bRectWidth, bRectHeight);\n    }\n\n    if (viewBoxRect) {\n      var viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect); // Only support `preserveAspectRatio 'xMidYMid'`\n\n      rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale;\n      rootFromParse.x = viewBoxTransform.x;\n      rootFromParse.y = viewBoxTransform.y;\n    } // SVG needs to clip based on `viewBox`. And some SVG files really rely on this feature.\n    // They do not strictly confine all of the content inside a display rect, but deliberately\n    // use a `viewBox` to define a displayable rect.\n    // PENDING:\n    // The drawback of the `setClipPath` here is: the region label (genereted by echarts) near the\n    // edge might also be clipped, because region labels are put as `textContent` of the SVG path.\n\n\n    root.setClipPath(new Rect({\n      shape: boundingRect.plain()\n    }));\n    var named = [];\n    each(result.named, function (namedItem) {\n      if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {\n        named.push(namedItem);\n        setSilent(namedItem.el);\n      }\n    });\n    return {\n      root: root,\n      boundingRect: boundingRect,\n      named: named\n    };\n  };\n  /**\n   * Consider:\n   * (1) One graphic element can not be shared by different `geoView` running simultaneously.\n   *     Notice, also need to consider multiple echarts instances share a `mapRecord`.\n   * (2) Converting SVG to graphic elements is time consuming.\n   * (3) In the current architecture, `load` should be called frequently to get boundingRect,\n   *     and it is called without view info.\n   * So we maintain graphic elements in this module, and enables `view` to use/return these\n   * graphics from/to the pool with it's uid.\n   */\n\n\n  GeoSVGResource.prototype.useGraphic = function (hostKey\n  /*, nameMap: NameMap */\n  ) {\n    var usedRootMap = this._usedGraphicMap;\n    var svgGraphic = usedRootMap.get(hostKey);\n\n    if (svgGraphic) {\n      return svgGraphic;\n    }\n\n    svgGraphic = this._freedGraphics.pop() // use the first boundingRect to avoid duplicated boundingRect calculation.\n    || this._buildGraphic(this._parsedXML);\n    usedRootMap.set(hostKey, svgGraphic); // PENDING: `nameMap` will not be supported until some real requirement come.\n    // `nameMap` can only be obtained from echarts option.\n    // The original `named` must not be modified.\n    // if (nameMap) {\n    //     svgGraphic = extend({}, svgGraphic);\n    //     svgGraphic.named = applyNameMap(svgGraphic.named, nameMap);\n    // }\n\n    return svgGraphic;\n  };\n\n  GeoSVGResource.prototype.freeGraphic = function (hostKey) {\n    var usedRootMap = this._usedGraphicMap;\n    var svgGraphic = usedRootMap.get(hostKey);\n\n    if (svgGraphic) {\n      usedRootMap.removeKey(hostKey);\n\n      this._freedGraphics.push(svgGraphic);\n    }\n  };\n\n  return GeoSVGResource;\n}();\n\nexport { GeoSVGResource };\n\nfunction setSilent(el) {\n  // Only named element has silent: false, other elements should\n  // act as background and has no user interaction.\n  el.silent = false; // text|tspan will be converted to group.\n\n  if (el.isGroup) {\n    el.traverse(function (child) {\n      child.silent = false;\n    });\n  }\n}\n\nfunction createRegions(named) {\n  var regions = [];\n  var regionsMap = createHashMap(); // Create resions only for the first graphic.\n\n  each(named, function (namedItem) {\n    // Region has feature to calculate center for tooltip or other features.\n    // If there is a <g name=\"xxx\">, the center should be the center of the\n    // bounding rect of the g.\n    if (namedItem.namedFrom != null) {\n      return;\n    }\n\n    var region = new GeoSVGRegion(namedItem.name, namedItem.el); // PENDING: if `nameMap` supported, this region can not be mounted on\n    // `this`, but can only be created each time `load()` called.\n\n    regions.push(region); // PENDING: if multiple tag named with the same name, only one will be\n    // found by `_regionsMap`. `_regionsMap` is used to find a coordinate\n    // by name. We use `region.getCenter()` as the coordinate.\n\n    regionsMap.set(namedItem.name, region);\n  });\n  return {\n    regions: regions,\n    regionsMap: regionsMap\n  };\n} // PENDING: `nameMap` will not be supported until some real requirement come.\n// /**\n//  * Use the alias in geoNameMap.\n//  * The input `named` must not be modified.\n//  */\n// function applyNameMap(\n//     named: GeoSVGGraphicRecord['named'],\n//     nameMap: NameMap\n// ): GeoSVGGraphicRecord['named'] {\n//     const result = [] as GeoSVGGraphicRecord['named'];\n//     for (let i = 0; i < named.length; i++) {\n//         let regionGraphic = named[i];\n//         const name = regionGraphic.name;\n//         if (nameMap && nameMap.hasOwnProperty(name)) {\n//             regionGraphic = extend({}, regionGraphic);\n//             regionGraphic.name = name;\n//         }\n//         result.push(regionGraphic);\n//     }\n//     return result;\n// }"]},"metadata":{},"sourceType":"module"}