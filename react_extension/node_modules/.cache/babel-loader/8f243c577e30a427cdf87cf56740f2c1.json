{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport SymbolDraw from '../../chart/helper/SymbolDraw';\nimport * as numberUtil from '../../util/number';\nimport SeriesData from '../../data/SeriesData';\nimport * as markerHelper from './markerHelper';\nimport MarkerView from './MarkerView';\nimport MarkerModel from './MarkerModel';\nimport { isFunction, map, filter, curry, extend } from 'zrender/lib/core/util';\nimport { getECData } from '../../util/innerStore';\nimport { getVisualFromData } from '../../visual/helper';\n\nfunction updateMarkerLayout(mpData, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  mpData.each(function (idx) {\n    var itemModel = mpData.getItemModel(idx);\n    var point;\n    var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n    var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n\n    if (!isNaN(xPx) && !isNaN(yPx)) {\n      point = [xPx, yPx];\n    } // Chart like bar may have there own marker positioning logic\n    else if (seriesModel.getMarkerPosition) {\n      // Use the getMarkerPoisition\n      point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));\n    } else if (coordSys) {\n      var x = mpData.get(coordSys.dimensions[0], idx);\n      var y = mpData.get(coordSys.dimensions[1], idx);\n      point = coordSys.dataToPoint([x, y]);\n    } // Use x, y if has any\n\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n\n    mpData.setItemLayout(idx, point);\n  });\n}\n\nvar MarkPointView =\n/** @class */\nfunction (_super) {\n  __extends(MarkPointView, _super);\n\n  function MarkPointView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = MarkPointView.type;\n    return _this;\n  }\n\n  MarkPointView.prototype.updateTransform = function (markPointModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var mpModel = MarkerModel.getMarkerModelFromSeries(seriesModel, 'markPoint');\n\n      if (mpModel) {\n        updateMarkerLayout(mpModel.getData(), seriesModel, api);\n        this.markerGroupMap.get(seriesModel.id).updateLayout();\n      }\n    }, this);\n  };\n\n  MarkPointView.prototype.renderSeries = function (seriesModel, mpModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var symbolDrawMap = this.markerGroupMap;\n    var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw());\n    var mpData = createData(coordSys, seriesModel, mpModel); // FIXME\n\n    mpModel.setData(mpData);\n    updateMarkerLayout(mpModel.getData(), seriesModel, api);\n    mpData.each(function (idx) {\n      var itemModel = mpData.getItemModel(idx);\n      var symbol = itemModel.getShallow('symbol');\n      var symbolSize = itemModel.getShallow('symbolSize');\n      var symbolRotate = itemModel.getShallow('symbolRotate');\n      var symbolOffset = itemModel.getShallow('symbolOffset');\n      var symbolKeepAspect = itemModel.getShallow('symbolKeepAspect'); // TODO: refactor needed: single data item should not support callback function\n\n      if (isFunction(symbol) || isFunction(symbolSize) || isFunction(symbolRotate) || isFunction(symbolOffset)) {\n        var rawIdx = mpModel.getRawValue(idx);\n        var dataParams = mpModel.getDataParams(idx);\n\n        if (isFunction(symbol)) {\n          symbol = symbol(rawIdx, dataParams);\n        }\n\n        if (isFunction(symbolSize)) {\n          // FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？\n          symbolSize = symbolSize(rawIdx, dataParams);\n        }\n\n        if (isFunction(symbolRotate)) {\n          symbolRotate = symbolRotate(rawIdx, dataParams);\n        }\n\n        if (isFunction(symbolOffset)) {\n          symbolOffset = symbolOffset(rawIdx, dataParams);\n        }\n      }\n\n      var style = itemModel.getModel('itemStyle').getItemStyle();\n      var color = getVisualFromData(seriesData, 'color');\n\n      if (!style.fill) {\n        style.fill = color;\n      }\n\n      mpData.setItemVisual(idx, {\n        symbol: symbol,\n        symbolSize: symbolSize,\n        symbolRotate: symbolRotate,\n        symbolOffset: symbolOffset,\n        symbolKeepAspect: symbolKeepAspect,\n        style: style\n      });\n    }); // TODO Text are wrong\n\n    symbolDraw.updateData(mpData);\n    this.group.add(symbolDraw.group); // Set host model for tooltip\n    // FIXME\n\n    mpData.eachItemGraphicEl(function (el) {\n      el.traverse(function (child) {\n        getECData(child).dataModel = mpModel;\n      });\n    });\n    this.markKeep(symbolDraw);\n    symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');\n  };\n\n  MarkPointView.type = 'markPoint';\n  return MarkPointView;\n}(MarkerView);\n\nfunction createData(coordSys, seriesModel, mpModel) {\n  var coordDimsInfos;\n\n  if (coordSys) {\n    coordDimsInfos = map(coordSys && coordSys.dimensions, function (coordDim) {\n      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      return extend(extend({}, info), {\n        name: coordDim,\n        // DON'T use ordinalMeta to parse and collect ordinal.\n        ordinalMeta: null\n      });\n    });\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n  }\n\n  var mpData = new SeriesData(coordDimsInfos, mpModel);\n  var dataOpt = map(mpModel.get('data'), curry(markerHelper.dataTransform, seriesModel));\n\n  if (coordSys) {\n    dataOpt = filter(dataOpt, curry(markerHelper.dataFilter, coordSys));\n  }\n\n  mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function (item) {\n    return item.value;\n  });\n  return mpData;\n}\n\nexport default MarkPointView;","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/component/marker/MarkPointView.js"],"names":["__extends","SymbolDraw","numberUtil","SeriesData","markerHelper","MarkerView","MarkerModel","isFunction","map","filter","curry","extend","getECData","getVisualFromData","updateMarkerLayout","mpData","seriesModel","api","coordSys","coordinateSystem","each","idx","itemModel","getItemModel","point","xPx","parsePercent","get","getWidth","yPx","getHeight","isNaN","getMarkerPosition","getValues","dimensions","x","y","dataToPoint","setItemLayout","MarkPointView","_super","_this","apply","arguments","type","prototype","updateTransform","markPointModel","ecModel","eachSeries","mpModel","getMarkerModelFromSeries","getData","markerGroupMap","id","updateLayout","renderSeries","seriesId","seriesData","symbolDrawMap","symbolDraw","set","createData","setData","symbol","getShallow","symbolSize","symbolRotate","symbolOffset","symbolKeepAspect","rawIdx","getRawValue","dataParams","getDataParams","style","getModel","getItemStyle","color","fill","setItemVisual","updateData","group","add","eachItemGraphicEl","el","traverse","child","dataModel","markKeep","silent","coordDimsInfos","coordDim","info","getDimensionInfo","mapDimension","name","ordinalMeta","dataOpt","dataTransform","dataFilter","initData","dimValueGetter","item","value"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport SymbolDraw from '../../chart/helper/SymbolDraw';\nimport * as numberUtil from '../../util/number';\nimport SeriesData from '../../data/SeriesData';\nimport * as markerHelper from './markerHelper';\nimport MarkerView from './MarkerView';\nimport MarkerModel from './MarkerModel';\nimport { isFunction, map, filter, curry, extend } from 'zrender/lib/core/util';\nimport { getECData } from '../../util/innerStore';\nimport { getVisualFromData } from '../../visual/helper';\n\nfunction updateMarkerLayout(mpData, seriesModel, api) {\n  var coordSys = seriesModel.coordinateSystem;\n  mpData.each(function (idx) {\n    var itemModel = mpData.getItemModel(idx);\n    var point;\n    var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());\n    var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());\n\n    if (!isNaN(xPx) && !isNaN(yPx)) {\n      point = [xPx, yPx];\n    } // Chart like bar may have there own marker positioning logic\n    else if (seriesModel.getMarkerPosition) {\n        // Use the getMarkerPoisition\n        point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));\n      } else if (coordSys) {\n        var x = mpData.get(coordSys.dimensions[0], idx);\n        var y = mpData.get(coordSys.dimensions[1], idx);\n        point = coordSys.dataToPoint([x, y]);\n      } // Use x, y if has any\n\n\n    if (!isNaN(xPx)) {\n      point[0] = xPx;\n    }\n\n    if (!isNaN(yPx)) {\n      point[1] = yPx;\n    }\n\n    mpData.setItemLayout(idx, point);\n  });\n}\n\nvar MarkPointView =\n/** @class */\nfunction (_super) {\n  __extends(MarkPointView, _super);\n\n  function MarkPointView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = MarkPointView.type;\n    return _this;\n  }\n\n  MarkPointView.prototype.updateTransform = function (markPointModel, ecModel, api) {\n    ecModel.eachSeries(function (seriesModel) {\n      var mpModel = MarkerModel.getMarkerModelFromSeries(seriesModel, 'markPoint');\n\n      if (mpModel) {\n        updateMarkerLayout(mpModel.getData(), seriesModel, api);\n        this.markerGroupMap.get(seriesModel.id).updateLayout();\n      }\n    }, this);\n  };\n\n  MarkPointView.prototype.renderSeries = function (seriesModel, mpModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var seriesId = seriesModel.id;\n    var seriesData = seriesModel.getData();\n    var symbolDrawMap = this.markerGroupMap;\n    var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw());\n    var mpData = createData(coordSys, seriesModel, mpModel); // FIXME\n\n    mpModel.setData(mpData);\n    updateMarkerLayout(mpModel.getData(), seriesModel, api);\n    mpData.each(function (idx) {\n      var itemModel = mpData.getItemModel(idx);\n      var symbol = itemModel.getShallow('symbol');\n      var symbolSize = itemModel.getShallow('symbolSize');\n      var symbolRotate = itemModel.getShallow('symbolRotate');\n      var symbolOffset = itemModel.getShallow('symbolOffset');\n      var symbolKeepAspect = itemModel.getShallow('symbolKeepAspect'); // TODO: refactor needed: single data item should not support callback function\n\n      if (isFunction(symbol) || isFunction(symbolSize) || isFunction(symbolRotate) || isFunction(symbolOffset)) {\n        var rawIdx = mpModel.getRawValue(idx);\n        var dataParams = mpModel.getDataParams(idx);\n\n        if (isFunction(symbol)) {\n          symbol = symbol(rawIdx, dataParams);\n        }\n\n        if (isFunction(symbolSize)) {\n          // FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？\n          symbolSize = symbolSize(rawIdx, dataParams);\n        }\n\n        if (isFunction(symbolRotate)) {\n          symbolRotate = symbolRotate(rawIdx, dataParams);\n        }\n\n        if (isFunction(symbolOffset)) {\n          symbolOffset = symbolOffset(rawIdx, dataParams);\n        }\n      }\n\n      var style = itemModel.getModel('itemStyle').getItemStyle();\n      var color = getVisualFromData(seriesData, 'color');\n\n      if (!style.fill) {\n        style.fill = color;\n      }\n\n      mpData.setItemVisual(idx, {\n        symbol: symbol,\n        symbolSize: symbolSize,\n        symbolRotate: symbolRotate,\n        symbolOffset: symbolOffset,\n        symbolKeepAspect: symbolKeepAspect,\n        style: style\n      });\n    }); // TODO Text are wrong\n\n    symbolDraw.updateData(mpData);\n    this.group.add(symbolDraw.group); // Set host model for tooltip\n    // FIXME\n\n    mpData.eachItemGraphicEl(function (el) {\n      el.traverse(function (child) {\n        getECData(child).dataModel = mpModel;\n      });\n    });\n    this.markKeep(symbolDraw);\n    symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');\n  };\n\n  MarkPointView.type = 'markPoint';\n  return MarkPointView;\n}(MarkerView);\n\nfunction createData(coordSys, seriesModel, mpModel) {\n  var coordDimsInfos;\n\n  if (coordSys) {\n    coordDimsInfos = map(coordSys && coordSys.dimensions, function (coordDim) {\n      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys\n\n      return extend(extend({}, info), {\n        name: coordDim,\n        // DON'T use ordinalMeta to parse and collect ordinal.\n        ordinalMeta: null\n      });\n    });\n  } else {\n    coordDimsInfos = [{\n      name: 'value',\n      type: 'float'\n    }];\n  }\n\n  var mpData = new SeriesData(coordDimsInfos, mpModel);\n  var dataOpt = map(mpModel.get('data'), curry(markerHelper.dataTransform, seriesModel));\n\n  if (coordSys) {\n    dataOpt = filter(dataOpt, curry(markerHelper.dataFilter, coordSys));\n  }\n\n  mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function (item) {\n    return item.value;\n  });\n  return mpData;\n}\n\nexport default MarkPointView;"]},"metadata":{},"sourceType":"module"}