{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { VISUAL_DIMENSIONS } from '../../util/types';\nimport SeriesDimensionDefine from '../SeriesDimensionDefine';\nimport { createHashMap, defaults, each, extend, isObject, isString } from 'zrender/lib/core/util';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source';\nimport { CtorInt32Array } from '../DataStore';\nimport { normalizeToArray } from '../../util/model';\nimport { BE_ORDINAL, guessOrdinal } from './sourceHelper';\nimport { createDimNameMap, ensureSourceDimNameMap, SeriesDataSchema, shouldOmitUnusedDimensions } from './SeriesDataSchema';\n/**\n * For outside usage compat (like echarts-gl are using it).\n */\n\nexport function createDimensions(source, opt) {\n  return prepareSeriesDataSchema(source, opt).dimensions;\n}\n/**\n * This method builds the relationship between:\n * + \"what the coord sys or series requires (see `coordDimensions`)\",\n * + \"what the user defines (in `encode` and `dimensions`, see `opt.dimensionsDefine` and `opt.encodeDefine`)\"\n * + \"what the data source provids (see `source`)\".\n *\n * Some guess strategy will be adapted if user does not define something.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @return The results are always sorted by `storeDimIndex` asc.\n */\n\nexport default function prepareSeriesDataSchema( // TODO: TYPE completeDimensions type\nsource, opt) {\n  if (!isSourceInstance(source)) {\n    source = createSourceFromSeriesDataOption(source);\n  }\n\n  opt = opt || {};\n  var sysDims = opt.coordDimensions || [];\n  var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];\n  var coordDimNameMap = createHashMap();\n  var resultList = [];\n  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount); // Try to ignore unsed dimensions if sharing a high dimension datastore\n  // 30 is an experience value.\n\n  var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);\n  var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;\n  var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);\n  var encodeDef = opt.encodeDefine;\n\n  if (!encodeDef && opt.encodeDefaulter) {\n    encodeDef = opt.encodeDefaulter(source, dimCount);\n  }\n\n  var encodeDefMap = createHashMap(encodeDef);\n  var indicesMap = new CtorInt32Array(dimCount);\n\n  for (var i = 0; i < indicesMap.length; i++) {\n    indicesMap[i] = -1;\n  }\n\n  function getResultItem(dimIdx) {\n    var idx = indicesMap[dimIdx];\n\n    if (idx < 0) {\n      var dimDefItemRaw = dimsDef[dimIdx];\n      var dimDefItem = isObject(dimDefItemRaw) ? dimDefItemRaw : {\n        name: dimDefItemRaw\n      };\n      var resultItem = new SeriesDimensionDefine();\n      var userDimName = dimDefItem.name;\n\n      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {\n        // Only if `series.dimensions` is defined in option\n        // displayName, will be set, and dimension will be diplayed vertically in\n        // tooltip by default.\n        resultItem.name = resultItem.displayName = userDimName;\n      }\n\n      dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n      dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);\n      var newIdx = resultList.length;\n      indicesMap[dimIdx] = newIdx;\n      resultItem.storeDimIndex = dimIdx;\n      resultList.push(resultItem);\n      return resultItem;\n    }\n\n    return resultList[idx];\n  }\n\n  if (!omitUnusedDimensions) {\n    for (var i = 0; i < dimCount; i++) {\n      getResultItem(i);\n    }\n  } // Set `coordDim` and `coordDimIndex` by `encodeDefMap` and normalize `encodeDefMap`.\n\n\n  encodeDefMap.each(function (dataDimsRaw, coordDim) {\n    var dataDims = normalizeToArray(dataDimsRaw).slice(); // Note: It is allowed that `dataDims.length` is `0`, e.g., options is\n    // `{encode: {x: -1, y: 1}}`. Should not filter anything in\n    // this case.\n\n    if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {\n      encodeDefMap.set(coordDim, false);\n      return;\n    }\n\n    var validDataDims = encodeDefMap.set(coordDim, []);\n    each(dataDims, function (resultDimIdxOrName, idx) {\n      // The input resultDimIdx can be dim name or index.\n      var resultDimIdx = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;\n\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        validDataDims[idx] = resultDimIdx;\n        applyDim(getResultItem(resultDimIdx), coordDim, idx);\n      }\n    });\n  }); // Apply templetes and default order from `sysDims`.\n\n  var availDimIdx = 0;\n  each(sysDims, function (sysDimItemRaw) {\n    var coordDim;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n    var sysDimItem;\n\n    if (isString(sysDimItemRaw)) {\n      coordDim = sysDimItemRaw;\n      sysDimItem = {};\n    } else {\n      sysDimItem = sysDimItemRaw;\n      coordDim = sysDimItem.name;\n      var ordinalMeta = sysDimItem.ordinalMeta;\n      sysDimItem.ordinalMeta = null;\n      sysDimItem = extend({}, sysDimItem);\n      sysDimItem.ordinalMeta = ordinalMeta; // `coordDimIndex` should not be set directly.\n\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n\n    var dataDims = encodeDefMap.get(coordDim); // negative resultDimIdx means no need to mapping.\n\n    if (dataDims === false) {\n      return;\n    }\n\n    dataDims = normalizeToArray(dataDims); // dimensions provides default dim sequences.\n\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {\n          availDimIdx++;\n        }\n\n        availDimIdx < dimCount && dataDims.push(availDimIdx++);\n      }\n    } // Apply templates.\n\n\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = getResultItem(resultDimIdx); // Coordinate system has a higher priority on dim type than source.\n\n      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {\n        resultItem.type = sysDimItem.type;\n      }\n\n      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];\n        !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {\n          name: sysDimItemDimsDefItem\n        });\n        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;\n        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;\n      } // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}\n\n\n      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  });\n\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (VISUAL_DIMENSIONS.get(coordDim) != null) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  } // Make sure the first extra dim is 'value'.\n\n\n  var generateCoord = opt.generateCoord;\n  var generateCoordCount = opt.generateCoordCount;\n  var fromZero = generateCoordCount != null;\n  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;\n  var extra = generateCoord || 'value';\n\n  function ifNoNameFillWithCoordName(resultItem) {\n    if (resultItem.name == null) {\n      // Duplication will be removed in the next step.\n      resultItem.name = resultItem.coordDim;\n    }\n  } // Set dim `name` and other `coordDim` and other props.\n\n\n  if (!omitUnusedDimensions) {\n    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n      var resultItem = getResultItem(resultDimIdx);\n      var coordDim = resultItem.coordDim;\n\n      if (coordDim == null) {\n        // TODO no need to generate coordDim for isExtraCoord?\n        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);\n        resultItem.coordDimIndex = 0; // Series specified generateCoord is using out.\n\n        if (!generateCoord || generateCoordCount <= 0) {\n          resultItem.isExtraCoord = true;\n        }\n\n        generateCoordCount--;\n      }\n\n      ifNoNameFillWithCoordName(resultItem);\n\n      if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must // Consider the case:\n      // {\n      //    dataset: {source: [\n      //        ['2001', 123],\n      //        ['2002', 456],\n      //        ...\n      //        ['The others', 987],\n      //    ]},\n      //    series: {type: 'pie'}\n      // }\n      // The first colum should better be treated as a \"ordinal\" although it\n      // might not able to be detected as an \"ordinal\" by `guessOrdinal`.\n      || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {\n        resultItem.type = 'ordinal';\n      }\n    }\n  } else {\n    each(resultList, function (resultItem) {\n      // PENDING: guessOrdinal or let user specify type: 'ordinal' manually?\n      ifNoNameFillWithCoordName(resultItem);\n    }); // Sort dimensions: there are some rule that use the last dim as label,\n    // and for some latter travel process easier.\n\n    resultList.sort(function (item0, item1) {\n      return item0.storeDimIndex - item1.storeDimIndex;\n    });\n  }\n\n  removeDuplication(resultList);\n  return new SeriesDataSchema({\n    source: source,\n    dimensions: resultList,\n    fullDimensionCount: dimCount,\n    dimensionOmitted: omitUnusedDimensions\n  });\n}\n\nfunction removeDuplication(result) {\n  var duplicationMap = createHashMap();\n\n  for (var i = 0; i < result.length; i++) {\n    var dim = result[i];\n    var dimOriginalName = dim.name;\n    var count = duplicationMap.get(dimOriginalName) || 0;\n\n    if (count > 0) {\n      // Starts from 0.\n      dim.name = dimOriginalName + (count - 1);\n    }\n\n    count++;\n    duplicationMap.set(dimOriginalName, count);\n  }\n} // ??? TODO\n// Originally detect dimCount by data[0]. Should we\n// optimize it to only by sysDims and dimensions and encode.\n// So only necessary dims will be initialized.\n// But\n// (1) custom series should be considered. where other dims\n// may be visited.\n// (2) sometimes user need to calcualte bubble size or use visualMap\n// on other dimensions besides coordSys needed.\n// So, dims that is not used by system, should be shared in data store?\n\n\nfunction getDimCount(source, sysDims, dimsDef, optDimCount) {\n  // Note that the result dimCount should not small than columns count\n  // of data, otherwise `dataDimNameMap` checking will be incorrect.\n  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);\n  each(sysDims, function (sysDimItem) {\n    var sysDimItemDimsDef;\n\n    if (isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {\n      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);\n    }\n  });\n  return dimCount;\n}\n\nfunction genCoordDimName(name, map, fromZero) {\n  var mapData = map.data;\n\n  if (fromZero || mapData.hasOwnProperty(name)) {\n    var i = 0;\n\n    while (mapData.hasOwnProperty(name + i)) {\n      i++;\n    }\n\n    name += i;\n  }\n\n  map.set(name, true);\n  return name;\n}","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/data/helper/createDimensions.js"],"names":["VISUAL_DIMENSIONS","SeriesDimensionDefine","createHashMap","defaults","each","extend","isObject","isString","createSourceFromSeriesDataOption","isSourceInstance","CtorInt32Array","normalizeToArray","BE_ORDINAL","guessOrdinal","createDimNameMap","ensureSourceDimNameMap","SeriesDataSchema","shouldOmitUnusedDimensions","createDimensions","source","opt","prepareSeriesDataSchema","dimensions","sysDims","coordDimensions","dimsDef","dimensionsDefine","coordDimNameMap","resultList","dimCount","getDimCount","dimensionsCount","omitUnusedDimensions","canOmitUnusedDimensions","isUsingSourceDimensionsDef","dataDimNameMap","encodeDef","encodeDefine","encodeDefaulter","encodeDefMap","indicesMap","i","length","getResultItem","dimIdx","idx","dimDefItemRaw","dimDefItem","name","resultItem","userDimName","get","displayName","type","newIdx","storeDimIndex","push","dataDimsRaw","coordDim","dataDims","slice","set","validDataDims","resultDimIdxOrName","resultDimIdx","applyDim","availDimIdx","sysDimItemRaw","sysDimItemDimsDef","sysDimItemOtherDims","sysDimItem","ordinalMeta","otherDims","coordDimIndex","sysDimItemDimsDefItem","defaultTooltip","generateCoord","generateCoordCount","fromZero","extra","ifNoNameFillWithCoordName","genCoordDimName","isExtraCoord","Must","itemName","seriesName","sort","item0","item1","removeDuplication","fullDimensionCount","dimensionOmitted","result","duplicationMap","dim","dimOriginalName","count","optDimCount","Math","max","dimensionsDetectedCount","map","mapData","data","hasOwnProperty"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { VISUAL_DIMENSIONS } from '../../util/types';\nimport SeriesDimensionDefine from '../SeriesDimensionDefine';\nimport { createHashMap, defaults, each, extend, isObject, isString } from 'zrender/lib/core/util';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source';\nimport { CtorInt32Array } from '../DataStore';\nimport { normalizeToArray } from '../../util/model';\nimport { BE_ORDINAL, guessOrdinal } from './sourceHelper';\nimport { createDimNameMap, ensureSourceDimNameMap, SeriesDataSchema, shouldOmitUnusedDimensions } from './SeriesDataSchema';\n/**\n * For outside usage compat (like echarts-gl are using it).\n */\n\nexport function createDimensions(source, opt) {\n  return prepareSeriesDataSchema(source, opt).dimensions;\n}\n/**\n * This method builds the relationship between:\n * + \"what the coord sys or series requires (see `coordDimensions`)\",\n * + \"what the user defines (in `encode` and `dimensions`, see `opt.dimensionsDefine` and `opt.encodeDefine`)\"\n * + \"what the data source provids (see `source`)\".\n *\n * Some guess strategy will be adapted if user does not define something.\n * If no 'value' dimension specified, the first no-named dimension will be\n * named as 'value'.\n *\n * @return The results are always sorted by `storeDimIndex` asc.\n */\n\nexport default function prepareSeriesDataSchema( // TODO: TYPE completeDimensions type\nsource, opt) {\n  if (!isSourceInstance(source)) {\n    source = createSourceFromSeriesDataOption(source);\n  }\n\n  opt = opt || {};\n  var sysDims = opt.coordDimensions || [];\n  var dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];\n  var coordDimNameMap = createHashMap();\n  var resultList = [];\n  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount); // Try to ignore unsed dimensions if sharing a high dimension datastore\n  // 30 is an experience value.\n\n  var omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);\n  var isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;\n  var dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);\n  var encodeDef = opt.encodeDefine;\n\n  if (!encodeDef && opt.encodeDefaulter) {\n    encodeDef = opt.encodeDefaulter(source, dimCount);\n  }\n\n  var encodeDefMap = createHashMap(encodeDef);\n  var indicesMap = new CtorInt32Array(dimCount);\n\n  for (var i = 0; i < indicesMap.length; i++) {\n    indicesMap[i] = -1;\n  }\n\n  function getResultItem(dimIdx) {\n    var idx = indicesMap[dimIdx];\n\n    if (idx < 0) {\n      var dimDefItemRaw = dimsDef[dimIdx];\n      var dimDefItem = isObject(dimDefItemRaw) ? dimDefItemRaw : {\n        name: dimDefItemRaw\n      };\n      var resultItem = new SeriesDimensionDefine();\n      var userDimName = dimDefItem.name;\n\n      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {\n        // Only if `series.dimensions` is defined in option\n        // displayName, will be set, and dimension will be diplayed vertically in\n        // tooltip by default.\n        resultItem.name = resultItem.displayName = userDimName;\n      }\n\n      dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n      dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);\n      var newIdx = resultList.length;\n      indicesMap[dimIdx] = newIdx;\n      resultItem.storeDimIndex = dimIdx;\n      resultList.push(resultItem);\n      return resultItem;\n    }\n\n    return resultList[idx];\n  }\n\n  if (!omitUnusedDimensions) {\n    for (var i = 0; i < dimCount; i++) {\n      getResultItem(i);\n    }\n  } // Set `coordDim` and `coordDimIndex` by `encodeDefMap` and normalize `encodeDefMap`.\n\n\n  encodeDefMap.each(function (dataDimsRaw, coordDim) {\n    var dataDims = normalizeToArray(dataDimsRaw).slice(); // Note: It is allowed that `dataDims.length` is `0`, e.g., options is\n    // `{encode: {x: -1, y: 1}}`. Should not filter anything in\n    // this case.\n\n    if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {\n      encodeDefMap.set(coordDim, false);\n      return;\n    }\n\n    var validDataDims = encodeDefMap.set(coordDim, []);\n    each(dataDims, function (resultDimIdxOrName, idx) {\n      // The input resultDimIdx can be dim name or index.\n      var resultDimIdx = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;\n\n      if (resultDimIdx != null && resultDimIdx < dimCount) {\n        validDataDims[idx] = resultDimIdx;\n        applyDim(getResultItem(resultDimIdx), coordDim, idx);\n      }\n    });\n  }); // Apply templetes and default order from `sysDims`.\n\n  var availDimIdx = 0;\n  each(sysDims, function (sysDimItemRaw) {\n    var coordDim;\n    var sysDimItemDimsDef;\n    var sysDimItemOtherDims;\n    var sysDimItem;\n\n    if (isString(sysDimItemRaw)) {\n      coordDim = sysDimItemRaw;\n      sysDimItem = {};\n    } else {\n      sysDimItem = sysDimItemRaw;\n      coordDim = sysDimItem.name;\n      var ordinalMeta = sysDimItem.ordinalMeta;\n      sysDimItem.ordinalMeta = null;\n      sysDimItem = extend({}, sysDimItem);\n      sysDimItem.ordinalMeta = ordinalMeta; // `coordDimIndex` should not be set directly.\n\n      sysDimItemDimsDef = sysDimItem.dimsDef;\n      sysDimItemOtherDims = sysDimItem.otherDims;\n      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n    }\n\n    var dataDims = encodeDefMap.get(coordDim); // negative resultDimIdx means no need to mapping.\n\n    if (dataDims === false) {\n      return;\n    }\n\n    dataDims = normalizeToArray(dataDims); // dimensions provides default dim sequences.\n\n    if (!dataDims.length) {\n      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {\n          availDimIdx++;\n        }\n\n        availDimIdx < dimCount && dataDims.push(availDimIdx++);\n      }\n    } // Apply templates.\n\n\n    each(dataDims, function (resultDimIdx, coordDimIndex) {\n      var resultItem = getResultItem(resultDimIdx); // Coordinate system has a higher priority on dim type than source.\n\n      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {\n        resultItem.type = sysDimItem.type;\n      }\n\n      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n\n      if (resultItem.name == null && sysDimItemDimsDef) {\n        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];\n        !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {\n          name: sysDimItemDimsDefItem\n        });\n        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;\n        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;\n      } // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}\n\n\n      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n    });\n  });\n\n  function applyDim(resultItem, coordDim, coordDimIndex) {\n    if (VISUAL_DIMENSIONS.get(coordDim) != null) {\n      resultItem.otherDims[coordDim] = coordDimIndex;\n    } else {\n      resultItem.coordDim = coordDim;\n      resultItem.coordDimIndex = coordDimIndex;\n      coordDimNameMap.set(coordDim, true);\n    }\n  } // Make sure the first extra dim is 'value'.\n\n\n  var generateCoord = opt.generateCoord;\n  var generateCoordCount = opt.generateCoordCount;\n  var fromZero = generateCoordCount != null;\n  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;\n  var extra = generateCoord || 'value';\n\n  function ifNoNameFillWithCoordName(resultItem) {\n    if (resultItem.name == null) {\n      // Duplication will be removed in the next step.\n      resultItem.name = resultItem.coordDim;\n    }\n  } // Set dim `name` and other `coordDim` and other props.\n\n\n  if (!omitUnusedDimensions) {\n    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n      var resultItem = getResultItem(resultDimIdx);\n      var coordDim = resultItem.coordDim;\n\n      if (coordDim == null) {\n        // TODO no need to generate coordDim for isExtraCoord?\n        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);\n        resultItem.coordDimIndex = 0; // Series specified generateCoord is using out.\n\n        if (!generateCoord || generateCoordCount <= 0) {\n          resultItem.isExtraCoord = true;\n        }\n\n        generateCoordCount--;\n      }\n\n      ifNoNameFillWithCoordName(resultItem);\n\n      if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must // Consider the case:\n      // {\n      //    dataset: {source: [\n      //        ['2001', 123],\n      //        ['2002', 456],\n      //        ...\n      //        ['The others', 987],\n      //    ]},\n      //    series: {type: 'pie'}\n      // }\n      // The first colum should better be treated as a \"ordinal\" although it\n      // might not able to be detected as an \"ordinal\" by `guessOrdinal`.\n      || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {\n        resultItem.type = 'ordinal';\n      }\n    }\n  } else {\n    each(resultList, function (resultItem) {\n      // PENDING: guessOrdinal or let user specify type: 'ordinal' manually?\n      ifNoNameFillWithCoordName(resultItem);\n    }); // Sort dimensions: there are some rule that use the last dim as label,\n    // and for some latter travel process easier.\n\n    resultList.sort(function (item0, item1) {\n      return item0.storeDimIndex - item1.storeDimIndex;\n    });\n  }\n\n  removeDuplication(resultList);\n  return new SeriesDataSchema({\n    source: source,\n    dimensions: resultList,\n    fullDimensionCount: dimCount,\n    dimensionOmitted: omitUnusedDimensions\n  });\n}\n\nfunction removeDuplication(result) {\n  var duplicationMap = createHashMap();\n\n  for (var i = 0; i < result.length; i++) {\n    var dim = result[i];\n    var dimOriginalName = dim.name;\n    var count = duplicationMap.get(dimOriginalName) || 0;\n\n    if (count > 0) {\n      // Starts from 0.\n      dim.name = dimOriginalName + (count - 1);\n    }\n\n    count++;\n    duplicationMap.set(dimOriginalName, count);\n  }\n} // ??? TODO\n// Originally detect dimCount by data[0]. Should we\n// optimize it to only by sysDims and dimensions and encode.\n// So only necessary dims will be initialized.\n// But\n// (1) custom series should be considered. where other dims\n// may be visited.\n// (2) sometimes user need to calcualte bubble size or use visualMap\n// on other dimensions besides coordSys needed.\n// So, dims that is not used by system, should be shared in data store?\n\n\nfunction getDimCount(source, sysDims, dimsDef, optDimCount) {\n  // Note that the result dimCount should not small than columns count\n  // of data, otherwise `dataDimNameMap` checking will be incorrect.\n  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);\n  each(sysDims, function (sysDimItem) {\n    var sysDimItemDimsDef;\n\n    if (isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {\n      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);\n    }\n  });\n  return dimCount;\n}\n\nfunction genCoordDimName(name, map, fromZero) {\n  var mapData = map.data;\n\n  if (fromZero || mapData.hasOwnProperty(name)) {\n    var i = 0;\n\n    while (mapData.hasOwnProperty(name + i)) {\n      i++;\n    }\n\n    name += i;\n  }\n\n  map.set(name, true);\n  return name;\n}"]},"metadata":{},"sourceType":"module"}