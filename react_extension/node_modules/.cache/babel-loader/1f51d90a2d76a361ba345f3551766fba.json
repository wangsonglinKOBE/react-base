{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, isObject, isArray, createHashMap, map, assert, isString, indexOf, isStringSafe } from 'zrender/lib/core/util';\nimport env from 'zrender/lib/core/env';\nimport { isNumeric, getRandomIdBase, getPrecision, round } from './number';\nimport { interpolateNumber } from 'zrender/lib/animation/Animator';\nimport { warn } from './log';\n/**\n * Make the name displayable. But we should\n * make sure it is not duplicated with user\n * specified name, so use '\\0';\n */\n\nvar DUMMY_COMPONENT_NAME_PREFIX = 'series\\0';\nvar INTERNAL_COMPONENT_ID_PREFIX = '\\0_ec_\\0';\n/**\n * If value is not array, then translate it to array.\n * @param  {*} value\n * @return {Array} [value] or value\n */\n\nexport function normalizeToArray(value) {\n  return value instanceof Array ? value : value == null ? [] : [value];\n}\n/**\n * Sync default option between normal and emphasis like `position` and `show`\n * In case some one will write code like\n *     label: {\n *          show: false,\n *          position: 'outside',\n *          fontSize: 18\n *     },\n *     emphasis: {\n *          label: { show: true }\n *     }\n */\n\nexport function defaultEmphasis(opt, key, subOpts) {\n  // Caution: performance sensitive.\n  if (opt) {\n    opt[key] = opt[key] || {};\n    opt.emphasis = opt.emphasis || {};\n    opt.emphasis[key] = opt.emphasis[key] || {}; // Default emphasis option from normal\n\n    for (var i = 0, len = subOpts.length; i < len; i++) {\n      var subOptName = subOpts[i];\n\n      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {\n        opt.emphasis[key][subOptName] = opt[key][subOptName];\n      }\n    }\n  }\n}\nexport var TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([\n//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',\n//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n//     // FIXME: deprecated, check and remove it.\n//     'textStyle'\n// ]);\n\n/**\n * The method do not ensure performance.\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method retieves value from data.\n */\n\nexport function getDataItemValue(dataItem) {\n  return isObject(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;\n}\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method determine if dataItem has extra option besides value\n */\n\nexport function isDataItemOption(dataItem) {\n  return isObject(dataItem) && !(dataItem instanceof Array); // // markLine data can be array\n  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n}\n;\n/**\n * Mapping to existings for merge.\n *\n * Mode \"normalMege\":\n *     The mapping result (merge result) will keep the order of the existing\n *     component, rather than the order of new option. Because we should ensure\n *     some specified index reference (like xAxisIndex) keep work.\n *     And in most cases, \"merge option\" is used to update partial option but not\n *     be expected to change the order.\n *\n * Mode \"replaceMege\":\n *     (1) Only the id mapped components will be merged.\n *     (2) Other existing components (except internal compoonets) will be removed.\n *     (3) Other new options will be used to create new component.\n *     (4) The index of the existing compoents will not be modified.\n *     That means their might be \"hole\" after the removal.\n *     The new components are created first at those available index.\n *\n * Mode \"replaceAll\":\n *     This mode try to support that reproduce an echarts instance from another\n *     echarts instance (via `getOption`) in some simple cases.\n *     In this senario, the `result` index are exactly the consistent with the `newCmptOptions`,\n *     which ensures the compoennt index referring (like `xAxisIndex: ?`) corrent. That is,\n *     the \"hole\" in `newCmptOptions` will also be kept.\n *     On the contrary, other modes try best to eliminate holes.\n *     PENDING: This is an experimental mode yet.\n *\n * @return See the comment of <MappingResult>.\n */\n\nexport function mappingToExists(existings, newCmptOptions, mode) {\n  var isNormalMergeMode = mode === 'normalMerge';\n  var isReplaceMergeMode = mode === 'replaceMerge';\n  var isReplaceAllMode = mode === 'replaceAll';\n  existings = existings || [];\n  newCmptOptions = (newCmptOptions || []).slice();\n  var existingIdIdxMap = createHashMap(); // Validate id and name on user input option.\n\n  each(newCmptOptions, function (cmptOption, index) {\n    if (!isObject(cmptOption)) {\n      newCmptOptions[index] = null;\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // There is some legacy case that name is set as `false`.\n      // But should work normally rather than throw error.\n      if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {\n        warnInvalidateIdOrName(cmptOption.id);\n      }\n\n      if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {\n        warnInvalidateIdOrName(cmptOption.name);\n      }\n    }\n  });\n  var result = prepareResult(existings, existingIdIdxMap, mode);\n\n  if (isNormalMergeMode || isReplaceMergeMode) {\n    mappingById(result, existings, existingIdIdxMap, newCmptOptions);\n  }\n\n  if (isNormalMergeMode) {\n    mappingByName(result, newCmptOptions);\n  }\n\n  if (isNormalMergeMode || isReplaceMergeMode) {\n    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);\n  } else if (isReplaceAllMode) {\n    mappingInReplaceAllMode(result, newCmptOptions);\n  }\n\n  makeIdAndName(result); // The array `result` MUST NOT contain elided items, otherwise the\n  // forEach will ommit those items and result in incorrect result.\n\n  return result;\n}\n\nfunction prepareResult(existings, existingIdIdxMap, mode) {\n  var result = [];\n\n  if (mode === 'replaceAll') {\n    return result;\n  } // Do not use native `map` to in case that the array `existings`\n  // contains elided items, which will be ommited.\n\n\n  for (var index = 0; index < existings.length; index++) {\n    var existing = existings[index]; // Because of replaceMerge, `existing` may be null/undefined.\n\n    if (existing && existing.id != null) {\n      existingIdIdxMap.set(existing.id, index);\n    } // For non-internal-componnets:\n    //     Mode \"normalMerge\": all existings kept.\n    //     Mode \"replaceMerge\": all existing removed unless mapped by id.\n    // For internal-components:\n    //     go with \"replaceMerge\" approach in both mode.\n\n\n    result.push({\n      existing: mode === 'replaceMerge' || isComponentIdInternal(existing) ? null : existing,\n      newOption: null,\n      keyInfo: null,\n      brandNew: null\n    });\n  }\n\n  return result;\n}\n\nfunction mappingById(result, existings, existingIdIdxMap, newCmptOptions) {\n  // Mapping by id if specified.\n  each(newCmptOptions, function (cmptOption, index) {\n    if (!cmptOption || cmptOption.id == null) {\n      return;\n    }\n\n    var optionId = makeComparableKey(cmptOption.id);\n    var existingIdx = existingIdIdxMap.get(optionId);\n\n    if (existingIdx != null) {\n      var resultItem = result[existingIdx];\n      assert(!resultItem.newOption, 'Duplicated option on id \"' + optionId + '\".');\n      resultItem.newOption = cmptOption; // In both mode, if id matched, new option will be merged to\n      // the existings rather than creating new component model.\n\n      resultItem.existing = existings[existingIdx];\n      newCmptOptions[index] = null;\n    }\n  });\n}\n\nfunction mappingByName(result, newCmptOptions) {\n  // Mapping by name if specified.\n  each(newCmptOptions, function (cmptOption, index) {\n    if (!cmptOption || cmptOption.name == null) {\n      return;\n    }\n\n    for (var i = 0; i < result.length; i++) {\n      var existing = result[i].existing;\n\n      if (!result[i].newOption // Consider name: two map to one.\n      // Can not match when both ids existing but different.\n      && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual('name', existing, cmptOption)) {\n        result[i].newOption = cmptOption;\n        newCmptOptions[index] = null;\n        return;\n      }\n    }\n  });\n}\n\nfunction mappingByIndex(result, newCmptOptions, brandNew) {\n  each(newCmptOptions, function (cmptOption) {\n    if (!cmptOption) {\n      return;\n    } // Find the first place that not mapped by id and not internal component (consider the \"hole\").\n\n\n    var resultItem;\n    var nextIdx = 0;\n\n    while ( // Be `!resultItem` only when `nextIdx >= result.length`.\n    (resultItem = result[nextIdx]) && ( // (1) Existing models that already have id should be able to mapped to. Because\n    // after mapping performed, model will always be assigned with an id if user not given.\n    // After that all models have id.\n    // (2) If new option has id, it can only set to a hole or append to the last. It should\n    // not be merged to the existings with different id. Because id should not be overwritten.\n    // (3) Name can be overwritten, because axis use name as 'show label text'.\n    resultItem.newOption || isComponentIdInternal(resultItem.existing) || // In mode \"replaceMerge\", here no not-mapped-non-internal-existing.\n    resultItem.existing && cmptOption.id != null && !keyExistAndEqual('id', cmptOption, resultItem.existing))) {\n      nextIdx++;\n    }\n\n    if (resultItem) {\n      resultItem.newOption = cmptOption;\n      resultItem.brandNew = brandNew;\n    } else {\n      result.push({\n        newOption: cmptOption,\n        brandNew: brandNew,\n        existing: null,\n        keyInfo: null\n      });\n    }\n\n    nextIdx++;\n  });\n}\n\nfunction mappingInReplaceAllMode(result, newCmptOptions) {\n  each(newCmptOptions, function (cmptOption) {\n    // The feature \"reproduce\" requires \"hole\" will also reproduced\n    // in case that compoennt index referring are broken.\n    result.push({\n      newOption: cmptOption,\n      brandNew: true,\n      existing: null,\n      keyInfo: null\n    });\n  });\n}\n/**\n * Make id and name for mapping result (result of mappingToExists)\n * into `keyInfo` field.\n */\n\n\nfunction makeIdAndName(mapResult) {\n  // We use this id to hash component models and view instances\n  // in echarts. id can be specified by user, or auto generated.\n  // The id generation rule ensures new view instance are able\n  // to mapped to old instance when setOption are called in\n  // no-merge mode. So we generate model id by name and plus\n  // type in view id.\n  // name can be duplicated among components, which is convenient\n  // to specify multi components (like series) by one name.\n  // Ensure that each id is distinct.\n  var idMap = createHashMap();\n  each(mapResult, function (item) {\n    var existing = item.existing;\n    existing && idMap.set(existing.id, item);\n  });\n  each(mapResult, function (item) {\n    var opt = item.newOption; // Force ensure id not duplicated.\n\n    assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));\n    opt && opt.id != null && idMap.set(opt.id, item);\n    !item.keyInfo && (item.keyInfo = {});\n  }); // Make name and id.\n\n  each(mapResult, function (item, index) {\n    var existing = item.existing;\n    var opt = item.newOption;\n    var keyInfo = item.keyInfo;\n\n    if (!isObject(opt)) {\n      return;\n    } // name can be overwitten. Consider case: axis.name = '20km'.\n    // But id generated by name will not be changed, which affect\n    // only in that case: setOption with 'not merge mode' and view\n    // instance will be recreated, which can be accepted.\n\n\n    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name // Avoid diffferent series has the same name,\n    // because name may be used like in color pallet.\n    : DUMMY_COMPONENT_NAME_PREFIX + index;\n\n    if (existing) {\n      keyInfo.id = makeComparableKey(existing.id);\n    } else if (opt.id != null) {\n      keyInfo.id = makeComparableKey(opt.id);\n    } else {\n      // Consider this situatoin:\n      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n      //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n      // Series with the same name between optionA and optionB\n      // should be mapped.\n      var idNum = 0;\n\n      do {\n        keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n      } while (idMap.get(keyInfo.id));\n    }\n\n    idMap.set(keyInfo.id, item);\n  });\n}\n\nfunction keyExistAndEqual(attr, obj1, obj2) {\n  var key1 = convertOptionIdName(obj1[attr], null);\n  var key2 = convertOptionIdName(obj2[attr], null); // See `MappingExistingItem`. `id` and `name` trade string equals to number.\n\n  return key1 != null && key2 != null && key1 === key2;\n}\n/**\n * @return return null if not exist.\n */\n\n\nfunction makeComparableKey(val) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (val == null) {\n      throw new Error();\n    }\n  }\n\n  return convertOptionIdName(val, '');\n}\n\nexport function convertOptionIdName(idOrName, defaultValue) {\n  if (idOrName == null) {\n    return defaultValue;\n  }\n\n  var type = typeof idOrName;\n  return type === 'string' ? idOrName : type === 'number' || isStringSafe(idOrName) ? idOrName + '' : defaultValue;\n}\n\nfunction warnInvalidateIdOrName(idOrName) {\n  if (process.env.NODE_ENV !== 'production') {\n    warn('`' + idOrName + '` is invalid id or name. Must be a string or number.');\n  }\n}\n\nfunction isValidIdOrName(idOrName) {\n  return isStringSafe(idOrName) || isNumeric(idOrName);\n}\n\nexport function isNameSpecified(componentModel) {\n  var name = componentModel.name; // Is specified when `indexOf` get -1 or > 0.\n\n  return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));\n}\n/**\n * @public\n * @param {Object} cmptOption\n * @return {boolean}\n */\n\nexport function isComponentIdInternal(cmptOption) {\n  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;\n}\nexport function makeInternalComponentId(idSuffix) {\n  return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;\n}\nexport function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {\n  // Set mainType and complete subType.\n  each(mappingResult, function (item) {\n    var newOption = item.newOption;\n\n    if (isObject(newOption)) {\n      item.keyInfo.mainType = mainType;\n      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);\n    }\n  });\n}\n\nfunction determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {\n  var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\n  : componentModelCtor.determineSubType(mainType, newCmptOption); // tooltip, markline, markpoint may always has no subType\n\n  return subType;\n}\n/**\n * A helper for removing duplicate items between batchA and batchB,\n * and in themselves, and categorize by series.\n *\n * @param batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @param batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @return result: [resultBatchA, resultBatchB]\n */\n\n\nexport function compressBatches(batchA, batchB) {\n  var mapA = {};\n  var mapB = {};\n  makeMap(batchA || [], mapA);\n  makeMap(batchB || [], mapB, mapA);\n  return [mapToArray(mapA), mapToArray(mapB)];\n\n  function makeMap(sourceBatch, map, otherMap) {\n    for (var i = 0, len = sourceBatch.length; i < len; i++) {\n      var seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);\n\n      if (seriesId == null) {\n        return;\n      }\n\n      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);\n      var otherDataIndices = otherMap && otherMap[seriesId];\n\n      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n        var dataIndex = dataIndices[j];\n\n        if (otherDataIndices && otherDataIndices[dataIndex]) {\n          otherDataIndices[dataIndex] = null;\n        } else {\n          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n        }\n      }\n    }\n  }\n\n  function mapToArray(map, isData) {\n    var result = [];\n\n    for (var i in map) {\n      if (map.hasOwnProperty(i) && map[i] != null) {\n        if (isData) {\n          result.push(+i);\n        } else {\n          var dataIndices = mapToArray(map[i], true);\n          dataIndices.length && result.push({\n            seriesId: i,\n            dataIndex: dataIndices\n          });\n        }\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * @param payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n *                         each of which can be Array or primary type.\n * @return dataIndex If not found, return undefined/null.\n */\n\nexport function queryDataIndex(data, payload) {\n  if (payload.dataIndexInside != null) {\n    return payload.dataIndexInside;\n  } else if (payload.dataIndex != null) {\n    return isArray(payload.dataIndex) ? map(payload.dataIndex, function (value) {\n      return data.indexOfRawIndex(value);\n    }) : data.indexOfRawIndex(payload.dataIndex);\n  } else if (payload.name != null) {\n    return isArray(payload.name) ? map(payload.name, function (value) {\n      return data.indexOfName(value);\n    }) : data.indexOfName(payload.name);\n  }\n}\n/**\n * Enable property storage to any host object.\n * Notice: Serialization is not supported.\n *\n * For example:\n * let inner = zrUitl.makeInner();\n *\n * function some1(hostObj) {\n *      inner(hostObj).someProperty = 1212;\n *      ...\n * }\n * function some2() {\n *      let fields = inner(this);\n *      fields.someProperty1 = 1212;\n *      fields.someProperty2 = 'xx';\n *      ...\n * }\n *\n * @return {Function}\n */\n\nexport function makeInner() {\n  var key = '__ec_inner_' + innerUniqueIndex++;\n  return function (hostObj) {\n    return hostObj[key] || (hostObj[key] = {});\n  };\n}\nvar innerUniqueIndex = getRandomIdBase();\n/**\n * The same behavior as `component.getReferringComponents`.\n */\n\nexport function parseFinder(ecModel, finderInput, opt) {\n  var _a = preParseFinder(finderInput, opt),\n      mainTypeSpecified = _a.mainTypeSpecified,\n      queryOptionMap = _a.queryOptionMap,\n      others = _a.others;\n\n  var result = others;\n  var defaultMainType = opt ? opt.defaultMainType : null;\n\n  if (!mainTypeSpecified && defaultMainType) {\n    queryOptionMap.set(defaultMainType, {});\n  }\n\n  queryOptionMap.each(function (queryOption, mainType) {\n    var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {\n      useDefault: defaultMainType === mainType,\n      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,\n      enableNone: opt && opt.enableNone != null ? opt.enableNone : true\n    });\n    result[mainType + 'Models'] = queryResult.models;\n    result[mainType + 'Model'] = queryResult.models[0];\n  });\n  return result;\n}\nexport function preParseFinder(finderInput, opt) {\n  var finder;\n\n  if (isString(finderInput)) {\n    var obj = {};\n    obj[finderInput + 'Index'] = 0;\n    finder = obj;\n  } else {\n    finder = finderInput;\n  }\n\n  var queryOptionMap = createHashMap();\n  var others = {};\n  var mainTypeSpecified = false;\n  each(finder, function (value, key) {\n    // Exclude 'dataIndex' and other illgal keys.\n    if (key === 'dataIndex' || key === 'dataIndexInside') {\n      others[key] = value;\n      return;\n    }\n\n    var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n    var mainType = parsedKey[1];\n    var queryType = (parsedKey[2] || '').toLowerCase();\n\n    if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {\n      return;\n    }\n\n    mainTypeSpecified = mainTypeSpecified || !!mainType;\n    var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});\n    queryOption[queryType] = value;\n  });\n  return {\n    mainTypeSpecified: mainTypeSpecified,\n    queryOptionMap: queryOptionMap,\n    others: others\n  };\n}\nexport var SINGLE_REFERRING = {\n  useDefault: true,\n  enableAll: false,\n  enableNone: false\n};\nexport var MULTIPLE_REFERRING = {\n  useDefault: false,\n  enableAll: true,\n  enableNone: true\n};\nexport function queryReferringComponents(ecModel, mainType, userOption, opt) {\n  opt = opt || SINGLE_REFERRING;\n  var indexOption = userOption.index;\n  var idOption = userOption.id;\n  var nameOption = userOption.name;\n  var result = {\n    models: null,\n    specified: indexOption != null || idOption != null || nameOption != null\n  };\n\n  if (!result.specified) {\n    // Use the first as default if `useDefault`.\n    var firstCmpt = void 0;\n    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];\n    return result;\n  }\n\n  if (indexOption === 'none' || indexOption === false) {\n    assert(opt.enableNone, '`\"none\"` or `false` is not a valid value on index option.');\n    result.models = [];\n    return result;\n  } // `queryComponents` will return all components if\n  // both all of index/id/name are null/undefined.\n\n\n  if (indexOption === 'all') {\n    assert(opt.enableAll, '`\"all\"` is not a valid value on index option.');\n    indexOption = idOption = nameOption = null;\n  }\n\n  result.models = ecModel.queryComponents({\n    mainType: mainType,\n    index: indexOption,\n    id: idOption,\n    name: nameOption\n  });\n  return result;\n}\nexport function setAttribute(dom, key, value) {\n  dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;\n}\nexport function getAttribute(dom, key) {\n  return dom.getAttribute ? dom.getAttribute(key) : dom[key];\n}\nexport function getTooltipRenderMode(renderModeOption) {\n  if (renderModeOption === 'auto') {\n    // Using html when `document` exists, use richText otherwise\n    return env.domSupported ? 'html' : 'richText';\n  } else {\n    return renderModeOption || 'html';\n  }\n}\n/**\n * Group a list by key.\n */\n\nexport function groupData(array, getKey // return key\n) {\n  var buckets = createHashMap();\n  var keys = [];\n  each(array, function (item) {\n    var key = getKey(item);\n    (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item);\n  });\n  return {\n    keys: keys,\n    buckets: buckets\n  };\n}\n/**\n * Interpolate raw values of a series with percent\n *\n * @param data         data\n * @param labelModel   label model of the text element\n * @param sourceValue  start value. May be null/undefined when init.\n * @param targetValue  end value\n * @param percent      0~1 percentage; 0 uses start value while 1 uses end value\n * @return             interpolated values\n *                     If `sourceValue` and `targetValue` are `number`, return `number`.\n *                     If `sourceValue` and `targetValue` are `string`, return `string`.\n *                     If `sourceValue` and `targetValue` are `(string | number)[]`, return `(string | number)[]`.\n *                     Other cases do not supported.\n */\n\nexport function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {\n  var isAutoPrecision = precision == null || precision === 'auto';\n\n  if (targetValue == null) {\n    return targetValue;\n  }\n\n  if (typeof targetValue === 'number') {\n    var value = interpolateNumber(sourceValue || 0, targetValue, percent);\n    return round(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);\n  } else if (typeof targetValue === 'string') {\n    return percent < 1 ? sourceValue : targetValue;\n  } else {\n    var interpolated = [];\n    var leftArr = sourceValue;\n    var rightArr = targetValue;\n    var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);\n\n    for (var i = 0; i < length_1; ++i) {\n      var info = data.getDimensionInfo(i); // Don't interpolate ordinal dims\n\n      if (info && info.type === 'ordinal') {\n        // In init, there is no `sourceValue`, but should better not to get undefined result.\n        interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];\n      } else {\n        var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;\n        var rightVal = rightArr[i];\n        var value = interpolateNumber(leftVal, rightVal, percent);\n        interpolated[i] = round(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);\n      }\n    }\n\n    return interpolated;\n  }\n}","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/util/model.js"],"names":["each","isObject","isArray","createHashMap","map","assert","isString","indexOf","isStringSafe","env","isNumeric","getRandomIdBase","getPrecision","round","interpolateNumber","warn","DUMMY_COMPONENT_NAME_PREFIX","INTERNAL_COMPONENT_ID_PREFIX","normalizeToArray","value","Array","defaultEmphasis","opt","key","subOpts","emphasis","i","len","length","subOptName","hasOwnProperty","TEXT_STYLE_OPTIONS","getDataItemValue","dataItem","Date","isDataItemOption","mappingToExists","existings","newCmptOptions","mode","isNormalMergeMode","isReplaceMergeMode","isReplaceAllMode","slice","existingIdIdxMap","cmptOption","index","process","NODE_ENV","id","isValidIdOrName","warnInvalidateIdOrName","name","result","prepareResult","mappingById","mappingByName","mappingByIndex","mappingInReplaceAllMode","makeIdAndName","existing","set","push","isComponentIdInternal","newOption","keyInfo","brandNew","optionId","makeComparableKey","existingIdx","get","resultItem","keyExistAndEqual","nextIdx","mapResult","idMap","item","idNum","attr","obj1","obj2","key1","convertOptionIdName","key2","val","Error","idOrName","defaultValue","type","isNameSpecified","componentModel","makeInternalComponentId","idSuffix","setComponentTypeToKeyInfo","mappingResult","mainType","componentModelCtor","subType","determineSubType","newCmptOption","existComponent","compressBatches","batchA","batchB","mapA","mapB","makeMap","mapToArray","sourceBatch","otherMap","seriesId","dataIndices","dataIndex","otherDataIndices","j","lenj","isData","queryDataIndex","data","payload","dataIndexInside","indexOfRawIndex","indexOfName","makeInner","innerUniqueIndex","hostObj","parseFinder","ecModel","finderInput","_a","preParseFinder","mainTypeSpecified","queryOptionMap","others","defaultMainType","queryOption","queryResult","queryReferringComponents","useDefault","enableAll","enableNone","models","finder","obj","parsedKey","match","queryType","toLowerCase","includeMainTypes","SINGLE_REFERRING","MULTIPLE_REFERRING","userOption","indexOption","idOption","nameOption","specified","firstCmpt","getComponent","queryComponents","setAttribute","dom","getAttribute","getTooltipRenderMode","renderModeOption","domSupported","groupData","array","getKey","buckets","keys","interpolateRawValues","precision","sourceValue","targetValue","percent","isAutoPrecision","Math","max","interpolated","leftArr","rightArr","length_1","info","getDimensionInfo","leftVal","rightVal"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,IAAT,EAAeC,QAAf,EAAyBC,OAAzB,EAAkCC,aAAlC,EAAiDC,GAAjD,EAAsDC,MAAtD,EAA8DC,QAA9D,EAAwEC,OAAxE,EAAiFC,YAAjF,QAAqG,uBAArG;AACA,OAAOC,GAAP,MAAgB,sBAAhB;AACA,SAASC,SAAT,EAAoBC,eAApB,EAAqCC,YAArC,EAAmDC,KAAnD,QAAgE,UAAhE;AACA,SAASC,iBAAT,QAAkC,gCAAlC;AACA,SAASC,IAAT,QAAqB,OAArB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,2BAA2B,GAAG,UAAlC;AACA,IAAIC,4BAA4B,GAAG,UAAnC;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,gBAAT,CAA0BC,KAA1B,EAAiC;AACtC,SAAOA,KAAK,YAAYC,KAAjB,GAAyBD,KAAzB,GAAiCA,KAAK,IAAI,IAAT,GAAgB,EAAhB,GAAqB,CAACA,KAAD,CAA7D;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASE,eAAT,CAAyBC,GAAzB,EAA8BC,GAA9B,EAAmCC,OAAnC,EAA4C;AACjD;AACA,MAAIF,GAAJ,EAAS;AACPA,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAWD,GAAG,CAACC,GAAD,CAAH,IAAY,EAAvB;AACAD,IAAAA,GAAG,CAACG,QAAJ,GAAeH,GAAG,CAACG,QAAJ,IAAgB,EAA/B;AACAH,IAAAA,GAAG,CAACG,QAAJ,CAAaF,GAAb,IAAoBD,GAAG,CAACG,QAAJ,CAAaF,GAAb,KAAqB,EAAzC,CAHO,CAGsC;;AAE7C,SAAK,IAAIG,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGH,OAAO,CAACI,MAA9B,EAAsCF,CAAC,GAAGC,GAA1C,EAA+CD,CAAC,EAAhD,EAAoD;AAClD,UAAIG,UAAU,GAAGL,OAAO,CAACE,CAAD,CAAxB;;AAEA,UAAI,CAACJ,GAAG,CAACG,QAAJ,CAAaF,GAAb,EAAkBO,cAAlB,CAAiCD,UAAjC,CAAD,IAAiDP,GAAG,CAACC,GAAD,CAAH,CAASO,cAAT,CAAwBD,UAAxB,CAArD,EAA0F;AACxFP,QAAAA,GAAG,CAACG,QAAJ,CAAaF,GAAb,EAAkBM,UAAlB,IAAgCP,GAAG,CAACC,GAAD,CAAH,CAASM,UAAT,CAAhC;AACD;AACF;AACF;AACF;AACD,OAAO,IAAIE,kBAAkB,GAAG,CAAC,WAAD,EAAc,YAAd,EAA4B,UAA5B,EAAwC,YAAxC,EAAsD,MAAtD,EAA8D,KAA9D,EAAqE,OAArE,EAA8E,iBAA9E,EAAiG,iBAAjG,EAAoH,OAApH,EAA6H,QAA7H,EAAuI,YAAvI,EAAqJ,OAArJ,EAA8J,eAA9J,EAA+K,UAA/K,EAA2L,aAA3L,EAA0M,YAA1M,EAAwN,eAAxN,EAAyO,eAAzO,EAA0P,iBAA1P,EAA6Q,gBAA7Q,EAA+R,mBAA/R,EAAoT,mBAApT,EAAyU,iBAAzU,EAA4V,aAA5V,EAA2W,aAA3W,EAA0X,cAA1X,EAA0Y,SAA1Y,CAAzB,C,CAA+a;AACtb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,gBAAT,CAA0BC,QAA1B,EAAoC;AACzC,SAAOhC,QAAQ,CAACgC,QAAD,CAAR,IAAsB,CAAC/B,OAAO,CAAC+B,QAAD,CAA9B,IAA4C,EAAEA,QAAQ,YAAYC,IAAtB,CAA5C,GAA0ED,QAAQ,CAACd,KAAnF,GAA2Fc,QAAlG;AACD;AACD;AACA;AACA;AACA;;AAEA,OAAO,SAASE,gBAAT,CAA0BF,QAA1B,EAAoC;AACzC,SAAOhC,QAAQ,CAACgC,QAAD,CAAR,IAAsB,EAAEA,QAAQ,YAAYb,KAAtB,CAA7B,CADyC,CACkB;AAC3D;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASgB,eAAT,CAAyBC,SAAzB,EAAoCC,cAApC,EAAoDC,IAApD,EAA0D;AAC/D,MAAIC,iBAAiB,GAAGD,IAAI,KAAK,aAAjC;AACA,MAAIE,kBAAkB,GAAGF,IAAI,KAAK,cAAlC;AACA,MAAIG,gBAAgB,GAAGH,IAAI,KAAK,YAAhC;AACAF,EAAAA,SAAS,GAAGA,SAAS,IAAI,EAAzB;AACAC,EAAAA,cAAc,GAAG,CAACA,cAAc,IAAI,EAAnB,EAAuBK,KAAvB,EAAjB;AACA,MAAIC,gBAAgB,GAAGzC,aAAa,EAApC,CAN+D,CAMvB;;AAExCH,EAAAA,IAAI,CAACsC,cAAD,EAAiB,UAAUO,UAAV,EAAsBC,KAAtB,EAA6B;AAChD,QAAI,CAAC7C,QAAQ,CAAC4C,UAAD,CAAb,EAA2B;AACzBP,MAAAA,cAAc,CAACQ,KAAD,CAAd,GAAwB,IAAxB;AACA;AACD;;AAED,QAAIC,OAAO,CAACtC,GAAR,CAAYuC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC;AACA;AACA,UAAIH,UAAU,CAACI,EAAX,IAAiB,IAAjB,IAAyB,CAACC,eAAe,CAACL,UAAU,CAACI,EAAZ,CAA7C,EAA8D;AAC5DE,QAAAA,sBAAsB,CAACN,UAAU,CAACI,EAAZ,CAAtB;AACD;;AAED,UAAIJ,UAAU,CAACO,IAAX,IAAmB,IAAnB,IAA2B,CAACF,eAAe,CAACL,UAAU,CAACO,IAAZ,CAA/C,EAAkE;AAChED,QAAAA,sBAAsB,CAACN,UAAU,CAACO,IAAZ,CAAtB;AACD;AACF;AACF,GAjBG,CAAJ;AAkBA,MAAIC,MAAM,GAAGC,aAAa,CAACjB,SAAD,EAAYO,gBAAZ,EAA8BL,IAA9B,CAA1B;;AAEA,MAAIC,iBAAiB,IAAIC,kBAAzB,EAA6C;AAC3Cc,IAAAA,WAAW,CAACF,MAAD,EAAShB,SAAT,EAAoBO,gBAApB,EAAsCN,cAAtC,CAAX;AACD;;AAED,MAAIE,iBAAJ,EAAuB;AACrBgB,IAAAA,aAAa,CAACH,MAAD,EAASf,cAAT,CAAb;AACD;;AAED,MAAIE,iBAAiB,IAAIC,kBAAzB,EAA6C;AAC3CgB,IAAAA,cAAc,CAACJ,MAAD,EAASf,cAAT,EAAyBG,kBAAzB,CAAd;AACD,GAFD,MAEO,IAAIC,gBAAJ,EAAsB;AAC3BgB,IAAAA,uBAAuB,CAACL,MAAD,EAASf,cAAT,CAAvB;AACD;;AAEDqB,EAAAA,aAAa,CAACN,MAAD,CAAb,CA1C+D,CA0CxC;AACvB;;AAEA,SAAOA,MAAP;AACD;;AAED,SAASC,aAAT,CAAuBjB,SAAvB,EAAkCO,gBAAlC,EAAoDL,IAApD,EAA0D;AACxD,MAAIc,MAAM,GAAG,EAAb;;AAEA,MAAId,IAAI,KAAK,YAAb,EAA2B;AACzB,WAAOc,MAAP;AACD,GALuD,CAKtD;AACF;;;AAGA,OAAK,IAAIP,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGT,SAAS,CAACT,MAAtC,EAA8CkB,KAAK,EAAnD,EAAuD;AACrD,QAAIc,QAAQ,GAAGvB,SAAS,CAACS,KAAD,CAAxB,CADqD,CACpB;;AAEjC,QAAIc,QAAQ,IAAIA,QAAQ,CAACX,EAAT,IAAe,IAA/B,EAAqC;AACnCL,MAAAA,gBAAgB,CAACiB,GAAjB,CAAqBD,QAAQ,CAACX,EAA9B,EAAkCH,KAAlC;AACD,KALoD,CAKnD;AACF;AACA;AACA;AACA;;;AAGAO,IAAAA,MAAM,CAACS,IAAP,CAAY;AACVF,MAAAA,QAAQ,EAAErB,IAAI,KAAK,cAAT,IAA2BwB,qBAAqB,CAACH,QAAD,CAAhD,GAA6D,IAA7D,GAAoEA,QADpE;AAEVI,MAAAA,SAAS,EAAE,IAFD;AAGVC,MAAAA,OAAO,EAAE,IAHC;AAIVC,MAAAA,QAAQ,EAAE;AAJA,KAAZ;AAMD;;AAED,SAAOb,MAAP;AACD;;AAED,SAASE,WAAT,CAAqBF,MAArB,EAA6BhB,SAA7B,EAAwCO,gBAAxC,EAA0DN,cAA1D,EAA0E;AACxE;AACAtC,EAAAA,IAAI,CAACsC,cAAD,EAAiB,UAAUO,UAAV,EAAsBC,KAAtB,EAA6B;AAChD,QAAI,CAACD,UAAD,IAAeA,UAAU,CAACI,EAAX,IAAiB,IAApC,EAA0C;AACxC;AACD;;AAED,QAAIkB,QAAQ,GAAGC,iBAAiB,CAACvB,UAAU,CAACI,EAAZ,CAAhC;AACA,QAAIoB,WAAW,GAAGzB,gBAAgB,CAAC0B,GAAjB,CAAqBH,QAArB,CAAlB;;AAEA,QAAIE,WAAW,IAAI,IAAnB,EAAyB;AACvB,UAAIE,UAAU,GAAGlB,MAAM,CAACgB,WAAD,CAAvB;AACAhE,MAAAA,MAAM,CAAC,CAACkE,UAAU,CAACP,SAAb,EAAwB,8BAA8BG,QAA9B,GAAyC,IAAjE,CAAN;AACAI,MAAAA,UAAU,CAACP,SAAX,GAAuBnB,UAAvB,CAHuB,CAGY;AACnC;;AAEA0B,MAAAA,UAAU,CAACX,QAAX,GAAsBvB,SAAS,CAACgC,WAAD,CAA/B;AACA/B,MAAAA,cAAc,CAACQ,KAAD,CAAd,GAAwB,IAAxB;AACD;AACF,GAjBG,CAAJ;AAkBD;;AAED,SAASU,aAAT,CAAuBH,MAAvB,EAA+Bf,cAA/B,EAA+C;AAC7C;AACAtC,EAAAA,IAAI,CAACsC,cAAD,EAAiB,UAAUO,UAAV,EAAsBC,KAAtB,EAA6B;AAChD,QAAI,CAACD,UAAD,IAAeA,UAAU,CAACO,IAAX,IAAmB,IAAtC,EAA4C;AAC1C;AACD;;AAED,SAAK,IAAI1B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2B,MAAM,CAACzB,MAA3B,EAAmCF,CAAC,EAApC,EAAwC;AACtC,UAAIkC,QAAQ,GAAGP,MAAM,CAAC3B,CAAD,CAAN,CAAUkC,QAAzB;;AAEA,UAAI,CAACP,MAAM,CAAC3B,CAAD,CAAN,CAAUsC,SAAX,CAAqB;AACzB;AADI,SAEDJ,QAFC,KAEYA,QAAQ,CAACX,EAAT,IAAe,IAAf,IAAuBJ,UAAU,CAACI,EAAX,IAAiB,IAFpD,KAE6D,CAACc,qBAAqB,CAAClB,UAAD,CAFnF,IAEmG,CAACkB,qBAAqB,CAACH,QAAD,CAFzH,IAEuIY,gBAAgB,CAAC,MAAD,EAASZ,QAAT,EAAmBf,UAAnB,CAF3J,EAE2L;AACzLQ,QAAAA,MAAM,CAAC3B,CAAD,CAAN,CAAUsC,SAAV,GAAsBnB,UAAtB;AACAP,QAAAA,cAAc,CAACQ,KAAD,CAAd,GAAwB,IAAxB;AACA;AACD;AACF;AACF,GAhBG,CAAJ;AAiBD;;AAED,SAASW,cAAT,CAAwBJ,MAAxB,EAAgCf,cAAhC,EAAgD4B,QAAhD,EAA0D;AACxDlE,EAAAA,IAAI,CAACsC,cAAD,EAAiB,UAAUO,UAAV,EAAsB;AACzC,QAAI,CAACA,UAAL,EAAiB;AACf;AACD,KAHwC,CAGvC;;;AAGF,QAAI0B,UAAJ;AACA,QAAIE,OAAO,GAAG,CAAd;;AAEA,YAAQ;AACR,KAACF,UAAU,GAAGlB,MAAM,CAACoB,OAAD,CAApB,OAAoC;AACpC;AACA;AACA;AACA;AACA;AACAF,IAAAA,UAAU,CAACP,SAAX,IAAwBD,qBAAqB,CAACQ,UAAU,CAACX,QAAZ,CAA7C,IAAsE;AACtEW,IAAAA,UAAU,CAACX,QAAX,IAAuBf,UAAU,CAACI,EAAX,IAAiB,IAAxC,IAAgD,CAACuB,gBAAgB,CAAC,IAAD,EAAO3B,UAAP,EAAmB0B,UAAU,CAACX,QAA9B,CAPjE,CADA,EAQ2G;AACzGa,MAAAA,OAAO;AACR;;AAED,QAAIF,UAAJ,EAAgB;AACdA,MAAAA,UAAU,CAACP,SAAX,GAAuBnB,UAAvB;AACA0B,MAAAA,UAAU,CAACL,QAAX,GAAsBA,QAAtB;AACD,KAHD,MAGO;AACLb,MAAAA,MAAM,CAACS,IAAP,CAAY;AACVE,QAAAA,SAAS,EAAEnB,UADD;AAEVqB,QAAAA,QAAQ,EAAEA,QAFA;AAGVN,QAAAA,QAAQ,EAAE,IAHA;AAIVK,QAAAA,OAAO,EAAE;AAJC,OAAZ;AAMD;;AAEDQ,IAAAA,OAAO;AACR,GAlCG,CAAJ;AAmCD;;AAED,SAASf,uBAAT,CAAiCL,MAAjC,EAAyCf,cAAzC,EAAyD;AACvDtC,EAAAA,IAAI,CAACsC,cAAD,EAAiB,UAAUO,UAAV,EAAsB;AACzC;AACA;AACAQ,IAAAA,MAAM,CAACS,IAAP,CAAY;AACVE,MAAAA,SAAS,EAAEnB,UADD;AAEVqB,MAAAA,QAAQ,EAAE,IAFA;AAGVN,MAAAA,QAAQ,EAAE,IAHA;AAIVK,MAAAA,OAAO,EAAE;AAJC,KAAZ;AAMD,GATG,CAAJ;AAUD;AACD;AACA;AACA;AACA;;;AAGA,SAASN,aAAT,CAAuBe,SAAvB,EAAkC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAIC,KAAK,GAAGxE,aAAa,EAAzB;AACAH,EAAAA,IAAI,CAAC0E,SAAD,EAAY,UAAUE,IAAV,EAAgB;AAC9B,QAAIhB,QAAQ,GAAGgB,IAAI,CAAChB,QAApB;AACAA,IAAAA,QAAQ,IAAIe,KAAK,CAACd,GAAN,CAAUD,QAAQ,CAACX,EAAnB,EAAuB2B,IAAvB,CAAZ;AACD,GAHG,CAAJ;AAIA5E,EAAAA,IAAI,CAAC0E,SAAD,EAAY,UAAUE,IAAV,EAAgB;AAC9B,QAAItD,GAAG,GAAGsD,IAAI,CAACZ,SAAf,CAD8B,CACJ;;AAE1B3D,IAAAA,MAAM,CAAC,CAACiB,GAAD,IAAQA,GAAG,CAAC2B,EAAJ,IAAU,IAAlB,IAA0B,CAAC0B,KAAK,CAACL,GAAN,CAAUhD,GAAG,CAAC2B,EAAd,CAA3B,IAAgD0B,KAAK,CAACL,GAAN,CAAUhD,GAAG,CAAC2B,EAAd,MAAsB2B,IAAvE,EAA6E,qBAAqBtD,GAAG,IAAIA,GAAG,CAAC2B,EAAhC,CAA7E,CAAN;AACA3B,IAAAA,GAAG,IAAIA,GAAG,CAAC2B,EAAJ,IAAU,IAAjB,IAAyB0B,KAAK,CAACd,GAAN,CAAUvC,GAAG,CAAC2B,EAAd,EAAkB2B,IAAlB,CAAzB;AACA,KAACA,IAAI,CAACX,OAAN,KAAkBW,IAAI,CAACX,OAAL,GAAe,EAAjC;AACD,GANG,CAAJ,CAfgC,CAqB5B;;AAEJjE,EAAAA,IAAI,CAAC0E,SAAD,EAAY,UAAUE,IAAV,EAAgB9B,KAAhB,EAAuB;AACrC,QAAIc,QAAQ,GAAGgB,IAAI,CAAChB,QAApB;AACA,QAAItC,GAAG,GAAGsD,IAAI,CAACZ,SAAf;AACA,QAAIC,OAAO,GAAGW,IAAI,CAACX,OAAnB;;AAEA,QAAI,CAAChE,QAAQ,CAACqB,GAAD,CAAb,EAAoB;AAClB;AACD,KAPoC,CAOnC;AACF;AACA;AACA;;;AAGA2C,IAAAA,OAAO,CAACb,IAAR,GAAe9B,GAAG,CAAC8B,IAAJ,IAAY,IAAZ,GAAmBgB,iBAAiB,CAAC9C,GAAG,CAAC8B,IAAL,CAApC,GAAiDQ,QAAQ,GAAGA,QAAQ,CAACR,IAAZ,CAAiB;AACzF;AADwE,MAEtEpC,2BAA2B,GAAG8B,KAFhC;;AAIA,QAAIc,QAAJ,EAAc;AACZK,MAAAA,OAAO,CAAChB,EAAR,GAAamB,iBAAiB,CAACR,QAAQ,CAACX,EAAV,CAA9B;AACD,KAFD,MAEO,IAAI3B,GAAG,CAAC2B,EAAJ,IAAU,IAAd,EAAoB;AACzBgB,MAAAA,OAAO,CAAChB,EAAR,GAAamB,iBAAiB,CAAC9C,GAAG,CAAC2B,EAAL,CAA9B;AACD,KAFM,MAEA;AACL;AACA;AACA;AACA;AACA;AACA,UAAI4B,KAAK,GAAG,CAAZ;;AAEA,SAAG;AACDZ,QAAAA,OAAO,CAAChB,EAAR,GAAa,OAAOgB,OAAO,CAACb,IAAf,GAAsB,IAAtB,GAA6ByB,KAAK,EAA/C;AACD,OAFD,QAESF,KAAK,CAACL,GAAN,CAAUL,OAAO,CAAChB,EAAlB,CAFT;AAGD;;AAED0B,IAAAA,KAAK,CAACd,GAAN,CAAUI,OAAO,CAAChB,EAAlB,EAAsB2B,IAAtB;AACD,GAnCG,CAAJ;AAoCD;;AAED,SAASJ,gBAAT,CAA0BM,IAA1B,EAAgCC,IAAhC,EAAsCC,IAAtC,EAA4C;AAC1C,MAAIC,IAAI,GAAGC,mBAAmB,CAACH,IAAI,CAACD,IAAD,CAAL,EAAa,IAAb,CAA9B;AACA,MAAIK,IAAI,GAAGD,mBAAmB,CAACF,IAAI,CAACF,IAAD,CAAL,EAAa,IAAb,CAA9B,CAF0C,CAEQ;;AAElD,SAAOG,IAAI,IAAI,IAAR,IAAgBE,IAAI,IAAI,IAAxB,IAAgCF,IAAI,KAAKE,IAAhD;AACD;AACD;AACA;AACA;;;AAGA,SAASf,iBAAT,CAA2BgB,GAA3B,EAAgC;AAC9B,MAAIrC,OAAO,CAACtC,GAAR,CAAYuC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,QAAIoC,GAAG,IAAI,IAAX,EAAiB;AACf,YAAM,IAAIC,KAAJ,EAAN;AACD;AACF;;AAED,SAAOH,mBAAmB,CAACE,GAAD,EAAM,EAAN,CAA1B;AACD;;AAED,OAAO,SAASF,mBAAT,CAA6BI,QAA7B,EAAuCC,YAAvC,EAAqD;AAC1D,MAAID,QAAQ,IAAI,IAAhB,EAAsB;AACpB,WAAOC,YAAP;AACD;;AAED,MAAIC,IAAI,GAAG,OAAOF,QAAlB;AACA,SAAOE,IAAI,KAAK,QAAT,GAAoBF,QAApB,GAA+BE,IAAI,KAAK,QAAT,IAAqBhF,YAAY,CAAC8E,QAAD,CAAjC,GAA8CA,QAAQ,GAAG,EAAzD,GAA8DC,YAApG;AACD;;AAED,SAASpC,sBAAT,CAAgCmC,QAAhC,EAA0C;AACxC,MAAIvC,OAAO,CAACtC,GAAR,CAAYuC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCjC,IAAAA,IAAI,CAAC,MAAMuE,QAAN,GAAiB,sDAAlB,CAAJ;AACD;AACF;;AAED,SAASpC,eAAT,CAAyBoC,QAAzB,EAAmC;AACjC,SAAO9E,YAAY,CAAC8E,QAAD,CAAZ,IAA0B5E,SAAS,CAAC4E,QAAD,CAA1C;AACD;;AAED,OAAO,SAASG,eAAT,CAAyBC,cAAzB,EAAyC;AAC9C,MAAItC,IAAI,GAAGsC,cAAc,CAACtC,IAA1B,CAD8C,CACd;;AAEhC,SAAO,CAAC,EAAEA,IAAI,IAAIA,IAAI,CAAC7C,OAAL,CAAaS,2BAAb,CAAV,CAAR;AACD;AACD;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAAS+C,qBAAT,CAA+BlB,UAA/B,EAA2C;AAChD,SAAOA,UAAU,IAAIA,UAAU,CAACI,EAAX,IAAiB,IAA/B,IAAuCmB,iBAAiB,CAACvB,UAAU,CAACI,EAAZ,CAAjB,CAAiC1C,OAAjC,CAAyCU,4BAAzC,MAA2E,CAAzH;AACD;AACD,OAAO,SAAS0E,uBAAT,CAAiCC,QAAjC,EAA2C;AAChD,SAAO3E,4BAA4B,GAAG2E,QAAtC;AACD;AACD,OAAO,SAASC,yBAAT,CAAmCC,aAAnC,EAAkDC,QAAlD,EAA4DC,kBAA5D,EAAgF;AACrF;AACAhG,EAAAA,IAAI,CAAC8F,aAAD,EAAgB,UAAUlB,IAAV,EAAgB;AAClC,QAAIZ,SAAS,GAAGY,IAAI,CAACZ,SAArB;;AAEA,QAAI/D,QAAQ,CAAC+D,SAAD,CAAZ,EAAyB;AACvBY,MAAAA,IAAI,CAACX,OAAL,CAAa8B,QAAb,GAAwBA,QAAxB;AACAnB,MAAAA,IAAI,CAACX,OAAL,CAAagC,OAAb,GAAuBC,gBAAgB,CAACH,QAAD,EAAW/B,SAAX,EAAsBY,IAAI,CAAChB,QAA3B,EAAqCoC,kBAArC,CAAvC;AACD;AACF,GAPG,CAAJ;AAQD;;AAED,SAASE,gBAAT,CAA0BH,QAA1B,EAAoCI,aAApC,EAAmDC,cAAnD,EAAmEJ,kBAAnE,EAAuF;AACrF,MAAIC,OAAO,GAAGE,aAAa,CAACX,IAAd,GAAqBW,aAAa,CAACX,IAAnC,GAA0CY,cAAc,GAAGA,cAAc,CAACH,OAAlB,CAA0B;AAA1B,IACpED,kBAAkB,CAACE,gBAAnB,CAAoCH,QAApC,EAA8CI,aAA9C,CADF,CADqF,CAErB;;AAEhE,SAAOF,OAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO,SAASI,eAAT,CAAyBC,MAAzB,EAAiCC,MAAjC,EAAyC;AAC9C,MAAIC,IAAI,GAAG,EAAX;AACA,MAAIC,IAAI,GAAG,EAAX;AACAC,EAAAA,OAAO,CAACJ,MAAM,IAAI,EAAX,EAAeE,IAAf,CAAP;AACAE,EAAAA,OAAO,CAACH,MAAM,IAAI,EAAX,EAAeE,IAAf,EAAqBD,IAArB,CAAP;AACA,SAAO,CAACG,UAAU,CAACH,IAAD,CAAX,EAAmBG,UAAU,CAACF,IAAD,CAA7B,CAAP;;AAEA,WAASC,OAAT,CAAiBE,WAAjB,EAA8BxG,GAA9B,EAAmCyG,QAAnC,EAA6C;AAC3C,SAAK,IAAInF,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGiF,WAAW,CAAChF,MAAlC,EAA0CF,CAAC,GAAGC,GAA9C,EAAmDD,CAAC,EAApD,EAAwD;AACtD,UAAIoF,QAAQ,GAAG5B,mBAAmB,CAAC0B,WAAW,CAAClF,CAAD,CAAX,CAAeoF,QAAhB,EAA0B,IAA1B,CAAlC;;AAEA,UAAIA,QAAQ,IAAI,IAAhB,EAAsB;AACpB;AACD;;AAED,UAAIC,WAAW,GAAG7F,gBAAgB,CAAC0F,WAAW,CAAClF,CAAD,CAAX,CAAesF,SAAhB,CAAlC;AACA,UAAIC,gBAAgB,GAAGJ,QAAQ,IAAIA,QAAQ,CAACC,QAAD,CAA3C;;AAEA,WAAK,IAAII,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAGJ,WAAW,CAACnF,MAAnC,EAA2CsF,CAAC,GAAGC,IAA/C,EAAqDD,CAAC,EAAtD,EAA0D;AACxD,YAAIF,SAAS,GAAGD,WAAW,CAACG,CAAD,CAA3B;;AAEA,YAAID,gBAAgB,IAAIA,gBAAgB,CAACD,SAAD,CAAxC,EAAqD;AACnDC,UAAAA,gBAAgB,CAACD,SAAD,CAAhB,GAA8B,IAA9B;AACD,SAFD,MAEO;AACL,WAAC5G,GAAG,CAAC0G,QAAD,CAAH,KAAkB1G,GAAG,CAAC0G,QAAD,CAAH,GAAgB,EAAlC,CAAD,EAAwCE,SAAxC,IAAqD,CAArD;AACD;AACF;AACF;AACF;;AAED,WAASL,UAAT,CAAoBvG,GAApB,EAAyBgH,MAAzB,EAAiC;AAC/B,QAAI/D,MAAM,GAAG,EAAb;;AAEA,SAAK,IAAI3B,CAAT,IAActB,GAAd,EAAmB;AACjB,UAAIA,GAAG,CAAC0B,cAAJ,CAAmBJ,CAAnB,KAAyBtB,GAAG,CAACsB,CAAD,CAAH,IAAU,IAAvC,EAA6C;AAC3C,YAAI0F,MAAJ,EAAY;AACV/D,UAAAA,MAAM,CAACS,IAAP,CAAY,CAACpC,CAAb;AACD,SAFD,MAEO;AACL,cAAIqF,WAAW,GAAGJ,UAAU,CAACvG,GAAG,CAACsB,CAAD,CAAJ,EAAS,IAAT,CAA5B;AACAqF,UAAAA,WAAW,CAACnF,MAAZ,IAAsByB,MAAM,CAACS,IAAP,CAAY;AAChCgD,YAAAA,QAAQ,EAAEpF,CADsB;AAEhCsF,YAAAA,SAAS,EAAED;AAFqB,WAAZ,CAAtB;AAID;AACF;AACF;;AAED,WAAO1D,MAAP;AACD;AACF;AACD;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASgE,cAAT,CAAwBC,IAAxB,EAA8BC,OAA9B,EAAuC;AAC5C,MAAIA,OAAO,CAACC,eAAR,IAA2B,IAA/B,EAAqC;AACnC,WAAOD,OAAO,CAACC,eAAf;AACD,GAFD,MAEO,IAAID,OAAO,CAACP,SAAR,IAAqB,IAAzB,EAA+B;AACpC,WAAO9G,OAAO,CAACqH,OAAO,CAACP,SAAT,CAAP,GAA6B5G,GAAG,CAACmH,OAAO,CAACP,SAAT,EAAoB,UAAU7F,KAAV,EAAiB;AAC1E,aAAOmG,IAAI,CAACG,eAAL,CAAqBtG,KAArB,CAAP;AACD,KAFsC,CAAhC,GAEFmG,IAAI,CAACG,eAAL,CAAqBF,OAAO,CAACP,SAA7B,CAFL;AAGD,GAJM,MAIA,IAAIO,OAAO,CAACnE,IAAR,IAAgB,IAApB,EAA0B;AAC/B,WAAOlD,OAAO,CAACqH,OAAO,CAACnE,IAAT,CAAP,GAAwBhD,GAAG,CAACmH,OAAO,CAACnE,IAAT,EAAe,UAAUjC,KAAV,EAAiB;AAChE,aAAOmG,IAAI,CAACI,WAAL,CAAiBvG,KAAjB,CAAP;AACD,KAFiC,CAA3B,GAEFmG,IAAI,CAACI,WAAL,CAAiBH,OAAO,CAACnE,IAAzB,CAFL;AAGD;AACF;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASuE,SAAT,GAAqB;AAC1B,MAAIpG,GAAG,GAAG,gBAAgBqG,gBAAgB,EAA1C;AACA,SAAO,UAAUC,OAAV,EAAmB;AACxB,WAAOA,OAAO,CAACtG,GAAD,CAAP,KAAiBsG,OAAO,CAACtG,GAAD,CAAP,GAAe,EAAhC,CAAP;AACD,GAFD;AAGD;AACD,IAAIqG,gBAAgB,GAAGjH,eAAe,EAAtC;AACA;AACA;AACA;;AAEA,OAAO,SAASmH,WAAT,CAAqBC,OAArB,EAA8BC,WAA9B,EAA2C1G,GAA3C,EAAgD;AACrD,MAAI2G,EAAE,GAAGC,cAAc,CAACF,WAAD,EAAc1G,GAAd,CAAvB;AAAA,MACI6G,iBAAiB,GAAGF,EAAE,CAACE,iBAD3B;AAAA,MAEIC,cAAc,GAAGH,EAAE,CAACG,cAFxB;AAAA,MAGIC,MAAM,GAAGJ,EAAE,CAACI,MAHhB;;AAKA,MAAIhF,MAAM,GAAGgF,MAAb;AACA,MAAIC,eAAe,GAAGhH,GAAG,GAAGA,GAAG,CAACgH,eAAP,GAAyB,IAAlD;;AAEA,MAAI,CAACH,iBAAD,IAAsBG,eAA1B,EAA2C;AACzCF,IAAAA,cAAc,CAACvE,GAAf,CAAmByE,eAAnB,EAAoC,EAApC;AACD;;AAEDF,EAAAA,cAAc,CAACpI,IAAf,CAAoB,UAAUuI,WAAV,EAAuBxC,QAAvB,EAAiC;AACnD,QAAIyC,WAAW,GAAGC,wBAAwB,CAACV,OAAD,EAAUhC,QAAV,EAAoBwC,WAApB,EAAiC;AACzEG,MAAAA,UAAU,EAAEJ,eAAe,KAAKvC,QADyC;AAEzE4C,MAAAA,SAAS,EAAErH,GAAG,IAAIA,GAAG,CAACqH,SAAJ,IAAiB,IAAxB,GAA+BrH,GAAG,CAACqH,SAAnC,GAA+C,IAFe;AAGzEC,MAAAA,UAAU,EAAEtH,GAAG,IAAIA,GAAG,CAACsH,UAAJ,IAAkB,IAAzB,GAAgCtH,GAAG,CAACsH,UAApC,GAAiD;AAHY,KAAjC,CAA1C;AAKAvF,IAAAA,MAAM,CAAC0C,QAAQ,GAAG,QAAZ,CAAN,GAA8ByC,WAAW,CAACK,MAA1C;AACAxF,IAAAA,MAAM,CAAC0C,QAAQ,GAAG,OAAZ,CAAN,GAA6ByC,WAAW,CAACK,MAAZ,CAAmB,CAAnB,CAA7B;AACD,GARD;AASA,SAAOxF,MAAP;AACD;AACD,OAAO,SAAS6E,cAAT,CAAwBF,WAAxB,EAAqC1G,GAArC,EAA0C;AAC/C,MAAIwH,MAAJ;;AAEA,MAAIxI,QAAQ,CAAC0H,WAAD,CAAZ,EAA2B;AACzB,QAAIe,GAAG,GAAG,EAAV;AACAA,IAAAA,GAAG,CAACf,WAAW,GAAG,OAAf,CAAH,GAA6B,CAA7B;AACAc,IAAAA,MAAM,GAAGC,GAAT;AACD,GAJD,MAIO;AACLD,IAAAA,MAAM,GAAGd,WAAT;AACD;;AAED,MAAII,cAAc,GAAGjI,aAAa,EAAlC;AACA,MAAIkI,MAAM,GAAG,EAAb;AACA,MAAIF,iBAAiB,GAAG,KAAxB;AACAnI,EAAAA,IAAI,CAAC8I,MAAD,EAAS,UAAU3H,KAAV,EAAiBI,GAAjB,EAAsB;AACjC;AACA,QAAIA,GAAG,KAAK,WAAR,IAAuBA,GAAG,KAAK,iBAAnC,EAAsD;AACpD8G,MAAAA,MAAM,CAAC9G,GAAD,CAAN,GAAcJ,KAAd;AACA;AACD;;AAED,QAAI6H,SAAS,GAAGzH,GAAG,CAAC0H,KAAJ,CAAU,wBAAV,KAAuC,EAAvD;AACA,QAAIlD,QAAQ,GAAGiD,SAAS,CAAC,CAAD,CAAxB;AACA,QAAIE,SAAS,GAAG,CAACF,SAAS,CAAC,CAAD,CAAT,IAAgB,EAAjB,EAAqBG,WAArB,EAAhB;;AAEA,QAAI,CAACpD,QAAD,IAAa,CAACmD,SAAd,IAA2B5H,GAAG,IAAIA,GAAG,CAAC8H,gBAAX,IAA+B7I,OAAO,CAACe,GAAG,CAAC8H,gBAAL,EAAuBrD,QAAvB,CAAP,GAA0C,CAAxG,EAA2G;AACzG;AACD;;AAEDoC,IAAAA,iBAAiB,GAAGA,iBAAiB,IAAI,CAAC,CAACpC,QAA3C;AACA,QAAIwC,WAAW,GAAGH,cAAc,CAAC9D,GAAf,CAAmByB,QAAnB,KAAgCqC,cAAc,CAACvE,GAAf,CAAmBkC,QAAnB,EAA6B,EAA7B,CAAlD;AACAwC,IAAAA,WAAW,CAACW,SAAD,CAAX,GAAyB/H,KAAzB;AACD,GAlBG,CAAJ;AAmBA,SAAO;AACLgH,IAAAA,iBAAiB,EAAEA,iBADd;AAELC,IAAAA,cAAc,EAAEA,cAFX;AAGLC,IAAAA,MAAM,EAAEA;AAHH,GAAP;AAKD;AACD,OAAO,IAAIgB,gBAAgB,GAAG;AAC5BX,EAAAA,UAAU,EAAE,IADgB;AAE5BC,EAAAA,SAAS,EAAE,KAFiB;AAG5BC,EAAAA,UAAU,EAAE;AAHgB,CAAvB;AAKP,OAAO,IAAIU,kBAAkB,GAAG;AAC9BZ,EAAAA,UAAU,EAAE,KADkB;AAE9BC,EAAAA,SAAS,EAAE,IAFmB;AAG9BC,EAAAA,UAAU,EAAE;AAHkB,CAAzB;AAKP,OAAO,SAASH,wBAAT,CAAkCV,OAAlC,EAA2ChC,QAA3C,EAAqDwD,UAArD,EAAiEjI,GAAjE,EAAsE;AAC3EA,EAAAA,GAAG,GAAGA,GAAG,IAAI+H,gBAAb;AACA,MAAIG,WAAW,GAAGD,UAAU,CAACzG,KAA7B;AACA,MAAI2G,QAAQ,GAAGF,UAAU,CAACtG,EAA1B;AACA,MAAIyG,UAAU,GAAGH,UAAU,CAACnG,IAA5B;AACA,MAAIC,MAAM,GAAG;AACXwF,IAAAA,MAAM,EAAE,IADG;AAEXc,IAAAA,SAAS,EAAEH,WAAW,IAAI,IAAf,IAAuBC,QAAQ,IAAI,IAAnC,IAA2CC,UAAU,IAAI;AAFzD,GAAb;;AAKA,MAAI,CAACrG,MAAM,CAACsG,SAAZ,EAAuB;AACrB;AACA,QAAIC,SAAS,GAAG,KAAK,CAArB;AACAvG,IAAAA,MAAM,CAACwF,MAAP,GAAgBvH,GAAG,CAACoH,UAAJ,KAAmBkB,SAAS,GAAG7B,OAAO,CAAC8B,YAAR,CAAqB9D,QAArB,CAA/B,IAAiE,CAAC6D,SAAD,CAAjE,GAA+E,EAA/F;AACA,WAAOvG,MAAP;AACD;;AAED,MAAImG,WAAW,KAAK,MAAhB,IAA0BA,WAAW,KAAK,KAA9C,EAAqD;AACnDnJ,IAAAA,MAAM,CAACiB,GAAG,CAACsH,UAAL,EAAiB,2DAAjB,CAAN;AACAvF,IAAAA,MAAM,CAACwF,MAAP,GAAgB,EAAhB;AACA,WAAOxF,MAAP;AACD,GArB0E,CAqBzE;AACF;;;AAGA,MAAImG,WAAW,KAAK,KAApB,EAA2B;AACzBnJ,IAAAA,MAAM,CAACiB,GAAG,CAACqH,SAAL,EAAgB,+CAAhB,CAAN;AACAa,IAAAA,WAAW,GAAGC,QAAQ,GAAGC,UAAU,GAAG,IAAtC;AACD;;AAEDrG,EAAAA,MAAM,CAACwF,MAAP,GAAgBd,OAAO,CAAC+B,eAAR,CAAwB;AACtC/D,IAAAA,QAAQ,EAAEA,QAD4B;AAEtCjD,IAAAA,KAAK,EAAE0G,WAF+B;AAGtCvG,IAAAA,EAAE,EAAEwG,QAHkC;AAItCrG,IAAAA,IAAI,EAAEsG;AAJgC,GAAxB,CAAhB;AAMA,SAAOrG,MAAP;AACD;AACD,OAAO,SAAS0G,YAAT,CAAsBC,GAAtB,EAA2BzI,GAA3B,EAAgCJ,KAAhC,EAAuC;AAC5C6I,EAAAA,GAAG,CAACD,YAAJ,GAAmBC,GAAG,CAACD,YAAJ,CAAiBxI,GAAjB,EAAsBJ,KAAtB,CAAnB,GAAkD6I,GAAG,CAACzI,GAAD,CAAH,GAAWJ,KAA7D;AACD;AACD,OAAO,SAAS8I,YAAT,CAAsBD,GAAtB,EAA2BzI,GAA3B,EAAgC;AACrC,SAAOyI,GAAG,CAACC,YAAJ,GAAmBD,GAAG,CAACC,YAAJ,CAAiB1I,GAAjB,CAAnB,GAA2CyI,GAAG,CAACzI,GAAD,CAArD;AACD;AACD,OAAO,SAAS2I,oBAAT,CAA8BC,gBAA9B,EAAgD;AACrD,MAAIA,gBAAgB,KAAK,MAAzB,EAAiC;AAC/B;AACA,WAAO1J,GAAG,CAAC2J,YAAJ,GAAmB,MAAnB,GAA4B,UAAnC;AACD,GAHD,MAGO;AACL,WAAOD,gBAAgB,IAAI,MAA3B;AACD;AACF;AACD;AACA;AACA;;AAEA,OAAO,SAASE,SAAT,CAAmBC,KAAnB,EAA0BC,MAA1B,CAAiC;AAAjC,EACL;AACA,MAAIC,OAAO,GAAGrK,aAAa,EAA3B;AACA,MAAIsK,IAAI,GAAG,EAAX;AACAzK,EAAAA,IAAI,CAACsK,KAAD,EAAQ,UAAU1F,IAAV,EAAgB;AAC1B,QAAIrD,GAAG,GAAGgJ,MAAM,CAAC3F,IAAD,CAAhB;AACA,KAAC4F,OAAO,CAAClG,GAAR,CAAY/C,GAAZ,MAAqBkJ,IAAI,CAAC3G,IAAL,CAAUvC,GAAV,GAAgBiJ,OAAO,CAAC3G,GAAR,CAAYtC,GAAZ,EAAiB,EAAjB,CAArC,CAAD,EAA6DuC,IAA7D,CAAkEc,IAAlE;AACD,GAHG,CAAJ;AAIA,SAAO;AACL6F,IAAAA,IAAI,EAAEA,IADD;AAELD,IAAAA,OAAO,EAAEA;AAFJ,GAAP;AAID;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASE,oBAAT,CAA8BpD,IAA9B,EAAoCqD,SAApC,EAA+CC,WAA/C,EAA4DC,WAA5D,EAAyEC,OAAzE,EAAkF;AACvF,MAAIC,eAAe,GAAGJ,SAAS,IAAI,IAAb,IAAqBA,SAAS,KAAK,MAAzD;;AAEA,MAAIE,WAAW,IAAI,IAAnB,EAAyB;AACvB,WAAOA,WAAP;AACD;;AAED,MAAI,OAAOA,WAAP,KAAuB,QAA3B,EAAqC;AACnC,QAAI1J,KAAK,GAAGL,iBAAiB,CAAC8J,WAAW,IAAI,CAAhB,EAAmBC,WAAnB,EAAgCC,OAAhC,CAA7B;AACA,WAAOjK,KAAK,CAACM,KAAD,EAAQ4J,eAAe,GAAGC,IAAI,CAACC,GAAL,CAASrK,YAAY,CAACgK,WAAW,IAAI,CAAhB,CAArB,EAAyChK,YAAY,CAACiK,WAAD,CAArD,CAAH,GAAyEF,SAAhG,CAAZ;AACD,GAHD,MAGO,IAAI,OAAOE,WAAP,KAAuB,QAA3B,EAAqC;AAC1C,WAAOC,OAAO,GAAG,CAAV,GAAcF,WAAd,GAA4BC,WAAnC;AACD,GAFM,MAEA;AACL,QAAIK,YAAY,GAAG,EAAnB;AACA,QAAIC,OAAO,GAAGP,WAAd;AACA,QAAIQ,QAAQ,GAAGP,WAAf;AACA,QAAIQ,QAAQ,GAAGL,IAAI,CAACC,GAAL,CAASE,OAAO,GAAGA,OAAO,CAACvJ,MAAX,GAAoB,CAApC,EAAuCwJ,QAAQ,CAACxJ,MAAhD,CAAf;;AAEA,SAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2J,QAApB,EAA8B,EAAE3J,CAAhC,EAAmC;AACjC,UAAI4J,IAAI,GAAGhE,IAAI,CAACiE,gBAAL,CAAsB7J,CAAtB,CAAX,CADiC,CACI;;AAErC,UAAI4J,IAAI,IAAIA,IAAI,CAAC9F,IAAL,KAAc,SAA1B,EAAqC;AACnC;AACA0F,QAAAA,YAAY,CAACxJ,CAAD,CAAZ,GAAkB,CAACoJ,OAAO,GAAG,CAAV,IAAeK,OAAf,GAAyBA,OAAzB,GAAmCC,QAApC,EAA8C1J,CAA9C,CAAlB;AACD,OAHD,MAGO;AACL,YAAI8J,OAAO,GAAGL,OAAO,IAAIA,OAAO,CAACzJ,CAAD,CAAlB,GAAwByJ,OAAO,CAACzJ,CAAD,CAA/B,GAAqC,CAAnD;AACA,YAAI+J,QAAQ,GAAGL,QAAQ,CAAC1J,CAAD,CAAvB;AACA,YAAIP,KAAK,GAAGL,iBAAiB,CAAC0K,OAAD,EAAUC,QAAV,EAAoBX,OAApB,CAA7B;AACAI,QAAAA,YAAY,CAACxJ,CAAD,CAAZ,GAAkBb,KAAK,CAACM,KAAD,EAAQ4J,eAAe,GAAGC,IAAI,CAACC,GAAL,CAASrK,YAAY,CAAC4K,OAAD,CAArB,EAAgC5K,YAAY,CAAC6K,QAAD,CAA5C,CAAH,GAA6Dd,SAApF,CAAvB;AACD;AACF;;AAED,WAAOO,YAAP;AACD;AACF","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, isObject, isArray, createHashMap, map, assert, isString, indexOf, isStringSafe } from 'zrender/lib/core/util';\nimport env from 'zrender/lib/core/env';\nimport { isNumeric, getRandomIdBase, getPrecision, round } from './number';\nimport { interpolateNumber } from 'zrender/lib/animation/Animator';\nimport { warn } from './log';\n/**\n * Make the name displayable. But we should\n * make sure it is not duplicated with user\n * specified name, so use '\\0';\n */\n\nvar DUMMY_COMPONENT_NAME_PREFIX = 'series\\0';\nvar INTERNAL_COMPONENT_ID_PREFIX = '\\0_ec_\\0';\n/**\n * If value is not array, then translate it to array.\n * @param  {*} value\n * @return {Array} [value] or value\n */\n\nexport function normalizeToArray(value) {\n  return value instanceof Array ? value : value == null ? [] : [value];\n}\n/**\n * Sync default option between normal and emphasis like `position` and `show`\n * In case some one will write code like\n *     label: {\n *          show: false,\n *          position: 'outside',\n *          fontSize: 18\n *     },\n *     emphasis: {\n *          label: { show: true }\n *     }\n */\n\nexport function defaultEmphasis(opt, key, subOpts) {\n  // Caution: performance sensitive.\n  if (opt) {\n    opt[key] = opt[key] || {};\n    opt.emphasis = opt.emphasis || {};\n    opt.emphasis[key] = opt.emphasis[key] || {}; // Default emphasis option from normal\n\n    for (var i = 0, len = subOpts.length; i < len; i++) {\n      var subOptName = subOpts[i];\n\n      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {\n        opt.emphasis[key][subOptName] = opt[key][subOptName];\n      }\n    }\n  }\n}\nexport var TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding']; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([\n//     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',\n//     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',\n//     // FIXME: deprecated, check and remove it.\n//     'textStyle'\n// ]);\n\n/**\n * The method do not ensure performance.\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method retieves value from data.\n */\n\nexport function getDataItemValue(dataItem) {\n  return isObject(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;\n}\n/**\n * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]\n * This helper method determine if dataItem has extra option besides value\n */\n\nexport function isDataItemOption(dataItem) {\n  return isObject(dataItem) && !(dataItem instanceof Array); // // markLine data can be array\n  // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));\n}\n;\n/**\n * Mapping to existings for merge.\n *\n * Mode \"normalMege\":\n *     The mapping result (merge result) will keep the order of the existing\n *     component, rather than the order of new option. Because we should ensure\n *     some specified index reference (like xAxisIndex) keep work.\n *     And in most cases, \"merge option\" is used to update partial option but not\n *     be expected to change the order.\n *\n * Mode \"replaceMege\":\n *     (1) Only the id mapped components will be merged.\n *     (2) Other existing components (except internal compoonets) will be removed.\n *     (3) Other new options will be used to create new component.\n *     (4) The index of the existing compoents will not be modified.\n *     That means their might be \"hole\" after the removal.\n *     The new components are created first at those available index.\n *\n * Mode \"replaceAll\":\n *     This mode try to support that reproduce an echarts instance from another\n *     echarts instance (via `getOption`) in some simple cases.\n *     In this senario, the `result` index are exactly the consistent with the `newCmptOptions`,\n *     which ensures the compoennt index referring (like `xAxisIndex: ?`) corrent. That is,\n *     the \"hole\" in `newCmptOptions` will also be kept.\n *     On the contrary, other modes try best to eliminate holes.\n *     PENDING: This is an experimental mode yet.\n *\n * @return See the comment of <MappingResult>.\n */\n\nexport function mappingToExists(existings, newCmptOptions, mode) {\n  var isNormalMergeMode = mode === 'normalMerge';\n  var isReplaceMergeMode = mode === 'replaceMerge';\n  var isReplaceAllMode = mode === 'replaceAll';\n  existings = existings || [];\n  newCmptOptions = (newCmptOptions || []).slice();\n  var existingIdIdxMap = createHashMap(); // Validate id and name on user input option.\n\n  each(newCmptOptions, function (cmptOption, index) {\n    if (!isObject(cmptOption)) {\n      newCmptOptions[index] = null;\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // There is some legacy case that name is set as `false`.\n      // But should work normally rather than throw error.\n      if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {\n        warnInvalidateIdOrName(cmptOption.id);\n      }\n\n      if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {\n        warnInvalidateIdOrName(cmptOption.name);\n      }\n    }\n  });\n  var result = prepareResult(existings, existingIdIdxMap, mode);\n\n  if (isNormalMergeMode || isReplaceMergeMode) {\n    mappingById(result, existings, existingIdIdxMap, newCmptOptions);\n  }\n\n  if (isNormalMergeMode) {\n    mappingByName(result, newCmptOptions);\n  }\n\n  if (isNormalMergeMode || isReplaceMergeMode) {\n    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);\n  } else if (isReplaceAllMode) {\n    mappingInReplaceAllMode(result, newCmptOptions);\n  }\n\n  makeIdAndName(result); // The array `result` MUST NOT contain elided items, otherwise the\n  // forEach will ommit those items and result in incorrect result.\n\n  return result;\n}\n\nfunction prepareResult(existings, existingIdIdxMap, mode) {\n  var result = [];\n\n  if (mode === 'replaceAll') {\n    return result;\n  } // Do not use native `map` to in case that the array `existings`\n  // contains elided items, which will be ommited.\n\n\n  for (var index = 0; index < existings.length; index++) {\n    var existing = existings[index]; // Because of replaceMerge, `existing` may be null/undefined.\n\n    if (existing && existing.id != null) {\n      existingIdIdxMap.set(existing.id, index);\n    } // For non-internal-componnets:\n    //     Mode \"normalMerge\": all existings kept.\n    //     Mode \"replaceMerge\": all existing removed unless mapped by id.\n    // For internal-components:\n    //     go with \"replaceMerge\" approach in both mode.\n\n\n    result.push({\n      existing: mode === 'replaceMerge' || isComponentIdInternal(existing) ? null : existing,\n      newOption: null,\n      keyInfo: null,\n      brandNew: null\n    });\n  }\n\n  return result;\n}\n\nfunction mappingById(result, existings, existingIdIdxMap, newCmptOptions) {\n  // Mapping by id if specified.\n  each(newCmptOptions, function (cmptOption, index) {\n    if (!cmptOption || cmptOption.id == null) {\n      return;\n    }\n\n    var optionId = makeComparableKey(cmptOption.id);\n    var existingIdx = existingIdIdxMap.get(optionId);\n\n    if (existingIdx != null) {\n      var resultItem = result[existingIdx];\n      assert(!resultItem.newOption, 'Duplicated option on id \"' + optionId + '\".');\n      resultItem.newOption = cmptOption; // In both mode, if id matched, new option will be merged to\n      // the existings rather than creating new component model.\n\n      resultItem.existing = existings[existingIdx];\n      newCmptOptions[index] = null;\n    }\n  });\n}\n\nfunction mappingByName(result, newCmptOptions) {\n  // Mapping by name if specified.\n  each(newCmptOptions, function (cmptOption, index) {\n    if (!cmptOption || cmptOption.name == null) {\n      return;\n    }\n\n    for (var i = 0; i < result.length; i++) {\n      var existing = result[i].existing;\n\n      if (!result[i].newOption // Consider name: two map to one.\n      // Can not match when both ids existing but different.\n      && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual('name', existing, cmptOption)) {\n        result[i].newOption = cmptOption;\n        newCmptOptions[index] = null;\n        return;\n      }\n    }\n  });\n}\n\nfunction mappingByIndex(result, newCmptOptions, brandNew) {\n  each(newCmptOptions, function (cmptOption) {\n    if (!cmptOption) {\n      return;\n    } // Find the first place that not mapped by id and not internal component (consider the \"hole\").\n\n\n    var resultItem;\n    var nextIdx = 0;\n\n    while ( // Be `!resultItem` only when `nextIdx >= result.length`.\n    (resultItem = result[nextIdx]) && ( // (1) Existing models that already have id should be able to mapped to. Because\n    // after mapping performed, model will always be assigned with an id if user not given.\n    // After that all models have id.\n    // (2) If new option has id, it can only set to a hole or append to the last. It should\n    // not be merged to the existings with different id. Because id should not be overwritten.\n    // (3) Name can be overwritten, because axis use name as 'show label text'.\n    resultItem.newOption || isComponentIdInternal(resultItem.existing) || // In mode \"replaceMerge\", here no not-mapped-non-internal-existing.\n    resultItem.existing && cmptOption.id != null && !keyExistAndEqual('id', cmptOption, resultItem.existing))) {\n      nextIdx++;\n    }\n\n    if (resultItem) {\n      resultItem.newOption = cmptOption;\n      resultItem.brandNew = brandNew;\n    } else {\n      result.push({\n        newOption: cmptOption,\n        brandNew: brandNew,\n        existing: null,\n        keyInfo: null\n      });\n    }\n\n    nextIdx++;\n  });\n}\n\nfunction mappingInReplaceAllMode(result, newCmptOptions) {\n  each(newCmptOptions, function (cmptOption) {\n    // The feature \"reproduce\" requires \"hole\" will also reproduced\n    // in case that compoennt index referring are broken.\n    result.push({\n      newOption: cmptOption,\n      brandNew: true,\n      existing: null,\n      keyInfo: null\n    });\n  });\n}\n/**\n * Make id and name for mapping result (result of mappingToExists)\n * into `keyInfo` field.\n */\n\n\nfunction makeIdAndName(mapResult) {\n  // We use this id to hash component models and view instances\n  // in echarts. id can be specified by user, or auto generated.\n  // The id generation rule ensures new view instance are able\n  // to mapped to old instance when setOption are called in\n  // no-merge mode. So we generate model id by name and plus\n  // type in view id.\n  // name can be duplicated among components, which is convenient\n  // to specify multi components (like series) by one name.\n  // Ensure that each id is distinct.\n  var idMap = createHashMap();\n  each(mapResult, function (item) {\n    var existing = item.existing;\n    existing && idMap.set(existing.id, item);\n  });\n  each(mapResult, function (item) {\n    var opt = item.newOption; // Force ensure id not duplicated.\n\n    assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));\n    opt && opt.id != null && idMap.set(opt.id, item);\n    !item.keyInfo && (item.keyInfo = {});\n  }); // Make name and id.\n\n  each(mapResult, function (item, index) {\n    var existing = item.existing;\n    var opt = item.newOption;\n    var keyInfo = item.keyInfo;\n\n    if (!isObject(opt)) {\n      return;\n    } // name can be overwitten. Consider case: axis.name = '20km'.\n    // But id generated by name will not be changed, which affect\n    // only in that case: setOption with 'not merge mode' and view\n    // instance will be recreated, which can be accepted.\n\n\n    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name // Avoid diffferent series has the same name,\n    // because name may be used like in color pallet.\n    : DUMMY_COMPONENT_NAME_PREFIX + index;\n\n    if (existing) {\n      keyInfo.id = makeComparableKey(existing.id);\n    } else if (opt.id != null) {\n      keyInfo.id = makeComparableKey(opt.id);\n    } else {\n      // Consider this situatoin:\n      //  optionA: [{name: 'a'}, {name: 'a'}, {..}]\n      //  optionB [{..}, {name: 'a'}, {name: 'a'}]\n      // Series with the same name between optionA and optionB\n      // should be mapped.\n      var idNum = 0;\n\n      do {\n        keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n      } while (idMap.get(keyInfo.id));\n    }\n\n    idMap.set(keyInfo.id, item);\n  });\n}\n\nfunction keyExistAndEqual(attr, obj1, obj2) {\n  var key1 = convertOptionIdName(obj1[attr], null);\n  var key2 = convertOptionIdName(obj2[attr], null); // See `MappingExistingItem`. `id` and `name` trade string equals to number.\n\n  return key1 != null && key2 != null && key1 === key2;\n}\n/**\n * @return return null if not exist.\n */\n\n\nfunction makeComparableKey(val) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (val == null) {\n      throw new Error();\n    }\n  }\n\n  return convertOptionIdName(val, '');\n}\n\nexport function convertOptionIdName(idOrName, defaultValue) {\n  if (idOrName == null) {\n    return defaultValue;\n  }\n\n  var type = typeof idOrName;\n  return type === 'string' ? idOrName : type === 'number' || isStringSafe(idOrName) ? idOrName + '' : defaultValue;\n}\n\nfunction warnInvalidateIdOrName(idOrName) {\n  if (process.env.NODE_ENV !== 'production') {\n    warn('`' + idOrName + '` is invalid id or name. Must be a string or number.');\n  }\n}\n\nfunction isValidIdOrName(idOrName) {\n  return isStringSafe(idOrName) || isNumeric(idOrName);\n}\n\nexport function isNameSpecified(componentModel) {\n  var name = componentModel.name; // Is specified when `indexOf` get -1 or > 0.\n\n  return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));\n}\n/**\n * @public\n * @param {Object} cmptOption\n * @return {boolean}\n */\n\nexport function isComponentIdInternal(cmptOption) {\n  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;\n}\nexport function makeInternalComponentId(idSuffix) {\n  return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;\n}\nexport function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {\n  // Set mainType and complete subType.\n  each(mappingResult, function (item) {\n    var newOption = item.newOption;\n\n    if (isObject(newOption)) {\n      item.keyInfo.mainType = mainType;\n      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);\n    }\n  });\n}\n\nfunction determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {\n  var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\n  : componentModelCtor.determineSubType(mainType, newCmptOption); // tooltip, markline, markpoint may always has no subType\n\n  return subType;\n}\n/**\n * A helper for removing duplicate items between batchA and batchB,\n * and in themselves, and categorize by series.\n *\n * @param batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @param batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]\n * @return result: [resultBatchA, resultBatchB]\n */\n\n\nexport function compressBatches(batchA, batchB) {\n  var mapA = {};\n  var mapB = {};\n  makeMap(batchA || [], mapA);\n  makeMap(batchB || [], mapB, mapA);\n  return [mapToArray(mapA), mapToArray(mapB)];\n\n  function makeMap(sourceBatch, map, otherMap) {\n    for (var i = 0, len = sourceBatch.length; i < len; i++) {\n      var seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);\n\n      if (seriesId == null) {\n        return;\n      }\n\n      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);\n      var otherDataIndices = otherMap && otherMap[seriesId];\n\n      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n        var dataIndex = dataIndices[j];\n\n        if (otherDataIndices && otherDataIndices[dataIndex]) {\n          otherDataIndices[dataIndex] = null;\n        } else {\n          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n        }\n      }\n    }\n  }\n\n  function mapToArray(map, isData) {\n    var result = [];\n\n    for (var i in map) {\n      if (map.hasOwnProperty(i) && map[i] != null) {\n        if (isData) {\n          result.push(+i);\n        } else {\n          var dataIndices = mapToArray(map[i], true);\n          dataIndices.length && result.push({\n            seriesId: i,\n            dataIndex: dataIndices\n          });\n        }\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * @param payload Contains dataIndex (means rawIndex) / dataIndexInside / name\n *                         each of which can be Array or primary type.\n * @return dataIndex If not found, return undefined/null.\n */\n\nexport function queryDataIndex(data, payload) {\n  if (payload.dataIndexInside != null) {\n    return payload.dataIndexInside;\n  } else if (payload.dataIndex != null) {\n    return isArray(payload.dataIndex) ? map(payload.dataIndex, function (value) {\n      return data.indexOfRawIndex(value);\n    }) : data.indexOfRawIndex(payload.dataIndex);\n  } else if (payload.name != null) {\n    return isArray(payload.name) ? map(payload.name, function (value) {\n      return data.indexOfName(value);\n    }) : data.indexOfName(payload.name);\n  }\n}\n/**\n * Enable property storage to any host object.\n * Notice: Serialization is not supported.\n *\n * For example:\n * let inner = zrUitl.makeInner();\n *\n * function some1(hostObj) {\n *      inner(hostObj).someProperty = 1212;\n *      ...\n * }\n * function some2() {\n *      let fields = inner(this);\n *      fields.someProperty1 = 1212;\n *      fields.someProperty2 = 'xx';\n *      ...\n * }\n *\n * @return {Function}\n */\n\nexport function makeInner() {\n  var key = '__ec_inner_' + innerUniqueIndex++;\n  return function (hostObj) {\n    return hostObj[key] || (hostObj[key] = {});\n  };\n}\nvar innerUniqueIndex = getRandomIdBase();\n/**\n * The same behavior as `component.getReferringComponents`.\n */\n\nexport function parseFinder(ecModel, finderInput, opt) {\n  var _a = preParseFinder(finderInput, opt),\n      mainTypeSpecified = _a.mainTypeSpecified,\n      queryOptionMap = _a.queryOptionMap,\n      others = _a.others;\n\n  var result = others;\n  var defaultMainType = opt ? opt.defaultMainType : null;\n\n  if (!mainTypeSpecified && defaultMainType) {\n    queryOptionMap.set(defaultMainType, {});\n  }\n\n  queryOptionMap.each(function (queryOption, mainType) {\n    var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {\n      useDefault: defaultMainType === mainType,\n      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,\n      enableNone: opt && opt.enableNone != null ? opt.enableNone : true\n    });\n    result[mainType + 'Models'] = queryResult.models;\n    result[mainType + 'Model'] = queryResult.models[0];\n  });\n  return result;\n}\nexport function preParseFinder(finderInput, opt) {\n  var finder;\n\n  if (isString(finderInput)) {\n    var obj = {};\n    obj[finderInput + 'Index'] = 0;\n    finder = obj;\n  } else {\n    finder = finderInput;\n  }\n\n  var queryOptionMap = createHashMap();\n  var others = {};\n  var mainTypeSpecified = false;\n  each(finder, function (value, key) {\n    // Exclude 'dataIndex' and other illgal keys.\n    if (key === 'dataIndex' || key === 'dataIndexInside') {\n      others[key] = value;\n      return;\n    }\n\n    var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n    var mainType = parsedKey[1];\n    var queryType = (parsedKey[2] || '').toLowerCase();\n\n    if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {\n      return;\n    }\n\n    mainTypeSpecified = mainTypeSpecified || !!mainType;\n    var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});\n    queryOption[queryType] = value;\n  });\n  return {\n    mainTypeSpecified: mainTypeSpecified,\n    queryOptionMap: queryOptionMap,\n    others: others\n  };\n}\nexport var SINGLE_REFERRING = {\n  useDefault: true,\n  enableAll: false,\n  enableNone: false\n};\nexport var MULTIPLE_REFERRING = {\n  useDefault: false,\n  enableAll: true,\n  enableNone: true\n};\nexport function queryReferringComponents(ecModel, mainType, userOption, opt) {\n  opt = opt || SINGLE_REFERRING;\n  var indexOption = userOption.index;\n  var idOption = userOption.id;\n  var nameOption = userOption.name;\n  var result = {\n    models: null,\n    specified: indexOption != null || idOption != null || nameOption != null\n  };\n\n  if (!result.specified) {\n    // Use the first as default if `useDefault`.\n    var firstCmpt = void 0;\n    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];\n    return result;\n  }\n\n  if (indexOption === 'none' || indexOption === false) {\n    assert(opt.enableNone, '`\"none\"` or `false` is not a valid value on index option.');\n    result.models = [];\n    return result;\n  } // `queryComponents` will return all components if\n  // both all of index/id/name are null/undefined.\n\n\n  if (indexOption === 'all') {\n    assert(opt.enableAll, '`\"all\"` is not a valid value on index option.');\n    indexOption = idOption = nameOption = null;\n  }\n\n  result.models = ecModel.queryComponents({\n    mainType: mainType,\n    index: indexOption,\n    id: idOption,\n    name: nameOption\n  });\n  return result;\n}\nexport function setAttribute(dom, key, value) {\n  dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;\n}\nexport function getAttribute(dom, key) {\n  return dom.getAttribute ? dom.getAttribute(key) : dom[key];\n}\nexport function getTooltipRenderMode(renderModeOption) {\n  if (renderModeOption === 'auto') {\n    // Using html when `document` exists, use richText otherwise\n    return env.domSupported ? 'html' : 'richText';\n  } else {\n    return renderModeOption || 'html';\n  }\n}\n/**\n * Group a list by key.\n */\n\nexport function groupData(array, getKey // return key\n) {\n  var buckets = createHashMap();\n  var keys = [];\n  each(array, function (item) {\n    var key = getKey(item);\n    (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item);\n  });\n  return {\n    keys: keys,\n    buckets: buckets\n  };\n}\n/**\n * Interpolate raw values of a series with percent\n *\n * @param data         data\n * @param labelModel   label model of the text element\n * @param sourceValue  start value. May be null/undefined when init.\n * @param targetValue  end value\n * @param percent      0~1 percentage; 0 uses start value while 1 uses end value\n * @return             interpolated values\n *                     If `sourceValue` and `targetValue` are `number`, return `number`.\n *                     If `sourceValue` and `targetValue` are `string`, return `string`.\n *                     If `sourceValue` and `targetValue` are `(string | number)[]`, return `(string | number)[]`.\n *                     Other cases do not supported.\n */\n\nexport function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {\n  var isAutoPrecision = precision == null || precision === 'auto';\n\n  if (targetValue == null) {\n    return targetValue;\n  }\n\n  if (typeof targetValue === 'number') {\n    var value = interpolateNumber(sourceValue || 0, targetValue, percent);\n    return round(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);\n  } else if (typeof targetValue === 'string') {\n    return percent < 1 ? sourceValue : targetValue;\n  } else {\n    var interpolated = [];\n    var leftArr = sourceValue;\n    var rightArr = targetValue;\n    var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);\n\n    for (var i = 0; i < length_1; ++i) {\n      var info = data.getDimensionInfo(i); // Don't interpolate ordinal dims\n\n      if (info && info.type === 'ordinal') {\n        // In init, there is no `sourceValue`, but should better not to get undefined result.\n        interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];\n      } else {\n        var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;\n        var rightVal = rightArr[i];\n        var value = interpolateNumber(leftVal, rightVal, percent);\n        interpolated[i] = round(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);\n      }\n    }\n\n    return interpolated;\n  }\n}"]},"metadata":{},"sourceType":"module"}