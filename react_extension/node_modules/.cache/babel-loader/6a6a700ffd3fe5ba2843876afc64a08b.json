{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\n\nimport * as zrUtil from 'zrender/lib/core/util';\nimport * as graphic from '../../util/graphic';\nimport * as layoutUtil from '../../util/layout';\nimport LegendView from './LegendView';\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\n\nvar ScrollableLegendView =\n/** @class */\nfunction (_super) {\n  __extends(ScrollableLegendView, _super);\n\n  function ScrollableLegendView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = ScrollableLegendView.type;\n    _this.newlineDisabled = true;\n    _this._currentIndex = 0;\n    return _this;\n  }\n\n  ScrollableLegendView.prototype.init = function () {\n    _super.prototype.init.call(this);\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n\n    this.group.add(this._controllerGroup = new Group());\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.resetInner = function () {\n    _super.prototype.resetInner.call(this);\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {\n    var self = this; // Render content items.\n\n    _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);\n\n    var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,\n    // e.g., '3/12345' should not overlap with the control arrow button.\n\n    var pageIconSize = legendModel.get('pageIconSize', true);\n    var pageIconSizeArr = zrUtil.isArray(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        // Placeholder to calculate a proper layout.\n        text: 'xx/xx',\n        fill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        verticalAlign: 'middle',\n        align: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(self._pageGo, self, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSizeArr[0] / 2,\n        y: -pageIconSizeArr[1] / 2,\n        width: pageIconSizeArr[0],\n        height: pageIconSizeArr[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {\n    var selectorGroup = this.getSelectorGroup();\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx];\n    selector && layoutUtil.box( // Buttons in selectorGroup always layout horizontally\n    'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));\n    var selectorButtonGap = legendModel.get('selectorButtonGap', true);\n    var selectorRect = selectorGroup.getBoundingRect();\n    var selectorPos = [-selectorRect.x, -selectorRect.y];\n    var processMaxSize = zrUtil.clone(maxSize);\n    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);\n\n    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);\n\n    if (selector) {\n      if (selectorPosition === 'end') {\n        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;\n      } else {\n        var offset = selectorRect[wh] + selectorButtonGap;\n        selectorPos[orientIdx] -= offset;\n        mainRect[xy] -= offset;\n      }\n\n      mainRect[wh] += selectorRect[wh] + selectorButtonGap;\n      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;\n      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);\n      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);\n      selectorGroup.x = selectorPos[0];\n      selectorGroup.y = selectorPos[1];\n      selectorGroup.markRedraw();\n    }\n\n    return mainRect;\n  };\n\n  ScrollableLegendView.prototype._layoutContentAndController = function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh]; // In case that the inner elements of contentGroup layout do not based on [0, 0]\n\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n    // If first rendering, `contentGroup.position` is [0, 0], which\n    // does not make sense and may cause unexepcted animation if adopted.\n\n    if (!isFirstRender) {\n      contentPos[orientIdx] = contentGroup[xy];\n    } // Layout container group based on 0.\n\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n        containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n      }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.setPosition(contentPos);\n    containerGroup.setPosition(containerPos);\n    controllerGroup.setPosition(controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as placeholders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      x: pageInfo.contentPosition[0],\n      y: pageInfo.contentPosition[1]\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird effect.\n    showController ? legendModel : null);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  };\n\n  ScrollableLegendView.prototype._pageGo = function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  };\n\n  ScrollableLegendView.prototype._updatePageInfoView = function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var key = name + 'DataIndex';\n      var canJump = pageInfo[key] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current == null ? '' : current + '').replace('{total}', total == null ? '' : total + '') : pageFormatter({\n      current: current,\n      total: total\n    }));\n  };\n  /**\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no previous page.\n   *  pageNextDataIndex: number, null when no next page.\n   * }\n   */\n\n\n  ScrollableLegendView.prototype._getPageInfo = function (legendModel) {\n    var scrollDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n\n    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);\n\n    var children = contentGroup.children();\n    var targetItem = children[targetItemIndex];\n    var itemCount = children.length;\n    var pCount = !itemCount ? 0 : 1;\n    var result = {\n      contentPosition: [contentGroup.x, contentGroup.y],\n      pageCount: pCount,\n      pageIndex: pCount - 1,\n      pagePrevDataIndex: null,\n      pageNextDataIndex: null\n    };\n\n    if (!targetItem) {\n      return result;\n    }\n\n    var targetItemInfo = getItemInfo(targetItem);\n    result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:\n    // (1) Always align based on the left/top most item.\n    // (2) It is user-friendly that the last item shown in the\n    // current window is shown at the begining of next window.\n    // Otherwise if half of the last item is cut by the window,\n    // it will have no chance to display entirely.\n    // (3) Consider that item size probably be different, we\n    // have calculate pageIndex by size rather than item index,\n    // and we can not get page index directly by division.\n    // (4) The window is to narrow to contain more than\n    // one item, we should make sure that the page can be fliped.\n\n    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // Half of the last item is out of the window.\n      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page\n      // can be started at the current item or the last item.\n      currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {\n        if (winEndItemInfo.i > winStartItemInfo.i) {\n          winStartItemInfo = winEndItemInfo;\n        } else {\n          // e.g., when page size is smaller than item size.\n          winStartItemInfo = currItemInfo;\n        }\n\n        if (winStartItemInfo) {\n          if (result.pageNextDataIndex == null) {\n            result.pageNextDataIndex = winStartItemInfo.i;\n          }\n\n          ++result.pageCount;\n        }\n      }\n\n      winEndItemInfo = currItemInfo;\n    }\n\n    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // If the the end item does not intersect with the window started\n      // from the current item, a page can be settled.\n      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.\n      winStartItemInfo.i < winEndItemInfo.i) {\n        winEndItemInfo = winStartItemInfo;\n\n        if (result.pagePrevDataIndex == null) {\n          result.pagePrevDataIndex = winStartItemInfo.i;\n        }\n\n        ++result.pageCount;\n        ++result.pageIndex;\n      }\n\n      winStartItemInfo = currItemInfo;\n    }\n\n    return result;\n\n    function getItemInfo(el) {\n      if (el) {\n        var itemRect = el.getBoundingRect();\n        var start = itemRect[xy] + el[xy];\n        return {\n          s: start,\n          e: start + itemRect[wh],\n          i: el.__legendDataIndex\n        };\n      }\n    }\n\n    function intersect(itemInfo, winStart) {\n      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;\n    }\n  };\n\n  ScrollableLegendView.prototype._findTargetItemIndex = function (targetDataIndex) {\n    if (!this._showController) {\n      return 0;\n    }\n\n    var index;\n    var contentGroup = this.getContentGroup();\n    var defaultIndex;\n    contentGroup.eachChild(function (child, idx) {\n      var legendDataIdx = child.__legendDataIndex; // FIXME\n      // If the given targetDataIndex (from model) is illegal,\n      // we use defaultIndex. But the index on the legend model and\n      // action payload is still illegal. That case will not be\n      // changed until some scenario requires.\n\n      if (defaultIndex == null && legendDataIdx != null) {\n        defaultIndex = idx;\n      }\n\n      if (legendDataIdx === targetDataIndex) {\n        index = idx;\n      }\n    });\n    return index != null ? index : defaultIndex;\n  };\n\n  ScrollableLegendView.type = 'legend.scroll';\n  return ScrollableLegendView;\n}(LegendView);\n\nexport default ScrollableLegendView;","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/component/legend/ScrollableLegendView.js"],"names":["__extends","zrUtil","graphic","layoutUtil","LegendView","Group","WH","XY","ScrollableLegendView","_super","_this","apply","arguments","type","newlineDisabled","_currentIndex","prototype","init","call","group","add","_containerGroup","getContentGroup","_controllerGroup","resetInner","removeAll","removeClipPath","__rectSize","renderInner","itemAlign","legendModel","ecModel","api","selector","orient","selectorPosition","self","controllerGroup","pageIconSize","get","pageIconSizeArr","isArray","createPageButton","pageTextStyleModel","getModel","Text","name","style","text","fill","getTextColor","font","getFont","verticalAlign","align","silent","iconIdx","pageDataIndexName","icon","createIcon","getOrient","onclick","bind","_pageGo","x","y","width","height","layoutInner","maxSize","isFirstRender","selectorGroup","getSelectorGroup","orientIdx","index","wh","xy","hw","yx","box","selectorButtonGap","selectorRect","getBoundingRect","selectorPos","processMaxSize","clone","mainRect","_layoutContentAndController","offset","Math","max","min","markRedraw","contentGroup","containerGroup","contentRect","controllerRect","showController","_showController","contentPos","containerPos","controllerPos","pageButtonGap","retrieve2","pageButtonPosition","setPosition","clipShape","setClipPath","Rect","shape","eachChild","child","attr","invisible","pageInfo","_getPageInfo","pageIndex","updateProps","contentPosition","_updatePageInfoView","to","scrollDataIndex","dispatchAction","legendId","id","each","key","canJump","childOfName","setStyle","cursor","pageText","pageFormatter","current","total","pageCount","isString","replace","containerRectSize","targetItemIndex","_findTargetItemIndex","children","targetItem","itemCount","length","pCount","result","pagePrevDataIndex","pageNextDataIndex","targetItemInfo","getItemInfo","s","i","winStartItemInfo","winEndItemInfo","currItemInfo","e","intersect","el","itemRect","start","__legendDataIndex","itemInfo","winStart","targetDataIndex","defaultIndex","idx","legendDataIdx"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\n/**\n * Separate legend and scrollable legend to reduce package size.\n */\n\nimport * as zrUtil from 'zrender/lib/core/util';\nimport * as graphic from '../../util/graphic';\nimport * as layoutUtil from '../../util/layout';\nimport LegendView from './LegendView';\nvar Group = graphic.Group;\nvar WH = ['width', 'height'];\nvar XY = ['x', 'y'];\n\nvar ScrollableLegendView =\n/** @class */\nfunction (_super) {\n  __extends(ScrollableLegendView, _super);\n\n  function ScrollableLegendView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = ScrollableLegendView.type;\n    _this.newlineDisabled = true;\n    _this._currentIndex = 0;\n    return _this;\n  }\n\n  ScrollableLegendView.prototype.init = function () {\n    _super.prototype.init.call(this);\n\n    this.group.add(this._containerGroup = new Group());\n\n    this._containerGroup.add(this.getContentGroup());\n\n    this.group.add(this._controllerGroup = new Group());\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.resetInner = function () {\n    _super.prototype.resetInner.call(this);\n\n    this._controllerGroup.removeAll();\n\n    this._containerGroup.removeClipPath();\n\n    this._containerGroup.__rectSize = null;\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {\n    var self = this; // Render content items.\n\n    _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);\n\n    var controllerGroup = this._controllerGroup; // FIXME: support be 'auto' adapt to size number text length,\n    // e.g., '3/12345' should not overlap with the control arrow button.\n\n    var pageIconSize = legendModel.get('pageIconSize', true);\n    var pageIconSizeArr = zrUtil.isArray(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];\n    createPageButton('pagePrev', 0);\n    var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n    controllerGroup.add(new graphic.Text({\n      name: 'pageText',\n      style: {\n        // Placeholder to calculate a proper layout.\n        text: 'xx/xx',\n        fill: pageTextStyleModel.getTextColor(),\n        font: pageTextStyleModel.getFont(),\n        verticalAlign: 'middle',\n        align: 'center'\n      },\n      silent: true\n    }));\n    createPageButton('pageNext', 1);\n\n    function createPageButton(name, iconIdx) {\n      var pageDataIndexName = name + 'DataIndex';\n      var icon = graphic.createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n        // Buttons will be created in each render, so we do not need\n        // to worry about avoiding using legendModel kept in scope.\n        onclick: zrUtil.bind(self._pageGo, self, pageDataIndexName, legendModel, api)\n      }, {\n        x: -pageIconSizeArr[0] / 2,\n        y: -pageIconSizeArr[1] / 2,\n        width: pageIconSizeArr[0],\n        height: pageIconSizeArr[1]\n      });\n      icon.name = name;\n      controllerGroup.add(icon);\n    }\n  };\n  /**\n   * @override\n   */\n\n\n  ScrollableLegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {\n    var selectorGroup = this.getSelectorGroup();\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n    var hw = WH[1 - orientIdx];\n    var yx = XY[1 - orientIdx];\n    selector && layoutUtil.box( // Buttons in selectorGroup always layout horizontally\n    'horizontal', selectorGroup, legendModel.get('selectorItemGap', true));\n    var selectorButtonGap = legendModel.get('selectorButtonGap', true);\n    var selectorRect = selectorGroup.getBoundingRect();\n    var selectorPos = [-selectorRect.x, -selectorRect.y];\n    var processMaxSize = zrUtil.clone(maxSize);\n    selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);\n\n    var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);\n\n    if (selector) {\n      if (selectorPosition === 'end') {\n        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;\n      } else {\n        var offset = selectorRect[wh] + selectorButtonGap;\n        selectorPos[orientIdx] -= offset;\n        mainRect[xy] -= offset;\n      }\n\n      mainRect[wh] += selectorRect[wh] + selectorButtonGap;\n      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;\n      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);\n      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);\n      selectorGroup.x = selectorPos[0];\n      selectorGroup.y = selectorPos[1];\n      selectorGroup.markRedraw();\n    }\n\n    return mainRect;\n  };\n\n  ScrollableLegendView.prototype._layoutContentAndController = function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {\n    var contentGroup = this.getContentGroup();\n    var containerGroup = this._containerGroup;\n    var controllerGroup = this._controllerGroup; // Place items in contentGroup.\n\n    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n    layoutUtil.box( // Buttons in controller are layout always horizontally.\n    'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n    var contentRect = contentGroup.getBoundingRect();\n    var controllerRect = controllerGroup.getBoundingRect();\n    var showController = this._showController = contentRect[wh] > maxSize[wh]; // In case that the inner elements of contentGroup layout do not based on [0, 0]\n\n    var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming.\n    // If first rendering, `contentGroup.position` is [0, 0], which\n    // does not make sense and may cause unexepcted animation if adopted.\n\n    if (!isFirstRender) {\n      contentPos[orientIdx] = contentGroup[xy];\n    } // Layout container group based on 0.\n\n\n    var containerPos = [0, 0];\n    var controllerPos = [-controllerRect.x, -controllerRect.y];\n    var pageButtonGap = zrUtil.retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)); // Place containerGroup and controllerGroup and contentGroup.\n\n    if (showController) {\n      var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom.\n\n      if (pageButtonPosition === 'end') {\n        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n      } // controller is on the left / top.\n      else {\n          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n        }\n    } // Always align controller to content as 'middle'.\n\n\n    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n    contentGroup.setPosition(contentPos);\n    containerGroup.setPosition(containerPos);\n    controllerGroup.setPosition(controllerPos); // Calculate `mainRect` and set `clipPath`.\n    // mainRect should not be calculated by `this.group.getBoundingRect()`\n    // for sake of the overflow.\n\n    var mainRect = {\n      x: 0,\n      y: 0\n    }; // Consider content may be overflow (should be clipped).\n\n    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.\n\n    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n    containerGroup.__rectSize = maxSize[wh];\n\n    if (showController) {\n      var clipShape = {\n        x: 0,\n        y: 0\n      };\n      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n      clipShape[hw] = mainRect[hw];\n      containerGroup.setClipPath(new graphic.Rect({\n        shape: clipShape\n      })); // Consider content may be larger than container, container rect\n      // can not be obtained from `containerGroup.getBoundingRect()`.\n\n      containerGroup.__rectSize = clipShape[wh];\n    } else {\n      // Do not remove or ignore controller. Keep them set as placeholders.\n      controllerGroup.eachChild(function (child) {\n        child.attr({\n          invisible: true,\n          silent: true\n        });\n      });\n    } // Content translate animation.\n\n\n    var pageInfo = this._getPageInfo(legendModel);\n\n    pageInfo.pageIndex != null && graphic.updateProps(contentGroup, {\n      x: pageInfo.contentPosition[0],\n      y: pageInfo.contentPosition[1]\n    }, // When switch from \"show controller\" to \"not show controller\", view should be\n    // updated immediately without animation, otherwise causes weird effect.\n    showController ? legendModel : null);\n\n    this._updatePageInfoView(legendModel, pageInfo);\n\n    return mainRect;\n  };\n\n  ScrollableLegendView.prototype._pageGo = function (to, legendModel, api) {\n    var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n    scrollDataIndex != null && api.dispatchAction({\n      type: 'legendScroll',\n      scrollDataIndex: scrollDataIndex,\n      legendId: legendModel.id\n    });\n  };\n\n  ScrollableLegendView.prototype._updatePageInfoView = function (legendModel, pageInfo) {\n    var controllerGroup = this._controllerGroup;\n    zrUtil.each(['pagePrev', 'pageNext'], function (name) {\n      var key = name + 'DataIndex';\n      var canJump = pageInfo[key] != null;\n      var icon = controllerGroup.childOfName(name);\n\n      if (icon) {\n        icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n        icon.cursor = canJump ? 'pointer' : 'default';\n      }\n    });\n    var pageText = controllerGroup.childOfName('pageText');\n    var pageFormatter = legendModel.get('pageFormatter');\n    var pageIndex = pageInfo.pageIndex;\n    var current = pageIndex != null ? pageIndex + 1 : 0;\n    var total = pageInfo.pageCount;\n    pageText && pageFormatter && pageText.setStyle('text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current == null ? '' : current + '').replace('{total}', total == null ? '' : total + '') : pageFormatter({\n      current: current,\n      total: total\n    }));\n  };\n  /**\n   *  contentPosition: Array.<number>, null when data item not found.\n   *  pageIndex: number, null when data item not found.\n   *  pageCount: number, always be a number, can be 0.\n   *  pagePrevDataIndex: number, null when no previous page.\n   *  pageNextDataIndex: number, null when no next page.\n   * }\n   */\n\n\n  ScrollableLegendView.prototype._getPageInfo = function (legendModel) {\n    var scrollDataIndex = legendModel.get('scrollDataIndex', true);\n    var contentGroup = this.getContentGroup();\n    var containerRectSize = this._containerGroup.__rectSize;\n    var orientIdx = legendModel.getOrient().index;\n    var wh = WH[orientIdx];\n    var xy = XY[orientIdx];\n\n    var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);\n\n    var children = contentGroup.children();\n    var targetItem = children[targetItemIndex];\n    var itemCount = children.length;\n    var pCount = !itemCount ? 0 : 1;\n    var result = {\n      contentPosition: [contentGroup.x, contentGroup.y],\n      pageCount: pCount,\n      pageIndex: pCount - 1,\n      pagePrevDataIndex: null,\n      pageNextDataIndex: null\n    };\n\n    if (!targetItem) {\n      return result;\n    }\n\n    var targetItemInfo = getItemInfo(targetItem);\n    result.contentPosition[orientIdx] = -targetItemInfo.s; // Strategy:\n    // (1) Always align based on the left/top most item.\n    // (2) It is user-friendly that the last item shown in the\n    // current window is shown at the begining of next window.\n    // Otherwise if half of the last item is cut by the window,\n    // it will have no chance to display entirely.\n    // (3) Consider that item size probably be different, we\n    // have calculate pageIndex by size rather than item index,\n    // and we can not get page index directly by division.\n    // (4) The window is to narrow to contain more than\n    // one item, we should make sure that the page can be fliped.\n\n    for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // Half of the last item is out of the window.\n      !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page\n      // can be started at the current item or the last item.\n      currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {\n        if (winEndItemInfo.i > winStartItemInfo.i) {\n          winStartItemInfo = winEndItemInfo;\n        } else {\n          // e.g., when page size is smaller than item size.\n          winStartItemInfo = currItemInfo;\n        }\n\n        if (winStartItemInfo) {\n          if (result.pageNextDataIndex == null) {\n            result.pageNextDataIndex = winStartItemInfo.i;\n          }\n\n          ++result.pageCount;\n        }\n      }\n\n      winEndItemInfo = currItemInfo;\n    }\n\n    for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {\n      currItemInfo = getItemInfo(children[i]);\n\n      if ( // If the the end item does not intersect with the window started\n      // from the current item, a page can be settled.\n      (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.\n      winStartItemInfo.i < winEndItemInfo.i) {\n        winEndItemInfo = winStartItemInfo;\n\n        if (result.pagePrevDataIndex == null) {\n          result.pagePrevDataIndex = winStartItemInfo.i;\n        }\n\n        ++result.pageCount;\n        ++result.pageIndex;\n      }\n\n      winStartItemInfo = currItemInfo;\n    }\n\n    return result;\n\n    function getItemInfo(el) {\n      if (el) {\n        var itemRect = el.getBoundingRect();\n        var start = itemRect[xy] + el[xy];\n        return {\n          s: start,\n          e: start + itemRect[wh],\n          i: el.__legendDataIndex\n        };\n      }\n    }\n\n    function intersect(itemInfo, winStart) {\n      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;\n    }\n  };\n\n  ScrollableLegendView.prototype._findTargetItemIndex = function (targetDataIndex) {\n    if (!this._showController) {\n      return 0;\n    }\n\n    var index;\n    var contentGroup = this.getContentGroup();\n    var defaultIndex;\n    contentGroup.eachChild(function (child, idx) {\n      var legendDataIdx = child.__legendDataIndex; // FIXME\n      // If the given targetDataIndex (from model) is illegal,\n      // we use defaultIndex. But the index on the legend model and\n      // action payload is still illegal. That case will not be\n      // changed until some scenario requires.\n\n      if (defaultIndex == null && legendDataIdx != null) {\n        defaultIndex = idx;\n      }\n\n      if (legendDataIdx === targetDataIndex) {\n        index = idx;\n      }\n    });\n    return index != null ? index : defaultIndex;\n  };\n\n  ScrollableLegendView.type = 'legend.scroll';\n  return ScrollableLegendView;\n}(LegendView);\n\nexport default ScrollableLegendView;"]},"metadata":{},"sourceType":"module"}