{"ast":null,"code":"import { fromPoints } from '../core/bbox';\nimport BoundingRect from '../core/BoundingRect';\nimport Point from '../core/Point';\nimport { map } from '../core/util';\nimport Polygon from '../graphic/shape/Polygon';\nimport Rect from '../graphic/shape/Rect';\nimport Sector from '../graphic/shape/Sector';\nimport { pathToPolygons } from './convertPath';\nimport { clonePath } from './path';\n\nfunction getDividingGrids(dimSize, rowDim, count) {\n  var rowSize = dimSize[rowDim];\n  var columnSize = dimSize[1 - rowDim];\n  var ratio = Math.abs(rowSize / columnSize);\n  var rowCount = Math.ceil(Math.sqrt(ratio * count));\n  var columnCount = Math.floor(count / rowCount);\n\n  if (columnCount === 0) {\n    columnCount = 1;\n    rowCount = count;\n  }\n\n  var grids = [];\n\n  for (var i = 0; i < rowCount; i++) {\n    grids.push(columnCount);\n  }\n\n  var currentCount = rowCount * columnCount;\n  var remained = count - currentCount;\n\n  if (remained > 0) {\n    for (var i = 0; i < remained; i++) {\n      grids[i % rowCount] += 1;\n    }\n  }\n\n  return grids;\n}\n\nfunction divideSector(sectorShape, count, outShapes) {\n  var r0 = sectorShape.r0;\n  var r = sectorShape.r;\n  var startAngle = sectorShape.startAngle;\n  var endAngle = sectorShape.endAngle;\n  var angle = Math.abs(endAngle - startAngle);\n  var arcLen = angle * r;\n  var deltaR = r - r0;\n  var isAngleRow = arcLen > Math.abs(deltaR);\n  var grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count);\n  var rowSize = (isAngleRow ? angle : deltaR) / grids.length;\n\n  for (var row = 0; row < grids.length; row++) {\n    var columnSize = (isAngleRow ? deltaR : angle) / grids[row];\n\n    for (var column = 0; column < grids[row]; column++) {\n      var newShape = {};\n\n      if (isAngleRow) {\n        newShape.startAngle = startAngle + rowSize * row;\n        newShape.endAngle = startAngle + rowSize * (row + 1);\n        newShape.r0 = r0 + columnSize * column;\n        newShape.r = r0 + columnSize * (column + 1);\n      } else {\n        newShape.startAngle = startAngle + columnSize * column;\n        newShape.endAngle = startAngle + columnSize * (column + 1);\n        newShape.r0 = r0 + rowSize * row;\n        newShape.r = r0 + rowSize * (row + 1);\n      }\n\n      newShape.clockwise = sectorShape.clockwise;\n      newShape.cx = sectorShape.cx;\n      newShape.cy = sectorShape.cy;\n      outShapes.push(newShape);\n    }\n  }\n}\n\nfunction divideRect(rectShape, count, outShapes) {\n  var width = rectShape.width;\n  var height = rectShape.height;\n  var isHorizontalRow = width > height;\n  var grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count);\n  var rowSizeDim = isHorizontalRow ? 'width' : 'height';\n  var columnSizeDim = isHorizontalRow ? 'height' : 'width';\n  var rowDim = isHorizontalRow ? 'x' : 'y';\n  var columnDim = isHorizontalRow ? 'y' : 'x';\n  var rowSize = rectShape[rowSizeDim] / grids.length;\n\n  for (var row = 0; row < grids.length; row++) {\n    var columnSize = rectShape[columnSizeDim] / grids[row];\n\n    for (var column = 0; column < grids[row]; column++) {\n      var newShape = {};\n      newShape[rowDim] = row * rowSize;\n      newShape[columnDim] = column * columnSize;\n      newShape[rowSizeDim] = rowSize;\n      newShape[columnSizeDim] = columnSize;\n      newShape.x += rectShape.x;\n      newShape.y += rectShape.y;\n      outShapes.push(newShape);\n    }\n  }\n}\n\nfunction crossProduct2d(x1, y1, x2, y2) {\n  return x1 * y2 - x2 * y1;\n}\n\nfunction lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n  var mx = a2x - a1x;\n  var my = a2y - a1y;\n  var nx = b2x - b1x;\n  var ny = b2y - b1y;\n  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n\n  if (Math.abs(nmCrossProduct) < 1e-6) {\n    return null;\n  }\n\n  var b1a1x = a1x - b1x;\n  var b1a1y = a1y - b1y;\n  var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n\n  if (p < 0 || p > 1) {\n    return null;\n  }\n\n  return new Point(p * mx + a1x, p * my + a1y);\n}\n\nfunction projPtOnLine(pt, lineA, lineB) {\n  var dir = new Point();\n  Point.sub(dir, lineB, lineA);\n  dir.normalize();\n  var dir2 = new Point();\n  Point.sub(dir2, pt, lineA);\n  var len = dir2.dot(dir);\n  return len;\n}\n\nfunction addToPoly(poly, pt) {\n  var last = poly[poly.length - 1];\n\n  if (last && last[0] === pt[0] && last[1] === pt[1]) {\n    return;\n  }\n\n  poly.push(pt);\n}\n\nfunction splitPolygonByLine(points, lineA, lineB) {\n  var len = points.length;\n  var intersections = [];\n\n  for (var i = 0; i < len; i++) {\n    var p0 = points[i];\n    var p1 = points[(i + 1) % len];\n    var intersectionPt = lineLineIntersect(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y);\n\n    if (intersectionPt) {\n      intersections.push({\n        projPt: projPtOnLine(intersectionPt, lineA, lineB),\n        pt: intersectionPt,\n        idx: i\n      });\n    }\n  }\n\n  if (intersections.length < 2) {\n    return [{\n      points: points\n    }, {\n      points: points\n    }];\n  }\n\n  intersections.sort(function (a, b) {\n    return a.projPt - b.projPt;\n  });\n  var splitPt0 = intersections[0];\n  var splitPt1 = intersections[intersections.length - 1];\n\n  if (splitPt1.idx < splitPt0.idx) {\n    var tmp = splitPt0;\n    splitPt0 = splitPt1;\n    splitPt1 = tmp;\n  }\n\n  var splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];\n  var splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];\n  var newPolyA = [splitPt0Arr];\n  var newPolyB = [splitPt1Arr];\n\n  for (var i = splitPt0.idx + 1; i <= splitPt1.idx; i++) {\n    addToPoly(newPolyA, points[i].slice());\n  }\n\n  addToPoly(newPolyA, splitPt1Arr);\n  addToPoly(newPolyA, splitPt0Arr);\n\n  for (var i = splitPt1.idx + 1; i <= splitPt0.idx + len; i++) {\n    addToPoly(newPolyB, points[i % len].slice());\n  }\n\n  addToPoly(newPolyB, splitPt0Arr);\n  addToPoly(newPolyB, splitPt1Arr);\n  return [{\n    points: newPolyA\n  }, {\n    points: newPolyB\n  }];\n}\n\nfunction binaryDividePolygon(polygonShape) {\n  var points = polygonShape.points;\n  var min = [];\n  var max = [];\n  fromPoints(points, min, max);\n  var boundingRect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  var width = boundingRect.width;\n  var height = boundingRect.height;\n  var x = boundingRect.x;\n  var y = boundingRect.y;\n  var pt0 = new Point();\n  var pt1 = new Point();\n\n  if (width > height) {\n    pt0.x = pt1.x = x + width / 2;\n    pt0.y = y;\n    pt1.y = y + height;\n  } else {\n    pt0.y = pt1.y = y + height / 2;\n    pt0.x = x;\n    pt1.x = x + width;\n  }\n\n  return splitPolygonByLine(points, pt0, pt1);\n}\n\nfunction binaryDivideRecursive(divider, shape, count, out) {\n  if (count === 1) {\n    out.push(shape);\n  } else {\n    var mid = Math.floor(count / 2);\n    var sub = divider(shape);\n    binaryDivideRecursive(divider, sub[0], mid, out);\n    binaryDivideRecursive(divider, sub[1], count - mid, out);\n  }\n\n  return out;\n}\n\nexport function clone(path, count) {\n  var paths = [];\n\n  for (var i = 0; i < count; i++) {\n    paths.push(clonePath(path));\n  }\n\n  return paths;\n}\n\nfunction copyPathProps(source, target) {\n  target.setStyle(source.style);\n  target.z = source.z;\n  target.z2 = source.z2;\n  target.zlevel = source.zlevel;\n}\n\nfunction polygonConvert(points) {\n  var out = [];\n\n  for (var i = 0; i < points.length;) {\n    out.push([points[i++], points[i++]]);\n  }\n\n  return out;\n}\n\nexport function split(path, count) {\n  var outShapes = [];\n  var shape = path.shape;\n  var OutShapeCtor;\n\n  switch (path.type) {\n    case 'rect':\n      divideRect(shape, count, outShapes);\n      OutShapeCtor = Rect;\n      break;\n\n    case 'sector':\n      divideSector(shape, count, outShapes);\n      OutShapeCtor = Sector;\n      break;\n\n    case 'circle':\n      divideSector({\n        r0: 0,\n        r: shape.r,\n        startAngle: 0,\n        endAngle: Math.PI * 2,\n        cx: shape.cx,\n        cy: shape.cy\n      }, count, outShapes);\n      OutShapeCtor = Sector;\n      break;\n\n    default:\n      var m = path.getComputedTransform();\n      var scale = m ? Math.sqrt(Math.max(m[0] * m[0] + m[1] * m[1], m[2] * m[2] + m[3] * m[3])) : 1;\n      var polygons = map(pathToPolygons(path.getUpdatedPathProxy(), scale), function (poly) {\n        return polygonConvert(poly);\n      });\n      var polygonCount = polygons.length;\n\n      if (polygonCount === 0) {\n        binaryDivideRecursive(binaryDividePolygon, {\n          points: polygons[0]\n        }, count, outShapes);\n      } else if (polygonCount === count) {\n        for (var i = 0; i < polygonCount; i++) {\n          outShapes.push({\n            points: polygons[i]\n          });\n        }\n      } else {\n        var totalArea_1 = 0;\n        var items = map(polygons, function (poly) {\n          var min = [];\n          var max = [];\n          fromPoints(poly, min, max);\n          var area = (max[1] - min[1]) * (max[0] - min[0]);\n          totalArea_1 += area;\n          return {\n            poly: poly,\n            area: area\n          };\n        });\n        items.sort(function (a, b) {\n          return b.area - a.area;\n        });\n        var left = count;\n\n        for (var i = 0; i < polygonCount; i++) {\n          var item = items[i];\n\n          if (left <= 0) {\n            break;\n          }\n\n          var selfCount = i === polygonCount - 1 ? left : Math.ceil(item.area / totalArea_1 * count);\n\n          if (selfCount < 0) {\n            continue;\n          }\n\n          binaryDivideRecursive(binaryDividePolygon, {\n            points: item.poly\n          }, selfCount, outShapes);\n          left -= selfCount;\n        }\n\n        ;\n      }\n\n      OutShapeCtor = Polygon;\n      break;\n  }\n\n  if (!OutShapeCtor) {\n    return clone(path, count);\n  }\n\n  var out = [];\n\n  for (var i = 0; i < outShapes.length; i++) {\n    var subPath = new OutShapeCtor();\n    subPath.setShape(outShapes[i]);\n    copyPathProps(path, subPath);\n    out.push(subPath);\n  }\n\n  return out;\n}","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/zrender/lib/tool/dividePath.js"],"names":["fromPoints","BoundingRect","Point","map","Polygon","Rect","Sector","pathToPolygons","clonePath","getDividingGrids","dimSize","rowDim","count","rowSize","columnSize","ratio","Math","abs","rowCount","ceil","sqrt","columnCount","floor","grids","i","push","currentCount","remained","divideSector","sectorShape","outShapes","r0","r","startAngle","endAngle","angle","arcLen","deltaR","isAngleRow","length","row","column","newShape","clockwise","cx","cy","divideRect","rectShape","width","height","isHorizontalRow","rowSizeDim","columnSizeDim","columnDim","x","y","crossProduct2d","x1","y1","x2","y2","lineLineIntersect","a1x","a1y","a2x","a2y","b1x","b1y","b2x","b2y","mx","my","nx","ny","nmCrossProduct","b1a1x","b1a1y","p","projPtOnLine","pt","lineA","lineB","dir","sub","normalize","dir2","len","dot","addToPoly","poly","last","splitPolygonByLine","points","intersections","p0","p1","intersectionPt","projPt","idx","sort","a","b","splitPt0","splitPt1","tmp","splitPt0Arr","splitPt1Arr","newPolyA","newPolyB","slice","binaryDividePolygon","polygonShape","min","max","boundingRect","pt0","pt1","binaryDivideRecursive","divider","shape","out","mid","clone","path","paths","copyPathProps","source","target","setStyle","style","z","z2","zlevel","polygonConvert","split","OutShapeCtor","type","PI","m","getComputedTransform","scale","polygons","getUpdatedPathProxy","polygonCount","totalArea_1","items","area","left","item","selfCount","subPath","setShape"],"mappings":"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","sourcesContent":["import { fromPoints } from '../core/bbox';\nimport BoundingRect from '../core/BoundingRect';\nimport Point from '../core/Point';\nimport { map } from '../core/util';\nimport Polygon from '../graphic/shape/Polygon';\nimport Rect from '../graphic/shape/Rect';\nimport Sector from '../graphic/shape/Sector';\nimport { pathToPolygons } from './convertPath';\nimport { clonePath } from './path';\nfunction getDividingGrids(dimSize, rowDim, count) {\n    var rowSize = dimSize[rowDim];\n    var columnSize = dimSize[1 - rowDim];\n    var ratio = Math.abs(rowSize / columnSize);\n    var rowCount = Math.ceil(Math.sqrt(ratio * count));\n    var columnCount = Math.floor(count / rowCount);\n    if (columnCount === 0) {\n        columnCount = 1;\n        rowCount = count;\n    }\n    var grids = [];\n    for (var i = 0; i < rowCount; i++) {\n        grids.push(columnCount);\n    }\n    var currentCount = rowCount * columnCount;\n    var remained = count - currentCount;\n    if (remained > 0) {\n        for (var i = 0; i < remained; i++) {\n            grids[i % rowCount] += 1;\n        }\n    }\n    return grids;\n}\nfunction divideSector(sectorShape, count, outShapes) {\n    var r0 = sectorShape.r0;\n    var r = sectorShape.r;\n    var startAngle = sectorShape.startAngle;\n    var endAngle = sectorShape.endAngle;\n    var angle = Math.abs(endAngle - startAngle);\n    var arcLen = angle * r;\n    var deltaR = r - r0;\n    var isAngleRow = arcLen > Math.abs(deltaR);\n    var grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count);\n    var rowSize = (isAngleRow ? angle : deltaR) / grids.length;\n    for (var row = 0; row < grids.length; row++) {\n        var columnSize = (isAngleRow ? deltaR : angle) / grids[row];\n        for (var column = 0; column < grids[row]; column++) {\n            var newShape = {};\n            if (isAngleRow) {\n                newShape.startAngle = startAngle + rowSize * row;\n                newShape.endAngle = startAngle + rowSize * (row + 1);\n                newShape.r0 = r0 + columnSize * column;\n                newShape.r = r0 + columnSize * (column + 1);\n            }\n            else {\n                newShape.startAngle = startAngle + columnSize * column;\n                newShape.endAngle = startAngle + columnSize * (column + 1);\n                newShape.r0 = r0 + rowSize * row;\n                newShape.r = r0 + rowSize * (row + 1);\n            }\n            newShape.clockwise = sectorShape.clockwise;\n            newShape.cx = sectorShape.cx;\n            newShape.cy = sectorShape.cy;\n            outShapes.push(newShape);\n        }\n    }\n}\nfunction divideRect(rectShape, count, outShapes) {\n    var width = rectShape.width;\n    var height = rectShape.height;\n    var isHorizontalRow = width > height;\n    var grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count);\n    var rowSizeDim = isHorizontalRow ? 'width' : 'height';\n    var columnSizeDim = isHorizontalRow ? 'height' : 'width';\n    var rowDim = isHorizontalRow ? 'x' : 'y';\n    var columnDim = isHorizontalRow ? 'y' : 'x';\n    var rowSize = rectShape[rowSizeDim] / grids.length;\n    for (var row = 0; row < grids.length; row++) {\n        var columnSize = rectShape[columnSizeDim] / grids[row];\n        for (var column = 0; column < grids[row]; column++) {\n            var newShape = {};\n            newShape[rowDim] = row * rowSize;\n            newShape[columnDim] = column * columnSize;\n            newShape[rowSizeDim] = rowSize;\n            newShape[columnSizeDim] = columnSize;\n            newShape.x += rectShape.x;\n            newShape.y += rectShape.y;\n            outShapes.push(newShape);\n        }\n    }\n}\nfunction crossProduct2d(x1, y1, x2, y2) {\n    return x1 * y2 - x2 * y1;\n}\nfunction lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n    var mx = a2x - a1x;\n    var my = a2y - a1y;\n    var nx = b2x - b1x;\n    var ny = b2y - b1y;\n    var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n    if (Math.abs(nmCrossProduct) < 1e-6) {\n        return null;\n    }\n    var b1a1x = a1x - b1x;\n    var b1a1y = a1y - b1y;\n    var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n    if (p < 0 || p > 1) {\n        return null;\n    }\n    return new Point(p * mx + a1x, p * my + a1y);\n}\nfunction projPtOnLine(pt, lineA, lineB) {\n    var dir = new Point();\n    Point.sub(dir, lineB, lineA);\n    dir.normalize();\n    var dir2 = new Point();\n    Point.sub(dir2, pt, lineA);\n    var len = dir2.dot(dir);\n    return len;\n}\nfunction addToPoly(poly, pt) {\n    var last = poly[poly.length - 1];\n    if (last && last[0] === pt[0] && last[1] === pt[1]) {\n        return;\n    }\n    poly.push(pt);\n}\nfunction splitPolygonByLine(points, lineA, lineB) {\n    var len = points.length;\n    var intersections = [];\n    for (var i = 0; i < len; i++) {\n        var p0 = points[i];\n        var p1 = points[(i + 1) % len];\n        var intersectionPt = lineLineIntersect(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y);\n        if (intersectionPt) {\n            intersections.push({\n                projPt: projPtOnLine(intersectionPt, lineA, lineB),\n                pt: intersectionPt,\n                idx: i\n            });\n        }\n    }\n    if (intersections.length < 2) {\n        return [{ points: points }, { points: points }];\n    }\n    intersections.sort(function (a, b) {\n        return a.projPt - b.projPt;\n    });\n    var splitPt0 = intersections[0];\n    var splitPt1 = intersections[intersections.length - 1];\n    if (splitPt1.idx < splitPt0.idx) {\n        var tmp = splitPt0;\n        splitPt0 = splitPt1;\n        splitPt1 = tmp;\n    }\n    var splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];\n    var splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];\n    var newPolyA = [splitPt0Arr];\n    var newPolyB = [splitPt1Arr];\n    for (var i = splitPt0.idx + 1; i <= splitPt1.idx; i++) {\n        addToPoly(newPolyA, points[i].slice());\n    }\n    addToPoly(newPolyA, splitPt1Arr);\n    addToPoly(newPolyA, splitPt0Arr);\n    for (var i = splitPt1.idx + 1; i <= splitPt0.idx + len; i++) {\n        addToPoly(newPolyB, points[i % len].slice());\n    }\n    addToPoly(newPolyB, splitPt0Arr);\n    addToPoly(newPolyB, splitPt1Arr);\n    return [{\n            points: newPolyA\n        }, {\n            points: newPolyB\n        }];\n}\nfunction binaryDividePolygon(polygonShape) {\n    var points = polygonShape.points;\n    var min = [];\n    var max = [];\n    fromPoints(points, min, max);\n    var boundingRect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n    var width = boundingRect.width;\n    var height = boundingRect.height;\n    var x = boundingRect.x;\n    var y = boundingRect.y;\n    var pt0 = new Point();\n    var pt1 = new Point();\n    if (width > height) {\n        pt0.x = pt1.x = x + width / 2;\n        pt0.y = y;\n        pt1.y = y + height;\n    }\n    else {\n        pt0.y = pt1.y = y + height / 2;\n        pt0.x = x;\n        pt1.x = x + width;\n    }\n    return splitPolygonByLine(points, pt0, pt1);\n}\nfunction binaryDivideRecursive(divider, shape, count, out) {\n    if (count === 1) {\n        out.push(shape);\n    }\n    else {\n        var mid = Math.floor(count / 2);\n        var sub = divider(shape);\n        binaryDivideRecursive(divider, sub[0], mid, out);\n        binaryDivideRecursive(divider, sub[1], count - mid, out);\n    }\n    return out;\n}\nexport function clone(path, count) {\n    var paths = [];\n    for (var i = 0; i < count; i++) {\n        paths.push(clonePath(path));\n    }\n    return paths;\n}\nfunction copyPathProps(source, target) {\n    target.setStyle(source.style);\n    target.z = source.z;\n    target.z2 = source.z2;\n    target.zlevel = source.zlevel;\n}\nfunction polygonConvert(points) {\n    var out = [];\n    for (var i = 0; i < points.length;) {\n        out.push([points[i++], points[i++]]);\n    }\n    return out;\n}\nexport function split(path, count) {\n    var outShapes = [];\n    var shape = path.shape;\n    var OutShapeCtor;\n    switch (path.type) {\n        case 'rect':\n            divideRect(shape, count, outShapes);\n            OutShapeCtor = Rect;\n            break;\n        case 'sector':\n            divideSector(shape, count, outShapes);\n            OutShapeCtor = Sector;\n            break;\n        case 'circle':\n            divideSector({\n                r0: 0, r: shape.r, startAngle: 0, endAngle: Math.PI * 2,\n                cx: shape.cx, cy: shape.cy\n            }, count, outShapes);\n            OutShapeCtor = Sector;\n            break;\n        default:\n            var m = path.getComputedTransform();\n            var scale = m ? Math.sqrt(Math.max(m[0] * m[0] + m[1] * m[1], m[2] * m[2] + m[3] * m[3])) : 1;\n            var polygons = map(pathToPolygons(path.getUpdatedPathProxy(), scale), function (poly) { return polygonConvert(poly); });\n            var polygonCount = polygons.length;\n            if (polygonCount === 0) {\n                binaryDivideRecursive(binaryDividePolygon, {\n                    points: polygons[0]\n                }, count, outShapes);\n            }\n            else if (polygonCount === count) {\n                for (var i = 0; i < polygonCount; i++) {\n                    outShapes.push({\n                        points: polygons[i]\n                    });\n                }\n            }\n            else {\n                var totalArea_1 = 0;\n                var items = map(polygons, function (poly) {\n                    var min = [];\n                    var max = [];\n                    fromPoints(poly, min, max);\n                    var area = (max[1] - min[1]) * (max[0] - min[0]);\n                    totalArea_1 += area;\n                    return { poly: poly, area: area };\n                });\n                items.sort(function (a, b) { return b.area - a.area; });\n                var left = count;\n                for (var i = 0; i < polygonCount; i++) {\n                    var item = items[i];\n                    if (left <= 0) {\n                        break;\n                    }\n                    var selfCount = i === polygonCount - 1\n                        ? left\n                        : Math.ceil(item.area / totalArea_1 * count);\n                    if (selfCount < 0) {\n                        continue;\n                    }\n                    binaryDivideRecursive(binaryDividePolygon, {\n                        points: item.poly\n                    }, selfCount, outShapes);\n                    left -= selfCount;\n                }\n                ;\n            }\n            OutShapeCtor = Polygon;\n            break;\n    }\n    if (!OutShapeCtor) {\n        return clone(path, count);\n    }\n    var out = [];\n    for (var i = 0; i < outShapes.length; i++) {\n        var subPath = new OutShapeCtor();\n        subPath.setShape(outShapes[i]);\n        copyPathProps(path, subPath);\n        out.push(subPath);\n    }\n    return out;\n}\n"]},"metadata":{},"sourceType":"module"}