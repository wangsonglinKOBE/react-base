{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport * as numberUtil from '../util/number';\nimport * as formatUtil from '../util/format';\nimport Scale from './Scale';\nimport * as helper from './helper';\nvar roundNumber = numberUtil.round;\n\nvar IntervalScale =\n/** @class */\nfunction (_super) {\n  __extends(IntervalScale, _super);\n\n  function IntervalScale() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'interval'; // Step is calculated in adjustExtent.\n\n    _this._interval = 0;\n    _this._intervalPrecision = 2;\n    return _this;\n  }\n\n  IntervalScale.prototype.parse = function (val) {\n    return val;\n  };\n\n  IntervalScale.prototype.contain = function (val) {\n    return helper.contain(val, this._extent);\n  };\n\n  IntervalScale.prototype.normalize = function (val) {\n    return helper.normalize(val, this._extent);\n  };\n\n  IntervalScale.prototype.scale = function (val) {\n    return helper.scale(val, this._extent);\n  };\n\n  IntervalScale.prototype.setExtent = function (start, end) {\n    var thisExtent = this._extent; // start,end may be a Number like '25',so...\n\n    if (!isNaN(start)) {\n      thisExtent[0] = parseFloat(start);\n    }\n\n    if (!isNaN(end)) {\n      thisExtent[1] = parseFloat(end);\n    }\n  };\n\n  IntervalScale.prototype.unionExtent = function (other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes\n\n    this.setExtent(extent[0], extent[1]);\n  };\n\n  IntervalScale.prototype.getInterval = function () {\n    return this._interval;\n  };\n\n  IntervalScale.prototype.setInterval = function (interval) {\n    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent\n    // We assume user wan't to set both interval, min, max to get a better result\n\n    this._niceExtent = this._extent.slice();\n    this._intervalPrecision = helper.getIntervalPrecision(interval);\n  };\n  /**\n   * @param expandToNicedExtent Whether expand the ticks to niced extent.\n   */\n\n\n  IntervalScale.prototype.getTicks = function (expandToNicedExtent) {\n    var interval = this._interval;\n    var extent = this._extent;\n    var niceTickExtent = this._niceExtent;\n    var intervalPrecision = this._intervalPrecision;\n    var ticks = []; // If interval is 0, return [];\n\n    if (!interval) {\n      return ticks;\n    } // Consider this case: using dataZoom toolbox, zoom and zoom.\n\n\n    var safeLimit = 10000;\n\n    if (extent[0] < niceTickExtent[0]) {\n      if (expandToNicedExtent) {\n        ticks.push({\n          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)\n        });\n      } else {\n        ticks.push({\n          value: extent[0]\n        });\n      }\n    }\n\n    var tick = niceTickExtent[0];\n\n    while (tick <= niceTickExtent[1]) {\n      ticks.push({\n        value: tick\n      }); // Avoid rounding error\n\n      tick = roundNumber(tick + interval, intervalPrecision);\n\n      if (tick === ticks[ticks.length - 1].value) {\n        // Consider out of safe float point, e.g.,\n        // -3711126.9907707 + 2e-10 === -3711126.9907707\n        break;\n      }\n\n      if (ticks.length > safeLimit) {\n        return [];\n      }\n    } // Consider this case: the last item of ticks is smaller\n    // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n\n\n    var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];\n\n    if (extent[1] > lastNiceTick) {\n      if (expandToNicedExtent) {\n        ticks.push({\n          value: roundNumber(lastNiceTick + interval, intervalPrecision)\n        });\n      } else {\n        ticks.push({\n          value: extent[1]\n        });\n      }\n    }\n\n    return ticks;\n  };\n\n  IntervalScale.prototype.getMinorTicks = function (splitNumber) {\n    var ticks = this.getTicks(true);\n    var minorTicks = [];\n    var extent = this.getExtent();\n\n    for (var i = 1; i < ticks.length; i++) {\n      var nextTick = ticks[i];\n      var prevTick = ticks[i - 1];\n      var count = 0;\n      var minorTicksGroup = [];\n      var interval = nextTick.value - prevTick.value;\n      var minorInterval = interval / splitNumber;\n\n      while (count < splitNumber - 1) {\n        var minorTick = roundNumber(prevTick.value + (count + 1) * minorInterval); // For the first and last interval. The count may be less than splitNumber.\n\n        if (minorTick > extent[0] && minorTick < extent[1]) {\n          minorTicksGroup.push(minorTick);\n        }\n\n        count++;\n      }\n\n      minorTicks.push(minorTicksGroup);\n    }\n\n    return minorTicks;\n  };\n  /**\n   * @param opt.precision If 'auto', use nice presision.\n   * @param opt.pad returns 1.50 but not 1.5 if precision is 2.\n   */\n\n\n  IntervalScale.prototype.getLabel = function (data, opt) {\n    if (data == null) {\n      return '';\n    }\n\n    var precision = opt && opt.precision;\n\n    if (precision == null) {\n      precision = numberUtil.getPrecision(data.value) || 0;\n    } else if (precision === 'auto') {\n      // Should be more precise then tick.\n      precision = this._intervalPrecision;\n    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n\n\n    var dataNum = roundNumber(data.value, precision, true);\n    return formatUtil.addCommas(dataNum);\n  };\n  /**\n   * @param splitNumber By default `5`.\n   */\n\n\n  IntervalScale.prototype.niceTicks = function (splitNumber, minInterval, maxInterval) {\n    splitNumber = splitNumber || 5;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (!isFinite(span)) {\n      return;\n    } // User may set axis min 0 and data are all negative\n    // FIXME If it needs to reverse ?\n\n\n    if (span < 0) {\n      span = -span;\n      extent.reverse();\n    }\n\n    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);\n    this._intervalPrecision = result.intervalPrecision;\n    this._interval = result.interval;\n    this._niceExtent = result.niceTickExtent;\n  };\n\n  IntervalScale.prototype.niceExtent = function (opt) {\n    var extent = this._extent; // If extent start and end are same, expand them\n\n    if (extent[0] === extent[1]) {\n      if (extent[0] !== 0) {\n        // Expand extent\n        var expandSize = extent[0]; // In the fowllowing case\n        //      Axis has been fixed max 100\n        //      Plus data are all 100 and axis extent are [100, 100].\n        // Extend to the both side will cause expanded max is larger than fixed max.\n        // So only expand to the smaller side.\n\n        if (!opt.fixMax) {\n          extent[1] += expandSize / 2;\n          extent[0] -= expandSize / 2;\n        } else {\n          extent[0] -= expandSize / 2;\n        }\n      } else {\n        extent[1] = 1;\n      }\n    }\n\n    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]\n\n    if (!isFinite(span)) {\n      extent[0] = 0;\n      extent[1] = 1;\n    }\n\n    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // let extent = this._extent;\n\n    var interval = this._interval;\n\n    if (!opt.fixMin) {\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n    }\n\n    if (!opt.fixMax) {\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n    }\n  };\n\n  IntervalScale.type = 'interval';\n  return IntervalScale;\n}(Scale);\n\nScale.registerClass(IntervalScale);\nexport default IntervalScale;","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/scale/Interval.js"],"names":["__extends","numberUtil","formatUtil","Scale","helper","roundNumber","round","IntervalScale","_super","_this","apply","arguments","type","_interval","_intervalPrecision","prototype","parse","val","contain","_extent","normalize","scale","setExtent","start","end","thisExtent","isNaN","parseFloat","unionExtent","other","extent","getInterval","setInterval","interval","_niceExtent","slice","getIntervalPrecision","getTicks","expandToNicedExtent","niceTickExtent","intervalPrecision","ticks","safeLimit","push","value","tick","length","lastNiceTick","getMinorTicks","splitNumber","minorTicks","getExtent","i","nextTick","prevTick","count","minorTicksGroup","minorInterval","minorTick","getLabel","data","opt","precision","getPrecision","dataNum","addCommas","niceTicks","minInterval","maxInterval","span","isFinite","reverse","result","intervalScaleNiceTicks","niceExtent","expandSize","fixMax","fixMin","Math","floor","ceil","registerClass"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport * as numberUtil from '../util/number';\nimport * as formatUtil from '../util/format';\nimport Scale from './Scale';\nimport * as helper from './helper';\nvar roundNumber = numberUtil.round;\n\nvar IntervalScale =\n/** @class */\nfunction (_super) {\n  __extends(IntervalScale, _super);\n\n  function IntervalScale() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'interval'; // Step is calculated in adjustExtent.\n\n    _this._interval = 0;\n    _this._intervalPrecision = 2;\n    return _this;\n  }\n\n  IntervalScale.prototype.parse = function (val) {\n    return val;\n  };\n\n  IntervalScale.prototype.contain = function (val) {\n    return helper.contain(val, this._extent);\n  };\n\n  IntervalScale.prototype.normalize = function (val) {\n    return helper.normalize(val, this._extent);\n  };\n\n  IntervalScale.prototype.scale = function (val) {\n    return helper.scale(val, this._extent);\n  };\n\n  IntervalScale.prototype.setExtent = function (start, end) {\n    var thisExtent = this._extent; // start,end may be a Number like '25',so...\n\n    if (!isNaN(start)) {\n      thisExtent[0] = parseFloat(start);\n    }\n\n    if (!isNaN(end)) {\n      thisExtent[1] = parseFloat(end);\n    }\n  };\n\n  IntervalScale.prototype.unionExtent = function (other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes\n\n    this.setExtent(extent[0], extent[1]);\n  };\n\n  IntervalScale.prototype.getInterval = function () {\n    return this._interval;\n  };\n\n  IntervalScale.prototype.setInterval = function (interval) {\n    this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent\n    // We assume user wan't to set both interval, min, max to get a better result\n\n    this._niceExtent = this._extent.slice();\n    this._intervalPrecision = helper.getIntervalPrecision(interval);\n  };\n  /**\n   * @param expandToNicedExtent Whether expand the ticks to niced extent.\n   */\n\n\n  IntervalScale.prototype.getTicks = function (expandToNicedExtent) {\n    var interval = this._interval;\n    var extent = this._extent;\n    var niceTickExtent = this._niceExtent;\n    var intervalPrecision = this._intervalPrecision;\n    var ticks = []; // If interval is 0, return [];\n\n    if (!interval) {\n      return ticks;\n    } // Consider this case: using dataZoom toolbox, zoom and zoom.\n\n\n    var safeLimit = 10000;\n\n    if (extent[0] < niceTickExtent[0]) {\n      if (expandToNicedExtent) {\n        ticks.push({\n          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)\n        });\n      } else {\n        ticks.push({\n          value: extent[0]\n        });\n      }\n    }\n\n    var tick = niceTickExtent[0];\n\n    while (tick <= niceTickExtent[1]) {\n      ticks.push({\n        value: tick\n      }); // Avoid rounding error\n\n      tick = roundNumber(tick + interval, intervalPrecision);\n\n      if (tick === ticks[ticks.length - 1].value) {\n        // Consider out of safe float point, e.g.,\n        // -3711126.9907707 + 2e-10 === -3711126.9907707\n        break;\n      }\n\n      if (ticks.length > safeLimit) {\n        return [];\n      }\n    } // Consider this case: the last item of ticks is smaller\n    // than niceTickExtent[1] and niceTickExtent[1] === extent[1].\n\n\n    var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];\n\n    if (extent[1] > lastNiceTick) {\n      if (expandToNicedExtent) {\n        ticks.push({\n          value: roundNumber(lastNiceTick + interval, intervalPrecision)\n        });\n      } else {\n        ticks.push({\n          value: extent[1]\n        });\n      }\n    }\n\n    return ticks;\n  };\n\n  IntervalScale.prototype.getMinorTicks = function (splitNumber) {\n    var ticks = this.getTicks(true);\n    var minorTicks = [];\n    var extent = this.getExtent();\n\n    for (var i = 1; i < ticks.length; i++) {\n      var nextTick = ticks[i];\n      var prevTick = ticks[i - 1];\n      var count = 0;\n      var minorTicksGroup = [];\n      var interval = nextTick.value - prevTick.value;\n      var minorInterval = interval / splitNumber;\n\n      while (count < splitNumber - 1) {\n        var minorTick = roundNumber(prevTick.value + (count + 1) * minorInterval); // For the first and last interval. The count may be less than splitNumber.\n\n        if (minorTick > extent[0] && minorTick < extent[1]) {\n          minorTicksGroup.push(minorTick);\n        }\n\n        count++;\n      }\n\n      minorTicks.push(minorTicksGroup);\n    }\n\n    return minorTicks;\n  };\n  /**\n   * @param opt.precision If 'auto', use nice presision.\n   * @param opt.pad returns 1.50 but not 1.5 if precision is 2.\n   */\n\n\n  IntervalScale.prototype.getLabel = function (data, opt) {\n    if (data == null) {\n      return '';\n    }\n\n    var precision = opt && opt.precision;\n\n    if (precision == null) {\n      precision = numberUtil.getPrecision(data.value) || 0;\n    } else if (precision === 'auto') {\n      // Should be more precise then tick.\n      precision = this._intervalPrecision;\n    } // (1) If `precision` is set, 12.005 should be display as '12.00500'.\n    // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.\n\n\n    var dataNum = roundNumber(data.value, precision, true);\n    return formatUtil.addCommas(dataNum);\n  };\n  /**\n   * @param splitNumber By default `5`.\n   */\n\n\n  IntervalScale.prototype.niceTicks = function (splitNumber, minInterval, maxInterval) {\n    splitNumber = splitNumber || 5;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (!isFinite(span)) {\n      return;\n    } // User may set axis min 0 and data are all negative\n    // FIXME If it needs to reverse ?\n\n\n    if (span < 0) {\n      span = -span;\n      extent.reverse();\n    }\n\n    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);\n    this._intervalPrecision = result.intervalPrecision;\n    this._interval = result.interval;\n    this._niceExtent = result.niceTickExtent;\n  };\n\n  IntervalScale.prototype.niceExtent = function (opt) {\n    var extent = this._extent; // If extent start and end are same, expand them\n\n    if (extent[0] === extent[1]) {\n      if (extent[0] !== 0) {\n        // Expand extent\n        var expandSize = extent[0]; // In the fowllowing case\n        //      Axis has been fixed max 100\n        //      Plus data are all 100 and axis extent are [100, 100].\n        // Extend to the both side will cause expanded max is larger than fixed max.\n        // So only expand to the smaller side.\n\n        if (!opt.fixMax) {\n          extent[1] += expandSize / 2;\n          extent[0] -= expandSize / 2;\n        } else {\n          extent[0] -= expandSize / 2;\n        }\n      } else {\n        extent[1] = 1;\n      }\n    }\n\n    var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity]\n\n    if (!isFinite(span)) {\n      extent[0] = 0;\n      extent[1] = 1;\n    }\n\n    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // let extent = this._extent;\n\n    var interval = this._interval;\n\n    if (!opt.fixMin) {\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n    }\n\n    if (!opt.fixMax) {\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n    }\n  };\n\n  IntervalScale.type = 'interval';\n  return IntervalScale;\n}(Scale);\n\nScale.registerClass(IntervalScale);\nexport default IntervalScale;"]},"metadata":{},"sourceType":"module"}