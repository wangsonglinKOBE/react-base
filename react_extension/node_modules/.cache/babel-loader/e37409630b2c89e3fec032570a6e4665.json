{"ast":null,"code":"import { cubicSubdivide } from '../core/curve';\nimport Path from '../graphic/Path';\nimport { defaults, map } from '../core/util';\nimport { lerp } from '../core/vector';\nimport { clonePath } from './path';\nimport Transformable from '../core/Transformable';\nimport { split } from './dividePath';\nimport { pathToBezierCurves } from './convertPath';\n\nfunction alignSubpath(subpath1, subpath2) {\n  var len1 = subpath1.length;\n  var len2 = subpath2.length;\n\n  if (len1 === len2) {\n    return [subpath1, subpath2];\n  }\n\n  var tmpSegX = [];\n  var tmpSegY = [];\n  var shorterPath = len1 < len2 ? subpath1 : subpath2;\n  var shorterLen = Math.min(len1, len2);\n  var diff = Math.abs(len2 - len1) / 6;\n  var shorterBezierCount = (shorterLen - 2) / 6;\n  var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n  var newSubpath = [shorterPath[0], shorterPath[1]];\n  var remained = diff;\n\n  for (var i = 2; i < shorterLen;) {\n    var x0 = shorterPath[i - 2];\n    var y0 = shorterPath[i - 1];\n    var x1 = shorterPath[i++];\n    var y1 = shorterPath[i++];\n    var x2 = shorterPath[i++];\n    var y2 = shorterPath[i++];\n    var x3 = shorterPath[i++];\n    var y3 = shorterPath[i++];\n\n    if (remained <= 0) {\n      newSubpath.push(x1, y1, x2, y2, x3, y3);\n      continue;\n    }\n\n    var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n\n    for (var k = 1; k <= actualSubDivCount; k++) {\n      var p = k / actualSubDivCount;\n      cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n      cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n      x0 = tmpSegX[3];\n      y0 = tmpSegY[3];\n      newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n      x1 = tmpSegX[5];\n      y1 = tmpSegY[5];\n      x2 = tmpSegX[6];\n      y2 = tmpSegY[6];\n    }\n\n    remained -= actualSubDivCount - 1;\n  }\n\n  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\n\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n  var len = lastSubpathSubpath.length;\n  var lastX = lastSubpathSubpath[len - 2];\n  var lastY = lastSubpathSubpath[len - 1];\n  var newSubpath = [];\n\n  for (var i = 0; i < otherSubpath.length;) {\n    newSubpath[i++] = lastX;\n    newSubpath[i++] = lastY;\n  }\n\n  return newSubpath;\n}\n\nexport function alignBezierCurves(array1, array2) {\n  var _a;\n\n  var lastSubpath1;\n  var lastSubpath2;\n  var newArray1 = [];\n  var newArray2 = [];\n\n  for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n    var subpath1 = array1[i];\n    var subpath2 = array2[i];\n    var newSubpath1 = void 0;\n    var newSubpath2 = void 0;\n\n    if (!subpath1) {\n      newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n      newSubpath2 = subpath2;\n    } else if (!subpath2) {\n      newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n      newSubpath1 = subpath1;\n    } else {\n      _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n      lastSubpath1 = newSubpath1;\n      lastSubpath2 = newSubpath2;\n    }\n\n    newArray1.push(newSubpath1);\n    newArray2.push(newSubpath2);\n  }\n\n  return [newArray1, newArray2];\n}\nexport function centroid(array) {\n  var signedArea = 0;\n  var cx = 0;\n  var cy = 0;\n  var len = array.length;\n\n  for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n    var x0 = array[j];\n    var y0 = array[j + 1];\n    var x1 = array[i];\n    var y1 = array[i + 1];\n    var a = x0 * y1 - x1 * y0;\n    signedArea += a;\n    cx += (x0 + x1) * a;\n    cy += (y0 + y1) * a;\n  }\n\n  if (signedArea === 0) {\n    return [array[0] || 0, array[1] || 0];\n  }\n\n  return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\n\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n  var bezierCount = (fromSubBeziers.length - 2) / 6;\n  var bestScore = Infinity;\n  var bestOffset = 0;\n  var len = fromSubBeziers.length;\n  var len2 = len - 2;\n\n  for (var offset = 0; offset < bezierCount; offset++) {\n    var cursorOffset = offset * 6;\n    var score = 0;\n\n    for (var k = 0; k < len; k += 2) {\n      var idx = k === 0 ? cursorOffset : (cursorOffset + k - 2) % len2 + 2;\n      var x0 = fromSubBeziers[idx] - fromCp[0];\n      var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n      var x1 = toSubBeziers[k] - toCp[0];\n      var y1 = toSubBeziers[k + 1] - toCp[1];\n      var dx = x1 - x0;\n      var dy = y1 - y0;\n      score += dx * dx + dy * dy;\n    }\n\n    if (score < bestScore) {\n      bestScore = score;\n      bestOffset = offset;\n    }\n  }\n\n  return bestOffset;\n}\n\nfunction reverse(array) {\n  var newArr = [];\n  var len = array.length;\n\n  for (var i = 0; i < len; i += 2) {\n    newArr[i] = array[len - i - 2];\n    newArr[i + 1] = array[len - i - 1];\n  }\n\n  return newArr;\n}\n\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n  var result = [];\n  var fromNeedsReverse;\n\n  for (var i = 0; i < fromArr.length; i++) {\n    var fromSubpathBezier = fromArr[i];\n    var toSubpathBezier = toArr[i];\n    var fromCp = centroid(fromSubpathBezier);\n    var toCp = centroid(toSubpathBezier);\n\n    if (fromNeedsReverse == null) {\n      fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n    }\n\n    var newFromSubpathBezier = [];\n    var newToSubpathBezier = [];\n    var bestAngle = 0;\n    var bestScore = Infinity;\n    var tmpArr = [];\n    var len = fromSubpathBezier.length;\n\n    if (fromNeedsReverse) {\n      fromSubpathBezier = reverse(fromSubpathBezier);\n    }\n\n    var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n    var len2 = len - 2;\n\n    for (var k = 0; k < len2; k += 2) {\n      var idx = (offset + k) % len2 + 2;\n      newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n      newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n    }\n\n    newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n    newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n\n    if (searchAngleIteration > 0) {\n      var step = searchAngleRange / searchAngleIteration;\n\n      for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n        var sa = Math.sin(angle);\n        var ca = Math.cos(angle);\n        var score = 0;\n\n        for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n          var x0 = newFromSubpathBezier[k];\n          var y0 = newFromSubpathBezier[k + 1];\n          var x1 = toSubpathBezier[k] - toCp[0];\n          var y1 = toSubpathBezier[k + 1] - toCp[1];\n          var newX1 = x1 * ca - y1 * sa;\n          var newY1 = x1 * sa + y1 * ca;\n          tmpArr[k] = newX1;\n          tmpArr[k + 1] = newY1;\n          var dx = newX1 - x0;\n          var dy = newY1 - y0;\n          score += dx * dx + dy * dy;\n        }\n\n        if (score < bestScore) {\n          bestScore = score;\n          bestAngle = angle;\n\n          for (var m = 0; m < tmpArr.length; m++) {\n            newToSubpathBezier[m] = tmpArr[m];\n          }\n        }\n      }\n    } else {\n      for (var i_1 = 0; i_1 < len; i_1 += 2) {\n        newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n        newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n      }\n    }\n\n    result.push({\n      from: newFromSubpathBezier,\n      to: newToSubpathBezier,\n      fromCp: fromCp,\n      toCp: toCp,\n      rotation: -bestAngle\n    });\n  }\n\n  return result;\n}\n\nexport function isCombineMorphing(path) {\n  return path.__isCombineMorphing;\n}\nexport function isMorphing(el) {\n  return el.__morphT >= 0;\n}\nvar SAVED_METHOD_PREFIX = '__mOriginal_';\n\nfunction saveAndModifyMethod(obj, methodName, modifiers) {\n  var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n  var originalMethod = obj[savedMethodName] || obj[methodName];\n\n  if (!obj[savedMethodName]) {\n    obj[savedMethodName] = obj[methodName];\n  }\n\n  var replace = modifiers.replace;\n  var after = modifiers.after;\n  var before = modifiers.before;\n\n  obj[methodName] = function () {\n    var args = arguments;\n    var res;\n    before && before.apply(this, args);\n\n    if (replace) {\n      res = replace.apply(this, args);\n    } else {\n      res = originalMethod.apply(this, args);\n    }\n\n    after && after.apply(this, args);\n    return res;\n  };\n}\n\nfunction restoreMethod(obj, methodName) {\n  var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n\n  if (obj[savedMethodName]) {\n    obj[methodName] = obj[savedMethodName];\n    obj[savedMethodName] = null;\n  }\n}\n\nfunction applyTransformOnBeziers(bezierCurves, mm) {\n  for (var i = 0; i < bezierCurves.length; i++) {\n    var subBeziers = bezierCurves[i];\n\n    for (var k = 0; k < subBeziers.length;) {\n      var x = subBeziers[k];\n      var y = subBeziers[k + 1];\n      subBeziers[k++] = mm[0] * x + mm[2] * y + mm[4];\n      subBeziers[k++] = mm[1] * x + mm[3] * y + mm[5];\n    }\n  }\n}\n\nfunction prepareMorphPath(fromPath, toPath) {\n  var fromPathProxy = fromPath.getUpdatedPathProxy();\n  var toPathProxy = toPath.getUpdatedPathProxy();\n\n  var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)),\n      fromBezierCurves = _a[0],\n      toBezierCurves = _a[1];\n\n  var fromPathTransform = fromPath.getComputedTransform();\n  var toPathTransform = toPath.getComputedTransform();\n\n  function updateIdentityTransform() {\n    this.transform = null;\n  }\n\n  fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);\n  toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);\n  saveAndModifyMethod(toPath, 'updateTransform', {\n    replace: updateIdentityTransform\n  });\n  toPath.transform = null;\n  var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n  var tmpArr = [];\n  saveAndModifyMethod(toPath, 'buildPath', {\n    replace: function (path) {\n      var t = toPath.__morphT;\n      var onet = 1 - t;\n      var newCp = [];\n\n      for (var i = 0; i < morphingData.length; i++) {\n        var item = morphingData[i];\n        var from = item.from;\n        var to = item.to;\n        var angle = item.rotation * t;\n        var fromCp = item.fromCp;\n        var toCp = item.toCp;\n        var sa = Math.sin(angle);\n        var ca = Math.cos(angle);\n        lerp(newCp, fromCp, toCp, t);\n\n        for (var m = 0; m < from.length; m += 2) {\n          var x0_1 = from[m];\n          var y0_1 = from[m + 1];\n          var x1 = to[m];\n          var y1 = to[m + 1];\n          var x = x0_1 * onet + x1 * t;\n          var y = y0_1 * onet + y1 * t;\n          tmpArr[m] = x * ca - y * sa + newCp[0];\n          tmpArr[m + 1] = x * sa + y * ca + newCp[1];\n        }\n\n        var x0 = tmpArr[0];\n        var y0 = tmpArr[1];\n        path.moveTo(x0, y0);\n\n        for (var m = 2; m < from.length;) {\n          var x1 = tmpArr[m++];\n          var y1 = tmpArr[m++];\n          var x2 = tmpArr[m++];\n          var y2 = tmpArr[m++];\n          var x3 = tmpArr[m++];\n          var y3 = tmpArr[m++];\n\n          if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) {\n            path.lineTo(x3, y3);\n          } else {\n            path.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n          }\n\n          x0 = x3;\n          y0 = y3;\n        }\n      }\n    }\n  });\n}\n\nexport function morphPath(fromPath, toPath, animationOpts) {\n  if (!fromPath || !toPath) {\n    return toPath;\n  }\n\n  var oldDone = animationOpts.done;\n  var oldDuring = animationOpts.during;\n  prepareMorphPath(fromPath, toPath);\n  toPath.__morphT = 0;\n\n  function restoreToPath() {\n    restoreMethod(toPath, 'buildPath');\n    restoreMethod(toPath, 'updateTransform');\n    toPath.__morphT = -1;\n    toPath.createPathProxy();\n    toPath.dirtyShape();\n  }\n\n  toPath.animateTo({\n    __morphT: 1\n  }, defaults({\n    during: function (p) {\n      toPath.dirtyShape();\n      oldDuring && oldDuring(p);\n    },\n    done: function () {\n      restoreToPath();\n      oldDone && oldDone();\n    }\n  }, animationOpts));\n  return toPath;\n}\n\nfunction hilbert(x, y, minX, minY, maxX, maxY) {\n  var bits = 16;\n  x = maxX === minX ? 0 : Math.round(32767 * (x - minX) / (maxX - minX));\n  y = maxY === minY ? 0 : Math.round(32767 * (y - minY) / (maxY - minY));\n  var d = 0;\n  var tmp;\n\n  for (var s = (1 << bits) / 2; s > 0; s /= 2) {\n    var rx = 0;\n    var ry = 0;\n\n    if ((x & s) > 0) {\n      rx = 1;\n    }\n\n    if ((y & s) > 0) {\n      ry = 1;\n    }\n\n    d += s * s * (3 * rx ^ ry);\n\n    if (ry === 0) {\n      if (rx === 1) {\n        x = s - 1 - x;\n        y = s - 1 - y;\n      }\n\n      tmp = x;\n      x = y;\n      y = tmp;\n    }\n  }\n\n  return d;\n}\n\nfunction sortPaths(pathList) {\n  var xMin = Infinity;\n  var yMin = Infinity;\n  var xMax = -Infinity;\n  var yMax = -Infinity;\n  var cps = map(pathList, function (path) {\n    var rect = path.getBoundingRect();\n    var m = path.getComputedTransform();\n    var x = rect.x + rect.width / 2 + (m ? m[4] : 0);\n    var y = rect.y + rect.height / 2 + (m ? m[5] : 0);\n    xMin = Math.min(x, xMin);\n    yMin = Math.min(y, yMin);\n    xMax = Math.max(x, xMax);\n    yMax = Math.max(y, yMax);\n    return [x, y];\n  });\n  var items = map(cps, function (cp, idx) {\n    return {\n      cp: cp,\n      z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),\n      path: pathList[idx]\n    };\n  });\n  return items.sort(function (a, b) {\n    return a.z - b.z;\n  }).map(function (item) {\n    return item.path;\n  });\n}\n\n;\n\nfunction defaultDividePath(param) {\n  return split(param.path, param.count);\n}\n\nfunction createEmptyReturn() {\n  return {\n    fromIndividuals: [],\n    toIndividuals: [],\n    count: 0\n  };\n}\n\nexport function combineMorph(fromList, toPath, animationOpts) {\n  var fromPathList = [];\n\n  function addFromPath(fromList) {\n    for (var i = 0; i < fromList.length; i++) {\n      var from = fromList[i];\n\n      if (isCombineMorphing(from)) {\n        addFromPath(from.childrenRef());\n      } else if (from instanceof Path) {\n        fromPathList.push(from);\n      }\n    }\n  }\n\n  addFromPath(fromList);\n  var separateCount = fromPathList.length;\n\n  if (!separateCount) {\n    return createEmptyReturn();\n  }\n\n  var dividePath = animationOpts.dividePath || defaultDividePath;\n  var toSubPathList = dividePath({\n    path: toPath,\n    count: separateCount\n  });\n\n  if (toSubPathList.length !== separateCount) {\n    console.error('Invalid morphing: unmatched splitted path');\n    return createEmptyReturn();\n  }\n\n  fromPathList = sortPaths(fromPathList);\n  toSubPathList = sortPaths(toSubPathList);\n  var oldDone = animationOpts.done;\n  var oldDuring = animationOpts.during;\n  var individualDelay = animationOpts.individualDelay;\n  var identityTransform = new Transformable();\n\n  for (var i = 0; i < separateCount; i++) {\n    var from = fromPathList[i];\n    var to = toSubPathList[i];\n    to.parent = toPath;\n    to.copyTransform(identityTransform);\n\n    if (!individualDelay) {\n      prepareMorphPath(from, to);\n    }\n  }\n\n  toPath.__isCombineMorphing = true;\n\n  toPath.childrenRef = function () {\n    return toSubPathList;\n  };\n\n  function addToSubPathListToZr(zr) {\n    for (var i = 0; i < toSubPathList.length; i++) {\n      toSubPathList[i].addSelfToZr(zr);\n    }\n  }\n\n  saveAndModifyMethod(toPath, 'addSelfToZr', {\n    after: function (zr) {\n      addToSubPathListToZr(zr);\n    }\n  });\n  saveAndModifyMethod(toPath, 'removeSelfFromZr', {\n    after: function (zr) {\n      for (var i = 0; i < toSubPathList.length; i++) {\n        toSubPathList[i].removeSelfFromZr(zr);\n      }\n    }\n  });\n\n  function restoreToPath() {\n    toPath.__isCombineMorphing = false;\n    toPath.__morphT = -1;\n    toPath.childrenRef = null;\n    restoreMethod(toPath, 'addSelfToZr');\n    restoreMethod(toPath, 'removeSelfFromZr');\n  }\n\n  var toLen = toSubPathList.length;\n\n  if (individualDelay) {\n    var animating_1 = toLen;\n\n    var eachDone = function () {\n      animating_1--;\n\n      if (animating_1 === 0) {\n        restoreToPath();\n        oldDone && oldDone();\n      }\n    };\n\n    for (var i = 0; i < toLen; i++) {\n      var indivdualAnimationOpts = individualDelay ? defaults({\n        delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toSubPathList[i]),\n        done: eachDone\n      }, animationOpts) : animationOpts;\n      morphPath(fromPathList[i], toSubPathList[i], indivdualAnimationOpts);\n    }\n  } else {\n    toPath.__morphT = 0;\n    toPath.animateTo({\n      __morphT: 1\n    }, defaults({\n      during: function (p) {\n        for (var i = 0; i < toLen; i++) {\n          var child = toSubPathList[i];\n          child.__morphT = toPath.__morphT;\n          child.dirtyShape();\n        }\n\n        oldDuring && oldDuring(p);\n      },\n      done: function () {\n        restoreToPath();\n\n        for (var i = 0; i < fromList.length; i++) {\n          restoreMethod(fromList[i], 'updateTransform');\n        }\n\n        oldDone && oldDone();\n      }\n    }, animationOpts));\n  }\n\n  if (toPath.__zr) {\n    addToSubPathListToZr(toPath.__zr);\n  }\n\n  return {\n    fromIndividuals: fromPathList,\n    toIndividuals: toSubPathList,\n    count: toLen\n  };\n}\nexport function separateMorph(fromPath, toPathList, animationOpts) {\n  var toLen = toPathList.length;\n  var fromPathList = [];\n  var dividePath = animationOpts.dividePath || defaultDividePath;\n\n  function addFromPath(fromList) {\n    for (var i = 0; i < fromList.length; i++) {\n      var from = fromList[i];\n\n      if (isCombineMorphing(from)) {\n        addFromPath(from.childrenRef());\n      } else if (from instanceof Path) {\n        fromPathList.push(from);\n      }\n    }\n  }\n\n  if (isCombineMorphing(fromPath)) {\n    addFromPath(fromPath.childrenRef());\n    var fromLen = fromPathList.length;\n\n    if (fromLen < toLen) {\n      var k = 0;\n\n      for (var i = fromLen; i < toLen; i++) {\n        fromPathList.push(clonePath(fromPathList[k++ % fromLen]));\n      }\n    }\n\n    fromPathList.length = toLen;\n  } else {\n    fromPathList = dividePath({\n      path: fromPath,\n      count: toLen\n    });\n    var fromPathTransform = fromPath.getComputedTransform();\n\n    for (var i = 0; i < fromPathList.length; i++) {\n      fromPathList[i].setLocalTransform(fromPathTransform);\n    }\n\n    if (fromPathList.length !== toLen) {\n      console.error('Invalid morphing: unmatched splitted path');\n      return createEmptyReturn();\n    }\n  }\n\n  fromPathList = sortPaths(fromPathList);\n  toPathList = sortPaths(toPathList);\n  var individualDelay = animationOpts.individualDelay;\n\n  for (var i = 0; i < toLen; i++) {\n    var indivdualAnimationOpts = individualDelay ? defaults({\n      delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toPathList[i])\n    }, animationOpts) : animationOpts;\n    morphPath(fromPathList[i], toPathList[i], indivdualAnimationOpts);\n  }\n\n  return {\n    fromIndividuals: fromPathList,\n    toIndividuals: toPathList,\n    count: toPathList.length\n  };\n}\nexport { split as defaultDividePath };","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/zrender/lib/tool/morphPath.js"],"names":["cubicSubdivide","Path","defaults","map","lerp","clonePath","Transformable","split","pathToBezierCurves","alignSubpath","subpath1","subpath2","len1","length","len2","tmpSegX","tmpSegY","shorterPath","shorterLen","Math","min","diff","abs","shorterBezierCount","eachCurveSubDivCount","ceil","newSubpath","remained","i","x0","y0","x1","y1","x2","y2","x3","y3","push","actualSubDivCount","k","p","createSubpath","lastSubpathSubpath","otherSubpath","len","lastX","lastY","alignBezierCurves","array1","array2","_a","lastSubpath1","lastSubpath2","newArray1","newArray2","max","newSubpath1","newSubpath2","centroid","array","signedArea","cx","cy","j","a","findBestRingOffset","fromSubBeziers","toSubBeziers","fromCp","toCp","bezierCount","bestScore","Infinity","bestOffset","offset","cursorOffset","score","idx","dx","dy","reverse","newArr","findBestMorphingRotation","fromArr","toArr","searchAngleIteration","searchAngleRange","result","fromNeedsReverse","fromSubpathBezier","toSubpathBezier","newFromSubpathBezier","newToSubpathBezier","bestAngle","tmpArr","step","angle","sa","sin","ca","cos","newX1","newY1","m","i_1","from","to","rotation","isCombineMorphing","path","__isCombineMorphing","isMorphing","el","__morphT","SAVED_METHOD_PREFIX","saveAndModifyMethod","obj","methodName","modifiers","savedMethodName","originalMethod","replace","after","before","args","arguments","res","apply","restoreMethod","applyTransformOnBeziers","bezierCurves","mm","subBeziers","x","y","prepareMorphPath","fromPath","toPath","fromPathProxy","getUpdatedPathProxy","toPathProxy","fromBezierCurves","toBezierCurves","fromPathTransform","getComputedTransform","toPathTransform","updateIdentityTransform","transform","morphingData","PI","t","onet","newCp","item","x0_1","y0_1","moveTo","lineTo","bezierCurveTo","morphPath","animationOpts","oldDone","done","oldDuring","during","restoreToPath","createPathProxy","dirtyShape","animateTo","hilbert","minX","minY","maxX","maxY","bits","round","d","tmp","s","rx","ry","sortPaths","pathList","xMin","yMin","xMax","yMax","cps","rect","getBoundingRect","width","height","items","cp","z","sort","b","defaultDividePath","param","count","createEmptyReturn","fromIndividuals","toIndividuals","combineMorph","fromList","fromPathList","addFromPath","childrenRef","separateCount","dividePath","toSubPathList","console","error","individualDelay","identityTransform","parent","copyTransform","addToSubPathListToZr","zr","addSelfToZr","removeSelfFromZr","toLen","animating_1","eachDone","indivdualAnimationOpts","delay","child","__zr","separateMorph","toPathList","fromLen","setLocalTransform"],"mappings":"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","sourcesContent":["import { cubicSubdivide } from '../core/curve';\nimport Path from '../graphic/Path';\nimport { defaults, map } from '../core/util';\nimport { lerp } from '../core/vector';\nimport { clonePath } from './path';\nimport Transformable from '../core/Transformable';\nimport { split } from './dividePath';\nimport { pathToBezierCurves } from './convertPath';\nfunction alignSubpath(subpath1, subpath2) {\n    var len1 = subpath1.length;\n    var len2 = subpath2.length;\n    if (len1 === len2) {\n        return [subpath1, subpath2];\n    }\n    var tmpSegX = [];\n    var tmpSegY = [];\n    var shorterPath = len1 < len2 ? subpath1 : subpath2;\n    var shorterLen = Math.min(len1, len2);\n    var diff = Math.abs(len2 - len1) / 6;\n    var shorterBezierCount = (shorterLen - 2) / 6;\n    var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n    var newSubpath = [shorterPath[0], shorterPath[1]];\n    var remained = diff;\n    for (var i = 2; i < shorterLen;) {\n        var x0 = shorterPath[i - 2];\n        var y0 = shorterPath[i - 1];\n        var x1 = shorterPath[i++];\n        var y1 = shorterPath[i++];\n        var x2 = shorterPath[i++];\n        var y2 = shorterPath[i++];\n        var x3 = shorterPath[i++];\n        var y3 = shorterPath[i++];\n        if (remained <= 0) {\n            newSubpath.push(x1, y1, x2, y2, x3, y3);\n            continue;\n        }\n        var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n        for (var k = 1; k <= actualSubDivCount; k++) {\n            var p = k / actualSubDivCount;\n            cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n            cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n            x0 = tmpSegX[3];\n            y0 = tmpSegY[3];\n            newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n            x1 = tmpSegX[5];\n            y1 = tmpSegY[5];\n            x2 = tmpSegX[6];\n            y2 = tmpSegY[6];\n        }\n        remained -= actualSubDivCount - 1;\n    }\n    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n    var len = lastSubpathSubpath.length;\n    var lastX = lastSubpathSubpath[len - 2];\n    var lastY = lastSubpathSubpath[len - 1];\n    var newSubpath = [];\n    for (var i = 0; i < otherSubpath.length;) {\n        newSubpath[i++] = lastX;\n        newSubpath[i++] = lastY;\n    }\n    return newSubpath;\n}\nexport function alignBezierCurves(array1, array2) {\n    var _a;\n    var lastSubpath1;\n    var lastSubpath2;\n    var newArray1 = [];\n    var newArray2 = [];\n    for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n        var subpath1 = array1[i];\n        var subpath2 = array2[i];\n        var newSubpath1 = void 0;\n        var newSubpath2 = void 0;\n        if (!subpath1) {\n            newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n            newSubpath2 = subpath2;\n        }\n        else if (!subpath2) {\n            newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n            newSubpath1 = subpath1;\n        }\n        else {\n            _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n            lastSubpath1 = newSubpath1;\n            lastSubpath2 = newSubpath2;\n        }\n        newArray1.push(newSubpath1);\n        newArray2.push(newSubpath2);\n    }\n    return [newArray1, newArray2];\n}\nexport function centroid(array) {\n    var signedArea = 0;\n    var cx = 0;\n    var cy = 0;\n    var len = array.length;\n    for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n        var x0 = array[j];\n        var y0 = array[j + 1];\n        var x1 = array[i];\n        var y1 = array[i + 1];\n        var a = x0 * y1 - x1 * y0;\n        signedArea += a;\n        cx += (x0 + x1) * a;\n        cy += (y0 + y1) * a;\n    }\n    if (signedArea === 0) {\n        return [array[0] || 0, array[1] || 0];\n    }\n    return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n    var bezierCount = (fromSubBeziers.length - 2) / 6;\n    var bestScore = Infinity;\n    var bestOffset = 0;\n    var len = fromSubBeziers.length;\n    var len2 = len - 2;\n    for (var offset = 0; offset < bezierCount; offset++) {\n        var cursorOffset = offset * 6;\n        var score = 0;\n        for (var k = 0; k < len; k += 2) {\n            var idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2 + 2);\n            var x0 = fromSubBeziers[idx] - fromCp[0];\n            var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n            var x1 = toSubBeziers[k] - toCp[0];\n            var y1 = toSubBeziers[k + 1] - toCp[1];\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            score += dx * dx + dy * dy;\n        }\n        if (score < bestScore) {\n            bestScore = score;\n            bestOffset = offset;\n        }\n    }\n    return bestOffset;\n}\nfunction reverse(array) {\n    var newArr = [];\n    var len = array.length;\n    for (var i = 0; i < len; i += 2) {\n        newArr[i] = array[len - i - 2];\n        newArr[i + 1] = array[len - i - 1];\n    }\n    return newArr;\n}\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n    var result = [];\n    var fromNeedsReverse;\n    for (var i = 0; i < fromArr.length; i++) {\n        var fromSubpathBezier = fromArr[i];\n        var toSubpathBezier = toArr[i];\n        var fromCp = centroid(fromSubpathBezier);\n        var toCp = centroid(toSubpathBezier);\n        if (fromNeedsReverse == null) {\n            fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n        }\n        var newFromSubpathBezier = [];\n        var newToSubpathBezier = [];\n        var bestAngle = 0;\n        var bestScore = Infinity;\n        var tmpArr = [];\n        var len = fromSubpathBezier.length;\n        if (fromNeedsReverse) {\n            fromSubpathBezier = reverse(fromSubpathBezier);\n        }\n        var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n        var len2 = len - 2;\n        for (var k = 0; k < len2; k += 2) {\n            var idx = (offset + k) % len2 + 2;\n            newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n            newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n        }\n        newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n        newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n        if (searchAngleIteration > 0) {\n            var step = searchAngleRange / searchAngleIteration;\n            for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n                var sa = Math.sin(angle);\n                var ca = Math.cos(angle);\n                var score = 0;\n                for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n                    var x0 = newFromSubpathBezier[k];\n                    var y0 = newFromSubpathBezier[k + 1];\n                    var x1 = toSubpathBezier[k] - toCp[0];\n                    var y1 = toSubpathBezier[k + 1] - toCp[1];\n                    var newX1 = x1 * ca - y1 * sa;\n                    var newY1 = x1 * sa + y1 * ca;\n                    tmpArr[k] = newX1;\n                    tmpArr[k + 1] = newY1;\n                    var dx = newX1 - x0;\n                    var dy = newY1 - y0;\n                    score += dx * dx + dy * dy;\n                }\n                if (score < bestScore) {\n                    bestScore = score;\n                    bestAngle = angle;\n                    for (var m = 0; m < tmpArr.length; m++) {\n                        newToSubpathBezier[m] = tmpArr[m];\n                    }\n                }\n            }\n        }\n        else {\n            for (var i_1 = 0; i_1 < len; i_1 += 2) {\n                newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n                newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n            }\n        }\n        result.push({\n            from: newFromSubpathBezier,\n            to: newToSubpathBezier,\n            fromCp: fromCp,\n            toCp: toCp,\n            rotation: -bestAngle\n        });\n    }\n    return result;\n}\nexport function isCombineMorphing(path) {\n    return path.__isCombineMorphing;\n}\nexport function isMorphing(el) {\n    return el.__morphT >= 0;\n}\nvar SAVED_METHOD_PREFIX = '__mOriginal_';\nfunction saveAndModifyMethod(obj, methodName, modifiers) {\n    var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n    var originalMethod = obj[savedMethodName] || obj[methodName];\n    if (!obj[savedMethodName]) {\n        obj[savedMethodName] = obj[methodName];\n    }\n    var replace = modifiers.replace;\n    var after = modifiers.after;\n    var before = modifiers.before;\n    obj[methodName] = function () {\n        var args = arguments;\n        var res;\n        before && before.apply(this, args);\n        if (replace) {\n            res = replace.apply(this, args);\n        }\n        else {\n            res = originalMethod.apply(this, args);\n        }\n        after && after.apply(this, args);\n        return res;\n    };\n}\nfunction restoreMethod(obj, methodName) {\n    var savedMethodName = SAVED_METHOD_PREFIX + methodName;\n    if (obj[savedMethodName]) {\n        obj[methodName] = obj[savedMethodName];\n        obj[savedMethodName] = null;\n    }\n}\nfunction applyTransformOnBeziers(bezierCurves, mm) {\n    for (var i = 0; i < bezierCurves.length; i++) {\n        var subBeziers = bezierCurves[i];\n        for (var k = 0; k < subBeziers.length;) {\n            var x = subBeziers[k];\n            var y = subBeziers[k + 1];\n            subBeziers[k++] = mm[0] * x + mm[2] * y + mm[4];\n            subBeziers[k++] = mm[1] * x + mm[3] * y + mm[5];\n        }\n    }\n}\nfunction prepareMorphPath(fromPath, toPath) {\n    var fromPathProxy = fromPath.getUpdatedPathProxy();\n    var toPathProxy = toPath.getUpdatedPathProxy();\n    var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a[0], toBezierCurves = _a[1];\n    var fromPathTransform = fromPath.getComputedTransform();\n    var toPathTransform = toPath.getComputedTransform();\n    function updateIdentityTransform() {\n        this.transform = null;\n    }\n    fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);\n    toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);\n    saveAndModifyMethod(toPath, 'updateTransform', { replace: updateIdentityTransform });\n    toPath.transform = null;\n    var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n    var tmpArr = [];\n    saveAndModifyMethod(toPath, 'buildPath', { replace: function (path) {\n            var t = toPath.__morphT;\n            var onet = 1 - t;\n            var newCp = [];\n            for (var i = 0; i < morphingData.length; i++) {\n                var item = morphingData[i];\n                var from = item.from;\n                var to = item.to;\n                var angle = item.rotation * t;\n                var fromCp = item.fromCp;\n                var toCp = item.toCp;\n                var sa = Math.sin(angle);\n                var ca = Math.cos(angle);\n                lerp(newCp, fromCp, toCp, t);\n                for (var m = 0; m < from.length; m += 2) {\n                    var x0_1 = from[m];\n                    var y0_1 = from[m + 1];\n                    var x1 = to[m];\n                    var y1 = to[m + 1];\n                    var x = x0_1 * onet + x1 * t;\n                    var y = y0_1 * onet + y1 * t;\n                    tmpArr[m] = (x * ca - y * sa) + newCp[0];\n                    tmpArr[m + 1] = (x * sa + y * ca) + newCp[1];\n                }\n                var x0 = tmpArr[0];\n                var y0 = tmpArr[1];\n                path.moveTo(x0, y0);\n                for (var m = 2; m < from.length;) {\n                    var x1 = tmpArr[m++];\n                    var y1 = tmpArr[m++];\n                    var x2 = tmpArr[m++];\n                    var y2 = tmpArr[m++];\n                    var x3 = tmpArr[m++];\n                    var y3 = tmpArr[m++];\n                    if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) {\n                        path.lineTo(x3, y3);\n                    }\n                    else {\n                        path.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n                    }\n                    x0 = x3;\n                    y0 = y3;\n                }\n            }\n        } });\n}\nexport function morphPath(fromPath, toPath, animationOpts) {\n    if (!fromPath || !toPath) {\n        return toPath;\n    }\n    var oldDone = animationOpts.done;\n    var oldDuring = animationOpts.during;\n    prepareMorphPath(fromPath, toPath);\n    toPath.__morphT = 0;\n    function restoreToPath() {\n        restoreMethod(toPath, 'buildPath');\n        restoreMethod(toPath, 'updateTransform');\n        toPath.__morphT = -1;\n        toPath.createPathProxy();\n        toPath.dirtyShape();\n    }\n    toPath.animateTo({\n        __morphT: 1\n    }, defaults({\n        during: function (p) {\n            toPath.dirtyShape();\n            oldDuring && oldDuring(p);\n        },\n        done: function () {\n            restoreToPath();\n            oldDone && oldDone();\n        }\n    }, animationOpts));\n    return toPath;\n}\nfunction hilbert(x, y, minX, minY, maxX, maxY) {\n    var bits = 16;\n    x = (maxX === minX) ? 0 : Math.round(32767 * (x - minX) / (maxX - minX));\n    y = (maxY === minY) ? 0 : Math.round(32767 * (y - minY) / (maxY - minY));\n    var d = 0;\n    var tmp;\n    for (var s = (1 << bits) / 2; s > 0; s /= 2) {\n        var rx = 0;\n        var ry = 0;\n        if ((x & s) > 0) {\n            rx = 1;\n        }\n        if ((y & s) > 0) {\n            ry = 1;\n        }\n        d += s * s * ((3 * rx) ^ ry);\n        if (ry === 0) {\n            if (rx === 1) {\n                x = s - 1 - x;\n                y = s - 1 - y;\n            }\n            tmp = x;\n            x = y;\n            y = tmp;\n        }\n    }\n    return d;\n}\nfunction sortPaths(pathList) {\n    var xMin = Infinity;\n    var yMin = Infinity;\n    var xMax = -Infinity;\n    var yMax = -Infinity;\n    var cps = map(pathList, function (path) {\n        var rect = path.getBoundingRect();\n        var m = path.getComputedTransform();\n        var x = rect.x + rect.width / 2 + (m ? m[4] : 0);\n        var y = rect.y + rect.height / 2 + (m ? m[5] : 0);\n        xMin = Math.min(x, xMin);\n        yMin = Math.min(y, yMin);\n        xMax = Math.max(x, xMax);\n        yMax = Math.max(y, yMax);\n        return [x, y];\n    });\n    var items = map(cps, function (cp, idx) {\n        return {\n            cp: cp,\n            z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),\n            path: pathList[idx]\n        };\n    });\n    return items.sort(function (a, b) { return a.z - b.z; }).map(function (item) { return item.path; });\n}\n;\nfunction defaultDividePath(param) {\n    return split(param.path, param.count);\n}\nfunction createEmptyReturn() {\n    return {\n        fromIndividuals: [],\n        toIndividuals: [],\n        count: 0\n    };\n}\nexport function combineMorph(fromList, toPath, animationOpts) {\n    var fromPathList = [];\n    function addFromPath(fromList) {\n        for (var i = 0; i < fromList.length; i++) {\n            var from = fromList[i];\n            if (isCombineMorphing(from)) {\n                addFromPath(from.childrenRef());\n            }\n            else if (from instanceof Path) {\n                fromPathList.push(from);\n            }\n        }\n    }\n    addFromPath(fromList);\n    var separateCount = fromPathList.length;\n    if (!separateCount) {\n        return createEmptyReturn();\n    }\n    var dividePath = animationOpts.dividePath || defaultDividePath;\n    var toSubPathList = dividePath({\n        path: toPath, count: separateCount\n    });\n    if (toSubPathList.length !== separateCount) {\n        console.error('Invalid morphing: unmatched splitted path');\n        return createEmptyReturn();\n    }\n    fromPathList = sortPaths(fromPathList);\n    toSubPathList = sortPaths(toSubPathList);\n    var oldDone = animationOpts.done;\n    var oldDuring = animationOpts.during;\n    var individualDelay = animationOpts.individualDelay;\n    var identityTransform = new Transformable();\n    for (var i = 0; i < separateCount; i++) {\n        var from = fromPathList[i];\n        var to = toSubPathList[i];\n        to.parent = toPath;\n        to.copyTransform(identityTransform);\n        if (!individualDelay) {\n            prepareMorphPath(from, to);\n        }\n    }\n    toPath.__isCombineMorphing = true;\n    toPath.childrenRef = function () {\n        return toSubPathList;\n    };\n    function addToSubPathListToZr(zr) {\n        for (var i = 0; i < toSubPathList.length; i++) {\n            toSubPathList[i].addSelfToZr(zr);\n        }\n    }\n    saveAndModifyMethod(toPath, 'addSelfToZr', {\n        after: function (zr) {\n            addToSubPathListToZr(zr);\n        }\n    });\n    saveAndModifyMethod(toPath, 'removeSelfFromZr', {\n        after: function (zr) {\n            for (var i = 0; i < toSubPathList.length; i++) {\n                toSubPathList[i].removeSelfFromZr(zr);\n            }\n        }\n    });\n    function restoreToPath() {\n        toPath.__isCombineMorphing = false;\n        toPath.__morphT = -1;\n        toPath.childrenRef = null;\n        restoreMethod(toPath, 'addSelfToZr');\n        restoreMethod(toPath, 'removeSelfFromZr');\n    }\n    var toLen = toSubPathList.length;\n    if (individualDelay) {\n        var animating_1 = toLen;\n        var eachDone = function () {\n            animating_1--;\n            if (animating_1 === 0) {\n                restoreToPath();\n                oldDone && oldDone();\n            }\n        };\n        for (var i = 0; i < toLen; i++) {\n            var indivdualAnimationOpts = individualDelay ? defaults({\n                delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toSubPathList[i]),\n                done: eachDone\n            }, animationOpts) : animationOpts;\n            morphPath(fromPathList[i], toSubPathList[i], indivdualAnimationOpts);\n        }\n    }\n    else {\n        toPath.__morphT = 0;\n        toPath.animateTo({\n            __morphT: 1\n        }, defaults({\n            during: function (p) {\n                for (var i = 0; i < toLen; i++) {\n                    var child = toSubPathList[i];\n                    child.__morphT = toPath.__morphT;\n                    child.dirtyShape();\n                }\n                oldDuring && oldDuring(p);\n            },\n            done: function () {\n                restoreToPath();\n                for (var i = 0; i < fromList.length; i++) {\n                    restoreMethod(fromList[i], 'updateTransform');\n                }\n                oldDone && oldDone();\n            }\n        }, animationOpts));\n    }\n    if (toPath.__zr) {\n        addToSubPathListToZr(toPath.__zr);\n    }\n    return {\n        fromIndividuals: fromPathList,\n        toIndividuals: toSubPathList,\n        count: toLen\n    };\n}\nexport function separateMorph(fromPath, toPathList, animationOpts) {\n    var toLen = toPathList.length;\n    var fromPathList = [];\n    var dividePath = animationOpts.dividePath || defaultDividePath;\n    function addFromPath(fromList) {\n        for (var i = 0; i < fromList.length; i++) {\n            var from = fromList[i];\n            if (isCombineMorphing(from)) {\n                addFromPath(from.childrenRef());\n            }\n            else if (from instanceof Path) {\n                fromPathList.push(from);\n            }\n        }\n    }\n    if (isCombineMorphing(fromPath)) {\n        addFromPath(fromPath.childrenRef());\n        var fromLen = fromPathList.length;\n        if (fromLen < toLen) {\n            var k = 0;\n            for (var i = fromLen; i < toLen; i++) {\n                fromPathList.push(clonePath(fromPathList[k++ % fromLen]));\n            }\n        }\n        fromPathList.length = toLen;\n    }\n    else {\n        fromPathList = dividePath({ path: fromPath, count: toLen });\n        var fromPathTransform = fromPath.getComputedTransform();\n        for (var i = 0; i < fromPathList.length; i++) {\n            fromPathList[i].setLocalTransform(fromPathTransform);\n        }\n        if (fromPathList.length !== toLen) {\n            console.error('Invalid morphing: unmatched splitted path');\n            return createEmptyReturn();\n        }\n    }\n    fromPathList = sortPaths(fromPathList);\n    toPathList = sortPaths(toPathList);\n    var individualDelay = animationOpts.individualDelay;\n    for (var i = 0; i < toLen; i++) {\n        var indivdualAnimationOpts = individualDelay ? defaults({\n            delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toPathList[i])\n        }, animationOpts) : animationOpts;\n        morphPath(fromPathList[i], toPathList[i], indivdualAnimationOpts);\n    }\n    return {\n        fromIndividuals: fromPathList,\n        toIndividuals: toPathList,\n        count: toPathList.length\n    };\n}\nexport { split as defaultDividePath };\n"]},"metadata":{},"sourceType":"module"}