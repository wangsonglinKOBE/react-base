{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport * as zrUtil from 'zrender/lib/core/util';\nimport * as graphic from '../../util/graphic';\nimport { enableHoverEmphasis } from '../../util/states';\nimport { createSymbol, normalizeSymbolOffset } from '../../util/symbol';\nimport { parsePercent, isNumeric } from '../../util/number';\nimport ChartView from '../../view/Chart';\nimport { getDefaultLabel } from '../helper/labelHelper';\nimport { setLabelStyle, getLabelStatesModels } from '../../label/labelStyle';\nimport ZRImage from 'zrender/lib/graphic/Image';\nimport { getECData } from '../../util/innerStore';\nvar BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'borderWidth']; // index: +isHorizontal\n\nvar LAYOUT_ATTRS = [{\n  xy: 'x',\n  wh: 'width',\n  index: 0,\n  posDesc: ['left', 'right']\n}, {\n  xy: 'y',\n  wh: 'height',\n  index: 1,\n  posDesc: ['top', 'bottom']\n}];\nvar pathForLineWidth = new graphic.Circle();\n\nvar PictorialBarView =\n/** @class */\nfunction (_super) {\n  __extends(PictorialBarView, _super);\n\n  function PictorialBarView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = PictorialBarView.type;\n    return _this;\n  }\n\n  PictorialBarView.prototype.render = function (seriesModel, ecModel, api) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var isHorizontal = baseAxis.isHorizontal();\n    var coordSysRect = cartesian.master.getRect();\n    var opt = {\n      ecSize: {\n        width: api.getWidth(),\n        height: api.getHeight()\n      },\n      seriesModel: seriesModel,\n      coordSys: cartesian,\n      coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],\n      isHorizontal: isHorizontal,\n      valueDim: LAYOUT_ATTRS[+isHorizontal],\n      categoryDim: LAYOUT_ATTRS[1 - +isHorizontal]\n    };\n    data.diff(oldData).add(function (dataIndex) {\n      if (!data.hasValue(dataIndex)) {\n        return;\n      }\n\n      var itemModel = getItemModel(data, dataIndex);\n      var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);\n      var bar = createBar(data, opt, symbolMeta);\n      data.setItemGraphicEl(dataIndex, bar);\n      group.add(bar);\n      updateCommon(bar, opt, symbolMeta);\n    }).update(function (newIndex, oldIndex) {\n      var bar = oldData.getItemGraphicEl(oldIndex);\n\n      if (!data.hasValue(newIndex)) {\n        group.remove(bar);\n        return;\n      }\n\n      var itemModel = getItemModel(data, newIndex);\n      var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);\n      var pictorialShapeStr = getShapeStr(data, symbolMeta);\n\n      if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {\n        group.remove(bar);\n        data.setItemGraphicEl(newIndex, null);\n        bar = null;\n      }\n\n      if (bar) {\n        updateBar(bar, opt, symbolMeta);\n      } else {\n        bar = createBar(data, opt, symbolMeta, true);\n      }\n\n      data.setItemGraphicEl(newIndex, bar);\n      bar.__pictorialSymbolMeta = symbolMeta; // Add back\n\n      group.add(bar);\n      updateCommon(bar, opt, symbolMeta);\n    }).remove(function (dataIndex) {\n      var bar = oldData.getItemGraphicEl(dataIndex);\n      bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);\n    }).execute();\n    this._data = data;\n    return this.group;\n  };\n\n  PictorialBarView.prototype.remove = function (ecModel, api) {\n    var group = this.group;\n    var data = this._data;\n\n    if (ecModel.get('animation')) {\n      if (data) {\n        data.eachItemGraphicEl(function (bar) {\n          removeBar(data, getECData(bar).dataIndex, ecModel, bar);\n        });\n      }\n    } else {\n      group.removeAll();\n    }\n  };\n\n  PictorialBarView.type = 'pictorialBar';\n  return PictorialBarView;\n}(ChartView); // Set or calculate default value about symbol, and calculate layout info.\n\n\nfunction getSymbolMeta(data, dataIndex, itemModel, opt) {\n  var layout = data.getItemLayout(dataIndex);\n  var symbolRepeat = itemModel.get('symbolRepeat');\n  var symbolClip = itemModel.get('symbolClip');\n  var symbolPosition = itemModel.get('symbolPosition') || 'start';\n  var symbolRotate = itemModel.get('symbolRotate');\n  var rotation = (symbolRotate || 0) * Math.PI / 180 || 0;\n  var symbolPatternSize = itemModel.get('symbolPatternSize') || 2;\n  var isAnimationEnabled = itemModel.isAnimationEnabled();\n  var symbolMeta = {\n    dataIndex: dataIndex,\n    layout: layout,\n    itemModel: itemModel,\n    symbolType: data.getItemVisual(dataIndex, 'symbol') || 'circle',\n    style: data.getItemVisual(dataIndex, 'style'),\n    symbolClip: symbolClip,\n    symbolRepeat: symbolRepeat,\n    symbolRepeatDirection: itemModel.get('symbolRepeatDirection'),\n    symbolPatternSize: symbolPatternSize,\n    rotation: rotation,\n    animationModel: isAnimationEnabled ? itemModel : null,\n    hoverScale: isAnimationEnabled && itemModel.get(['emphasis', 'scale']),\n    z2: itemModel.getShallow('z', true) || 0\n  };\n  prepareBarLength(itemModel, symbolRepeat, layout, opt, symbolMeta);\n  prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);\n  prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);\n  var symbolSize = symbolMeta.symbolSize;\n  var symbolOffset = normalizeSymbolOffset(itemModel.get('symbolOffset'), symbolSize);\n  prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);\n  return symbolMeta;\n} // bar length can be negative.\n\n\nfunction prepareBarLength(itemModel, symbolRepeat, layout, opt, outputSymbolMeta) {\n  var valueDim = opt.valueDim;\n  var symbolBoundingData = itemModel.get('symbolBoundingData');\n  var valueAxis = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());\n  var zeroPx = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0));\n  var pxSignIdx = 1 - +(layout[valueDim.wh] <= 0);\n  var boundingLength;\n\n  if (zrUtil.isArray(symbolBoundingData)) {\n    var symbolBoundingExtent = [convertToCoordOnAxis(valueAxis, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis, symbolBoundingData[1]) - zeroPx];\n    symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();\n    boundingLength = symbolBoundingExtent[pxSignIdx];\n  } else if (symbolBoundingData != null) {\n    boundingLength = convertToCoordOnAxis(valueAxis, symbolBoundingData) - zeroPx;\n  } else if (symbolRepeat) {\n    boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;\n  } else {\n    boundingLength = layout[valueDim.wh];\n  }\n\n  outputSymbolMeta.boundingLength = boundingLength;\n\n  if (symbolRepeat) {\n    outputSymbolMeta.repeatCutLength = layout[valueDim.wh];\n  }\n\n  outputSymbolMeta.pxSign = boundingLength > 0 ? 1 : boundingLength < 0 ? -1 : 0;\n}\n\nfunction convertToCoordOnAxis(axis, value) {\n  return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));\n} // Support ['100%', '100%']\n\n\nfunction prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, outputSymbolMeta) {\n  var valueDim = opt.valueDim;\n  var categoryDim = opt.categoryDim;\n  var categorySize = Math.abs(layout[categoryDim.wh]);\n  var symbolSize = data.getItemVisual(dataIndex, 'symbolSize');\n  var parsedSymbolSize;\n\n  if (zrUtil.isArray(symbolSize)) {\n    parsedSymbolSize = symbolSize.slice();\n  } else {\n    if (symbolSize == null) {\n      // will parse to number below\n      parsedSymbolSize = ['100%', '100%'];\n    } else {\n      parsedSymbolSize = [symbolSize, symbolSize];\n    }\n  } // Note: percentage symbolSize (like '100%') do not consider lineWidth, because it is\n  // to complicated to calculate real percent value if considering scaled lineWidth.\n  // So the actual size will bigger than layout size if lineWidth is bigger than zero,\n  // which can be tolerated in pictorial chart.\n\n\n  parsedSymbolSize[categoryDim.index] = parsePercent(parsedSymbolSize[categoryDim.index], categorySize);\n  parsedSymbolSize[valueDim.index] = parsePercent(parsedSymbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));\n  outputSymbolMeta.symbolSize = parsedSymbolSize; // If x or y is less than zero, show reversed shape.\n\n  var symbolScale = outputSymbolMeta.symbolScale = [parsedSymbolSize[0] / symbolPatternSize, parsedSymbolSize[1] / symbolPatternSize]; // Follow convention, 'right' and 'top' is the normal scale.\n\n  symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;\n}\n\nfunction prepareLineWidth(itemModel, symbolScale, rotation, opt, outputSymbolMeta) {\n  // In symbols are drawn with scale, so do not need to care about the case that width\n  // or height are too small. But symbol use strokeNoScale, where acture lineWidth should\n  // be calculated.\n  var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n\n  if (valueLineWidth) {\n    pathForLineWidth.attr({\n      scaleX: symbolScale[0],\n      scaleY: symbolScale[1],\n      rotation: rotation\n    });\n    pathForLineWidth.updateTransform();\n    valueLineWidth /= pathForLineWidth.getLineScale();\n    valueLineWidth *= symbolScale[opt.valueDim.index];\n  }\n\n  outputSymbolMeta.valueLineWidth = valueLineWidth;\n}\n\nfunction prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, outputSymbolMeta) {\n  var categoryDim = opt.categoryDim;\n  var valueDim = opt.valueDim;\n  var pxSign = outputSymbolMeta.pxSign;\n  var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);\n  var pathLen = unitLength; // Note: rotation will not effect the layout of symbols, because user may\n  // want symbols to rotate on its center, which should not be translated\n  // when rotating.\n\n  if (symbolRepeat) {\n    var absBoundingLength = Math.abs(boundingLength);\n    var symbolMargin = zrUtil.retrieve(itemModel.get('symbolMargin'), '15%') + '';\n    var hasEndGap = false;\n\n    if (symbolMargin.lastIndexOf('!') === symbolMargin.length - 1) {\n      hasEndGap = true;\n      symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);\n    }\n\n    var symbolMarginNumeric = parsePercent(symbolMargin, symbolSize[valueDim.index]);\n    var uLenWithMargin = Math.max(unitLength + symbolMarginNumeric * 2, 0); // When symbol margin is less than 0, margin at both ends will be subtracted\n    // to ensure that all of the symbols will not be overflow the given area.\n\n    var endFix = hasEndGap ? 0 : symbolMarginNumeric * 2; // Both final repeatTimes and final symbolMarginNumeric area calculated based on\n    // boundingLength.\n\n    var repeatSpecified = isNumeric(symbolRepeat);\n    var repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin); // Adjust calculate margin, to ensure each symbol is displayed\n    // entirely in the given layout area.\n\n    var mDiff = absBoundingLength - repeatTimes * unitLength;\n    symbolMarginNumeric = mDiff / 2 / (hasEndGap ? repeatTimes : Math.max(repeatTimes - 1, 1));\n    uLenWithMargin = unitLength + symbolMarginNumeric * 2;\n    endFix = hasEndGap ? 0 : symbolMarginNumeric * 2; // Update repeatTimes when not all symbol will be shown.\n\n    if (!repeatSpecified && symbolRepeat !== 'fixed') {\n      repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;\n    }\n\n    pathLen = repeatTimes * uLenWithMargin - endFix;\n    outputSymbolMeta.repeatTimes = repeatTimes;\n    outputSymbolMeta.symbolMargin = symbolMarginNumeric;\n  }\n\n  var sizeFix = pxSign * (pathLen / 2);\n  var pathPosition = outputSymbolMeta.pathPosition = [];\n  pathPosition[categoryDim.index] = layout[categoryDim.wh] / 2;\n  pathPosition[valueDim.index] = symbolPosition === 'start' ? sizeFix : symbolPosition === 'end' ? boundingLength - sizeFix : boundingLength / 2; // 'center'\n\n  if (symbolOffset) {\n    pathPosition[0] += symbolOffset[0];\n    pathPosition[1] += symbolOffset[1];\n  }\n\n  var bundlePosition = outputSymbolMeta.bundlePosition = [];\n  bundlePosition[categoryDim.index] = layout[categoryDim.xy];\n  bundlePosition[valueDim.index] = layout[valueDim.xy];\n  var barRectShape = outputSymbolMeta.barRectShape = zrUtil.extend({}, layout);\n  barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));\n  barRectShape[categoryDim.wh] = layout[categoryDim.wh];\n  var clipShape = outputSymbolMeta.clipShape = {}; // Consider that symbol may be overflow layout rect.\n\n  clipShape[categoryDim.xy] = -layout[categoryDim.xy];\n  clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];\n  clipShape[valueDim.xy] = 0;\n  clipShape[valueDim.wh] = layout[valueDim.wh];\n}\n\nfunction createPath(symbolMeta) {\n  var symbolPatternSize = symbolMeta.symbolPatternSize;\n  var path = createSymbol( // Consider texture img, make a big size.\n  symbolMeta.symbolType, -symbolPatternSize / 2, -symbolPatternSize / 2, symbolPatternSize, symbolPatternSize);\n  path.attr({\n    culling: true\n  });\n  path.type !== 'image' && path.setStyle({\n    strokeNoScale: true\n  });\n  return path;\n}\n\nfunction createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {\n  var bundle = bar.__pictorialBundle;\n  var symbolSize = symbolMeta.symbolSize;\n  var valueLineWidth = symbolMeta.valueLineWidth;\n  var pathPosition = symbolMeta.pathPosition;\n  var valueDim = opt.valueDim;\n  var repeatTimes = symbolMeta.repeatTimes || 0;\n  var index = 0;\n  var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;\n  eachPath(bar, function (path) {\n    path.__pictorialAnimationIndex = index;\n    path.__pictorialRepeatTimes = repeatTimes;\n\n    if (index < repeatTimes) {\n      updateAttr(path, null, makeTarget(index), symbolMeta, isUpdate);\n    } else {\n      updateAttr(path, null, {\n        scaleX: 0,\n        scaleY: 0\n      }, symbolMeta, isUpdate, function () {\n        bundle.remove(path);\n      });\n    } // updateHoverAnimation(path, symbolMeta);\n\n\n    index++;\n  });\n\n  for (; index < repeatTimes; index++) {\n    var path = createPath(symbolMeta);\n    path.__pictorialAnimationIndex = index;\n    path.__pictorialRepeatTimes = repeatTimes;\n    bundle.add(path);\n    var target = makeTarget(index);\n    updateAttr(path, {\n      x: target.x,\n      y: target.y,\n      scaleX: 0,\n      scaleY: 0\n    }, {\n      scaleX: target.scaleX,\n      scaleY: target.scaleY,\n      rotation: target.rotation\n    }, symbolMeta, isUpdate);\n  }\n\n  function makeTarget(index) {\n    var position = pathPosition.slice(); // (start && pxSign > 0) || (end && pxSign < 0): i = repeatTimes - index\n    // Otherwise: i = index;\n\n    var pxSign = symbolMeta.pxSign;\n    var i = index;\n\n    if (symbolMeta.symbolRepeatDirection === 'start' ? pxSign > 0 : pxSign < 0) {\n      i = repeatTimes - 1 - index;\n    }\n\n    position[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];\n    return {\n      x: position[0],\n      y: position[1],\n      scaleX: symbolMeta.symbolScale[0],\n      scaleY: symbolMeta.symbolScale[1],\n      rotation: symbolMeta.rotation\n    };\n  }\n}\n\nfunction createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {\n  var bundle = bar.__pictorialBundle;\n  var mainPath = bar.__pictorialMainPath;\n\n  if (!mainPath) {\n    mainPath = bar.__pictorialMainPath = createPath(symbolMeta);\n    bundle.add(mainPath);\n    updateAttr(mainPath, {\n      x: symbolMeta.pathPosition[0],\n      y: symbolMeta.pathPosition[1],\n      scaleX: 0,\n      scaleY: 0,\n      rotation: symbolMeta.rotation\n    }, {\n      scaleX: symbolMeta.symbolScale[0],\n      scaleY: symbolMeta.symbolScale[1]\n    }, symbolMeta, isUpdate);\n  } else {\n    updateAttr(mainPath, null, {\n      x: symbolMeta.pathPosition[0],\n      y: symbolMeta.pathPosition[1],\n      scaleX: symbolMeta.symbolScale[0],\n      scaleY: symbolMeta.symbolScale[1],\n      rotation: symbolMeta.rotation\n    }, symbolMeta, isUpdate);\n  }\n} // bar rect is used for label.\n\n\nfunction createOrUpdateBarRect(bar, symbolMeta, isUpdate) {\n  var rectShape = zrUtil.extend({}, symbolMeta.barRectShape);\n  var barRect = bar.__pictorialBarRect;\n\n  if (!barRect) {\n    barRect = bar.__pictorialBarRect = new graphic.Rect({\n      z2: 2,\n      shape: rectShape,\n      silent: true,\n      style: {\n        stroke: 'transparent',\n        fill: 'transparent',\n        lineWidth: 0\n      }\n    });\n    barRect.disableMorphing = true;\n    bar.add(barRect);\n  } else {\n    updateAttr(barRect, null, {\n      shape: rectShape\n    }, symbolMeta, isUpdate);\n  }\n}\n\nfunction createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {\n  // If not clip, symbol will be remove and rebuilt.\n  if (symbolMeta.symbolClip) {\n    var clipPath = bar.__pictorialClipPath;\n    var clipShape = zrUtil.extend({}, symbolMeta.clipShape);\n    var valueDim = opt.valueDim;\n    var animationModel = symbolMeta.animationModel;\n    var dataIndex = symbolMeta.dataIndex;\n\n    if (clipPath) {\n      graphic.updateProps(clipPath, {\n        shape: clipShape\n      }, animationModel, dataIndex);\n    } else {\n      clipShape[valueDim.wh] = 0;\n      clipPath = new graphic.Rect({\n        shape: clipShape\n      });\n\n      bar.__pictorialBundle.setClipPath(clipPath);\n\n      bar.__pictorialClipPath = clipPath;\n      var target = {};\n      target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](clipPath, {\n        shape: target\n      }, animationModel, dataIndex);\n    }\n  }\n}\n\nfunction getItemModel(data, dataIndex) {\n  var itemModel = data.getItemModel(dataIndex);\n  itemModel.getAnimationDelayParams = getAnimationDelayParams;\n  itemModel.isAnimationEnabled = isAnimationEnabled;\n  return itemModel;\n}\n\nfunction getAnimationDelayParams(path) {\n  // The order is the same as the z-order, see `symbolRepeatDiretion`.\n  return {\n    index: path.__pictorialAnimationIndex,\n    count: path.__pictorialRepeatTimes\n  };\n}\n\nfunction isAnimationEnabled() {\n  // `animation` prop can be set on itemModel in pictorial bar chart.\n  return this.parentModel.isAnimationEnabled() && !!this.getShallow('animation');\n}\n\nfunction createBar(data, opt, symbolMeta, isUpdate) {\n  // bar is the main element for each data.\n  var bar = new graphic.Group(); // bundle is used for location and clip.\n\n  var bundle = new graphic.Group();\n  bar.add(bundle);\n  bar.__pictorialBundle = bundle;\n  bundle.x = symbolMeta.bundlePosition[0];\n  bundle.y = symbolMeta.bundlePosition[1];\n\n  if (symbolMeta.symbolRepeat) {\n    createOrUpdateRepeatSymbols(bar, opt, symbolMeta);\n  } else {\n    createOrUpdateSingleSymbol(bar, opt, symbolMeta);\n  }\n\n  createOrUpdateBarRect(bar, symbolMeta, isUpdate);\n  createOrUpdateClip(bar, opt, symbolMeta, isUpdate);\n  bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);\n  bar.__pictorialSymbolMeta = symbolMeta;\n  return bar;\n}\n\nfunction updateBar(bar, opt, symbolMeta) {\n  var animationModel = symbolMeta.animationModel;\n  var dataIndex = symbolMeta.dataIndex;\n  var bundle = bar.__pictorialBundle;\n  graphic.updateProps(bundle, {\n    x: symbolMeta.bundlePosition[0],\n    y: symbolMeta.bundlePosition[1]\n  }, animationModel, dataIndex);\n\n  if (symbolMeta.symbolRepeat) {\n    createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);\n  } else {\n    createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);\n  }\n\n  createOrUpdateBarRect(bar, symbolMeta, true);\n  createOrUpdateClip(bar, opt, symbolMeta, true);\n}\n\nfunction removeBar(data, dataIndex, animationModel, bar) {\n  // Not show text when animating\n  var labelRect = bar.__pictorialBarRect;\n  labelRect && labelRect.removeTextContent();\n  var pathes = [];\n  eachPath(bar, function (path) {\n    pathes.push(path);\n  });\n  bar.__pictorialMainPath && pathes.push(bar.__pictorialMainPath); // I do not find proper remove animation for clip yet.\n\n  bar.__pictorialClipPath && (animationModel = null);\n  zrUtil.each(pathes, function (path) {\n    graphic.removeElement(path, {\n      scaleX: 0,\n      scaleY: 0\n    }, animationModel, dataIndex, function () {\n      bar.parent && bar.parent.remove(bar);\n    });\n  });\n  data.setItemGraphicEl(dataIndex, null);\n}\n\nfunction getShapeStr(data, symbolMeta) {\n  return [data.getItemVisual(symbolMeta.dataIndex, 'symbol') || 'none', !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip].join(':');\n}\n\nfunction eachPath(bar, cb, context) {\n  // Do not use Group#eachChild, because it do not support remove.\n  zrUtil.each(bar.__pictorialBundle.children(), function (el) {\n    el !== bar.__pictorialBarRect && cb.call(context, el);\n  });\n}\n\nfunction updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {\n  immediateAttrs && el.attr(immediateAttrs); // when symbolCip used, only clip path has init animation, otherwise it would be weird effect.\n\n  if (symbolMeta.symbolClip && !isUpdate) {\n    animationAttrs && el.attr(animationAttrs);\n  } else {\n    animationAttrs && graphic[isUpdate ? 'updateProps' : 'initProps'](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);\n  }\n}\n\nfunction updateCommon(bar, opt, symbolMeta) {\n  var dataIndex = symbolMeta.dataIndex;\n  var itemModel = symbolMeta.itemModel; // Color must be excluded.\n  // Because symbol provide setColor individually to set fill and stroke\n\n  var emphasisModel = itemModel.getModel('emphasis');\n  var emphasisStyle = emphasisModel.getModel('itemStyle').getItemStyle();\n  var blurStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle();\n  var selectStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  var focus = emphasisModel.get('focus');\n  var blurScope = emphasisModel.get('blurScope');\n  var hoverScale = emphasisModel.get('scale');\n  eachPath(bar, function (path) {\n    if (path instanceof ZRImage) {\n      var pathStyle = path.style;\n      path.useStyle(zrUtil.extend({\n        // TODO other properties like dx, dy ?\n        image: pathStyle.image,\n        x: pathStyle.x,\n        y: pathStyle.y,\n        width: pathStyle.width,\n        height: pathStyle.height\n      }, symbolMeta.style));\n    } else {\n      path.useStyle(symbolMeta.style);\n    }\n\n    var emphasisState = path.ensureState('emphasis');\n    emphasisState.style = emphasisStyle;\n\n    if (hoverScale) {\n      // NOTE: Must after scale is set after updateAttr\n      emphasisState.scaleX = path.scaleX * 1.1;\n      emphasisState.scaleY = path.scaleY * 1.1;\n    }\n\n    path.ensureState('blur').style = blurStyle;\n    path.ensureState('select').style = selectStyle;\n    cursorStyle && (path.cursor = cursorStyle);\n    path.z2 = symbolMeta.z2;\n  });\n  var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];\n  var barRect = bar.__pictorialBarRect;\n  setLabelStyle(barRect, getLabelStatesModels(itemModel), {\n    labelFetcher: opt.seriesModel,\n    labelDataIndex: dataIndex,\n    defaultText: getDefaultLabel(opt.seriesModel.getData(), dataIndex),\n    inheritColor: symbolMeta.style.fill,\n    defaultOpacity: symbolMeta.style.opacity,\n    defaultOutsidePosition: barPositionOutside\n  });\n  enableHoverEmphasis(bar, focus, blurScope);\n}\n\nfunction toIntTimes(times) {\n  var roundedTimes = Math.round(times); // Escapse accurate error\n\n  return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);\n}\n\nexport default PictorialBarView;","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/chart/bar/PictorialBarView.js"],"names":["__extends","zrUtil","graphic","enableHoverEmphasis","createSymbol","normalizeSymbolOffset","parsePercent","isNumeric","ChartView","getDefaultLabel","setLabelStyle","getLabelStatesModels","ZRImage","getECData","BAR_BORDER_WIDTH_QUERY","LAYOUT_ATTRS","xy","wh","index","posDesc","pathForLineWidth","Circle","PictorialBarView","_super","_this","apply","arguments","type","prototype","render","seriesModel","ecModel","api","group","data","getData","oldData","_data","cartesian","coordinateSystem","baseAxis","getBaseAxis","isHorizontal","coordSysRect","master","getRect","opt","ecSize","width","getWidth","height","getHeight","coordSys","coordSysExtent","x","y","valueDim","categoryDim","diff","add","dataIndex","hasValue","itemModel","getItemModel","symbolMeta","getSymbolMeta","bar","createBar","setItemGraphicEl","updateCommon","update","newIndex","oldIndex","getItemGraphicEl","remove","pictorialShapeStr","getShapeStr","__pictorialShapeStr","updateBar","__pictorialSymbolMeta","removeBar","animationModel","execute","get","eachItemGraphicEl","removeAll","layout","getItemLayout","symbolRepeat","symbolClip","symbolPosition","symbolRotate","rotation","Math","PI","symbolPatternSize","isAnimationEnabled","symbolType","getItemVisual","style","symbolRepeatDirection","hoverScale","z2","getShallow","prepareBarLength","prepareSymbolSize","boundingLength","pxSign","prepareLineWidth","symbolScale","symbolSize","symbolOffset","prepareLayoutInfo","valueLineWidth","repeatCutLength","outputSymbolMeta","symbolBoundingData","valueAxis","getOtherAxis","zeroPx","toGlobalCoord","dataToCoord","pxSignIdx","isArray","symbolBoundingExtent","convertToCoordOnAxis","reverse","axis","value","scale","parse","categorySize","abs","parsedSymbolSize","slice","attr","scaleX","scaleY","updateTransform","getLineScale","unitLength","max","pathLen","absBoundingLength","symbolMargin","retrieve","hasEndGap","lastIndexOf","length","symbolMarginNumeric","uLenWithMargin","endFix","repeatSpecified","repeatTimes","toIntTimes","mDiff","sizeFix","pathPosition","bundlePosition","barRectShape","extend","clipShape","createPath","path","culling","setStyle","strokeNoScale","createOrUpdateRepeatSymbols","isUpdate","bundle","__pictorialBundle","unit","eachPath","__pictorialAnimationIndex","__pictorialRepeatTimes","updateAttr","makeTarget","target","position","i","createOrUpdateSingleSymbol","mainPath","__pictorialMainPath","createOrUpdateBarRect","rectShape","barRect","__pictorialBarRect","Rect","shape","silent","stroke","fill","lineWidth","disableMorphing","createOrUpdateClip","clipPath","__pictorialClipPath","updateProps","setClipPath","getAnimationDelayParams","count","parentModel","Group","labelRect","removeTextContent","pathes","push","each","removeElement","parent","join","cb","context","children","el","call","immediateAttrs","animationAttrs","emphasisModel","getModel","emphasisStyle","getItemStyle","blurStyle","selectStyle","cursorStyle","focus","blurScope","pathStyle","useStyle","image","emphasisState","ensureState","cursor","barPositionOutside","labelFetcher","labelDataIndex","defaultText","inheritColor","defaultOpacity","opacity","defaultOutsidePosition","times","roundedTimes","round","ceil"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,SAAT,QAA0B,OAA1B;AACA,OAAO,KAAKC,MAAZ,MAAwB,uBAAxB;AACA,OAAO,KAAKC,OAAZ,MAAyB,oBAAzB;AACA,SAASC,mBAAT,QAAoC,mBAApC;AACA,SAASC,YAAT,EAAuBC,qBAAvB,QAAoD,mBAApD;AACA,SAASC,YAAT,EAAuBC,SAAvB,QAAwC,mBAAxC;AACA,OAAOC,SAAP,MAAsB,kBAAtB;AACA,SAASC,eAAT,QAAgC,uBAAhC;AACA,SAASC,aAAT,EAAwBC,oBAAxB,QAAoD,wBAApD;AACA,OAAOC,OAAP,MAAoB,2BAApB;AACA,SAASC,SAAT,QAA0B,uBAA1B;AACA,IAAIC,sBAAsB,GAAG,CAAC,WAAD,EAAc,aAAd,CAA7B,C,CAA2D;;AAE3D,IAAIC,YAAY,GAAG,CAAC;AAClBC,EAAAA,EAAE,EAAE,GADc;AAElBC,EAAAA,EAAE,EAAE,OAFc;AAGlBC,EAAAA,KAAK,EAAE,CAHW;AAIlBC,EAAAA,OAAO,EAAE,CAAC,MAAD,EAAS,OAAT;AAJS,CAAD,EAKhB;AACDH,EAAAA,EAAE,EAAE,GADH;AAEDC,EAAAA,EAAE,EAAE,QAFH;AAGDC,EAAAA,KAAK,EAAE,CAHN;AAIDC,EAAAA,OAAO,EAAE,CAAC,KAAD,EAAQ,QAAR;AAJR,CALgB,CAAnB;AAWA,IAAIC,gBAAgB,GAAG,IAAIlB,OAAO,CAACmB,MAAZ,EAAvB;;AAEA,IAAIC,gBAAgB;AACpB;AACA,UAAUC,MAAV,EAAkB;AAChBvB,EAAAA,SAAS,CAACsB,gBAAD,EAAmBC,MAAnB,CAAT;;AAEA,WAASD,gBAAT,GAA4B;AAC1B,QAAIE,KAAK,GAAGD,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACE,KAAP,CAAa,IAAb,EAAmBC,SAAnB,CAAnB,IAAoD,IAAhE;;AAEAF,IAAAA,KAAK,CAACG,IAAN,GAAaL,gBAAgB,CAACK,IAA9B;AACA,WAAOH,KAAP;AACD;;AAEDF,EAAAA,gBAAgB,CAACM,SAAjB,CAA2BC,MAA3B,GAAoC,UAAUC,WAAV,EAAuBC,OAAvB,EAAgCC,GAAhC,EAAqC;AACvE,QAAIC,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAIC,IAAI,GAAGJ,WAAW,CAACK,OAAZ,EAAX;AACA,QAAIC,OAAO,GAAG,KAAKC,KAAnB;AACA,QAAIC,SAAS,GAAGR,WAAW,CAACS,gBAA5B;AACA,QAAIC,QAAQ,GAAGF,SAAS,CAACG,WAAV,EAAf;AACA,QAAIC,YAAY,GAAGF,QAAQ,CAACE,YAAT,EAAnB;AACA,QAAIC,YAAY,GAAGL,SAAS,CAACM,MAAV,CAAiBC,OAAjB,EAAnB;AACA,QAAIC,GAAG,GAAG;AACRC,MAAAA,MAAM,EAAE;AACNC,QAAAA,KAAK,EAAEhB,GAAG,CAACiB,QAAJ,EADD;AAENC,QAAAA,MAAM,EAAElB,GAAG,CAACmB,SAAJ;AAFF,OADA;AAKRrB,MAAAA,WAAW,EAAEA,WALL;AAMRsB,MAAAA,QAAQ,EAAEd,SANF;AAORe,MAAAA,cAAc,EAAE,CAAC,CAACV,YAAY,CAACW,CAAd,EAAiBX,YAAY,CAACW,CAAb,GAAiBX,YAAY,CAACK,KAA/C,CAAD,EAAwD,CAACL,YAAY,CAACY,CAAd,EAAiBZ,YAAY,CAACY,CAAb,GAAiBZ,YAAY,CAACO,MAA/C,CAAxD,CAPR;AAQRR,MAAAA,YAAY,EAAEA,YARN;AASRc,MAAAA,QAAQ,EAAEzC,YAAY,CAAC,CAAC2B,YAAF,CATd;AAURe,MAAAA,WAAW,EAAE1C,YAAY,CAAC,IAAI,CAAC2B,YAAN;AAVjB,KAAV;AAYAR,IAAAA,IAAI,CAACwB,IAAL,CAAUtB,OAAV,EAAmBuB,GAAnB,CAAuB,UAAUC,SAAV,EAAqB;AAC1C,UAAI,CAAC1B,IAAI,CAAC2B,QAAL,CAAcD,SAAd,CAAL,EAA+B;AAC7B;AACD;;AAED,UAAIE,SAAS,GAAGC,YAAY,CAAC7B,IAAD,EAAO0B,SAAP,CAA5B;AACA,UAAII,UAAU,GAAGC,aAAa,CAAC/B,IAAD,EAAO0B,SAAP,EAAkBE,SAAlB,EAA6BhB,GAA7B,CAA9B;AACA,UAAIoB,GAAG,GAAGC,SAAS,CAACjC,IAAD,EAAOY,GAAP,EAAYkB,UAAZ,CAAnB;AACA9B,MAAAA,IAAI,CAACkC,gBAAL,CAAsBR,SAAtB,EAAiCM,GAAjC;AACAjC,MAAAA,KAAK,CAAC0B,GAAN,CAAUO,GAAV;AACAG,MAAAA,YAAY,CAACH,GAAD,EAAMpB,GAAN,EAAWkB,UAAX,CAAZ;AACD,KAXD,EAWGM,MAXH,CAWU,UAAUC,QAAV,EAAoBC,QAApB,EAA8B;AACtC,UAAIN,GAAG,GAAG9B,OAAO,CAACqC,gBAAR,CAAyBD,QAAzB,CAAV;;AAEA,UAAI,CAACtC,IAAI,CAAC2B,QAAL,CAAcU,QAAd,CAAL,EAA8B;AAC5BtC,QAAAA,KAAK,CAACyC,MAAN,CAAaR,GAAb;AACA;AACD;;AAED,UAAIJ,SAAS,GAAGC,YAAY,CAAC7B,IAAD,EAAOqC,QAAP,CAA5B;AACA,UAAIP,UAAU,GAAGC,aAAa,CAAC/B,IAAD,EAAOqC,QAAP,EAAiBT,SAAjB,EAA4BhB,GAA5B,CAA9B;AACA,UAAI6B,iBAAiB,GAAGC,WAAW,CAAC1C,IAAD,EAAO8B,UAAP,CAAnC;;AAEA,UAAIE,GAAG,IAAIS,iBAAiB,KAAKT,GAAG,CAACW,mBAArC,EAA0D;AACxD5C,QAAAA,KAAK,CAACyC,MAAN,CAAaR,GAAb;AACAhC,QAAAA,IAAI,CAACkC,gBAAL,CAAsBG,QAAtB,EAAgC,IAAhC;AACAL,QAAAA,GAAG,GAAG,IAAN;AACD;;AAED,UAAIA,GAAJ,EAAS;AACPY,QAAAA,SAAS,CAACZ,GAAD,EAAMpB,GAAN,EAAWkB,UAAX,CAAT;AACD,OAFD,MAEO;AACLE,QAAAA,GAAG,GAAGC,SAAS,CAACjC,IAAD,EAAOY,GAAP,EAAYkB,UAAZ,EAAwB,IAAxB,CAAf;AACD;;AAED9B,MAAAA,IAAI,CAACkC,gBAAL,CAAsBG,QAAtB,EAAgCL,GAAhC;AACAA,MAAAA,GAAG,CAACa,qBAAJ,GAA4Bf,UAA5B,CAzBsC,CAyBE;;AAExC/B,MAAAA,KAAK,CAAC0B,GAAN,CAAUO,GAAV;AACAG,MAAAA,YAAY,CAACH,GAAD,EAAMpB,GAAN,EAAWkB,UAAX,CAAZ;AACD,KAxCD,EAwCGU,MAxCH,CAwCU,UAAUd,SAAV,EAAqB;AAC7B,UAAIM,GAAG,GAAG9B,OAAO,CAACqC,gBAAR,CAAyBb,SAAzB,CAAV;AACAM,MAAAA,GAAG,IAAIc,SAAS,CAAC5C,OAAD,EAAUwB,SAAV,EAAqBM,GAAG,CAACa,qBAAJ,CAA0BE,cAA/C,EAA+Df,GAA/D,CAAhB;AACD,KA3CD,EA2CGgB,OA3CH;AA4CA,SAAK7C,KAAL,GAAaH,IAAb;AACA,WAAO,KAAKD,KAAZ;AACD,GAlED;;AAoEAX,EAAAA,gBAAgB,CAACM,SAAjB,CAA2B8C,MAA3B,GAAoC,UAAU3C,OAAV,EAAmBC,GAAnB,EAAwB;AAC1D,QAAIC,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAIC,IAAI,GAAG,KAAKG,KAAhB;;AAEA,QAAIN,OAAO,CAACoD,GAAR,CAAY,WAAZ,CAAJ,EAA8B;AAC5B,UAAIjD,IAAJ,EAAU;AACRA,QAAAA,IAAI,CAACkD,iBAAL,CAAuB,UAAUlB,GAAV,EAAe;AACpCc,UAAAA,SAAS,CAAC9C,IAAD,EAAOrB,SAAS,CAACqD,GAAD,CAAT,CAAeN,SAAtB,EAAiC7B,OAAjC,EAA0CmC,GAA1C,CAAT;AACD,SAFD;AAGD;AACF,KAND,MAMO;AACLjC,MAAAA,KAAK,CAACoD,SAAN;AACD;AACF,GAbD;;AAeA/D,EAAAA,gBAAgB,CAACK,IAAjB,GAAwB,cAAxB;AACA,SAAOL,gBAAP;AACD,CA/FD,CA+FEd,SA/FF,CAFA,C,CAiGc;;;AAGd,SAASyD,aAAT,CAAuB/B,IAAvB,EAA6B0B,SAA7B,EAAwCE,SAAxC,EAAmDhB,GAAnD,EAAwD;AACtD,MAAIwC,MAAM,GAAGpD,IAAI,CAACqD,aAAL,CAAmB3B,SAAnB,CAAb;AACA,MAAI4B,YAAY,GAAG1B,SAAS,CAACqB,GAAV,CAAc,cAAd,CAAnB;AACA,MAAIM,UAAU,GAAG3B,SAAS,CAACqB,GAAV,CAAc,YAAd,CAAjB;AACA,MAAIO,cAAc,GAAG5B,SAAS,CAACqB,GAAV,CAAc,gBAAd,KAAmC,OAAxD;AACA,MAAIQ,YAAY,GAAG7B,SAAS,CAACqB,GAAV,CAAc,cAAd,CAAnB;AACA,MAAIS,QAAQ,GAAG,CAACD,YAAY,IAAI,CAAjB,IAAsBE,IAAI,CAACC,EAA3B,GAAgC,GAAhC,IAAuC,CAAtD;AACA,MAAIC,iBAAiB,GAAGjC,SAAS,CAACqB,GAAV,CAAc,mBAAd,KAAsC,CAA9D;AACA,MAAIa,kBAAkB,GAAGlC,SAAS,CAACkC,kBAAV,EAAzB;AACA,MAAIhC,UAAU,GAAG;AACfJ,IAAAA,SAAS,EAAEA,SADI;AAEf0B,IAAAA,MAAM,EAAEA,MAFO;AAGfxB,IAAAA,SAAS,EAAEA,SAHI;AAIfmC,IAAAA,UAAU,EAAE/D,IAAI,CAACgE,aAAL,CAAmBtC,SAAnB,EAA8B,QAA9B,KAA2C,QAJxC;AAKfuC,IAAAA,KAAK,EAAEjE,IAAI,CAACgE,aAAL,CAAmBtC,SAAnB,EAA8B,OAA9B,CALQ;AAMf6B,IAAAA,UAAU,EAAEA,UANG;AAOfD,IAAAA,YAAY,EAAEA,YAPC;AAQfY,IAAAA,qBAAqB,EAAEtC,SAAS,CAACqB,GAAV,CAAc,uBAAd,CARR;AASfY,IAAAA,iBAAiB,EAAEA,iBATJ;AAUfH,IAAAA,QAAQ,EAAEA,QAVK;AAWfX,IAAAA,cAAc,EAAEe,kBAAkB,GAAGlC,SAAH,GAAe,IAXlC;AAYfuC,IAAAA,UAAU,EAAEL,kBAAkB,IAAIlC,SAAS,CAACqB,GAAV,CAAc,CAAC,UAAD,EAAa,OAAb,CAAd,CAZnB;AAafmB,IAAAA,EAAE,EAAExC,SAAS,CAACyC,UAAV,CAAqB,GAArB,EAA0B,IAA1B,KAAmC;AAbxB,GAAjB;AAeAC,EAAAA,gBAAgB,CAAC1C,SAAD,EAAY0B,YAAZ,EAA0BF,MAA1B,EAAkCxC,GAAlC,EAAuCkB,UAAvC,CAAhB;AACAyC,EAAAA,iBAAiB,CAACvE,IAAD,EAAO0B,SAAP,EAAkB0B,MAAlB,EAA0BE,YAA1B,EAAwCC,UAAxC,EAAoDzB,UAAU,CAAC0C,cAA/D,EAA+E1C,UAAU,CAAC2C,MAA1F,EAAkGZ,iBAAlG,EAAqHjD,GAArH,EAA0HkB,UAA1H,CAAjB;AACA4C,EAAAA,gBAAgB,CAAC9C,SAAD,EAAYE,UAAU,CAAC6C,WAAvB,EAAoCjB,QAApC,EAA8C9C,GAA9C,EAAmDkB,UAAnD,CAAhB;AACA,MAAI8C,UAAU,GAAG9C,UAAU,CAAC8C,UAA5B;AACA,MAAIC,YAAY,GAAG1G,qBAAqB,CAACyD,SAAS,CAACqB,GAAV,CAAc,cAAd,CAAD,EAAgC2B,UAAhC,CAAxC;AACAE,EAAAA,iBAAiB,CAAClD,SAAD,EAAYgD,UAAZ,EAAwBxB,MAAxB,EAAgCE,YAAhC,EAA8CC,UAA9C,EAA0DsB,YAA1D,EAAwErB,cAAxE,EAAwF1B,UAAU,CAACiD,cAAnG,EAAmHjD,UAAU,CAAC0C,cAA9H,EAA8I1C,UAAU,CAACkD,eAAzJ,EAA0KpE,GAA1K,EAA+KkB,UAA/K,CAAjB;AACA,SAAOA,UAAP;AACD,C,CAAC;;;AAGF,SAASwC,gBAAT,CAA0B1C,SAA1B,EAAqC0B,YAArC,EAAmDF,MAAnD,EAA2DxC,GAA3D,EAAgEqE,gBAAhE,EAAkF;AAChF,MAAI3D,QAAQ,GAAGV,GAAG,CAACU,QAAnB;AACA,MAAI4D,kBAAkB,GAAGtD,SAAS,CAACqB,GAAV,CAAc,oBAAd,CAAzB;AACA,MAAIkC,SAAS,GAAGvE,GAAG,CAACM,QAAJ,CAAakE,YAAb,CAA0BxE,GAAG,CAACM,QAAJ,CAAaX,WAAb,EAA1B,CAAhB;AACA,MAAI8E,MAAM,GAAGF,SAAS,CAACG,aAAV,CAAwBH,SAAS,CAACI,WAAV,CAAsB,CAAtB,CAAxB,CAAb;AACA,MAAIC,SAAS,GAAG,IAAI,EAAEpC,MAAM,CAAC9B,QAAQ,CAACvC,EAAV,CAAN,IAAuB,CAAzB,CAApB;AACA,MAAIyF,cAAJ;;AAEA,MAAIzG,MAAM,CAAC0H,OAAP,CAAeP,kBAAf,CAAJ,EAAwC;AACtC,QAAIQ,oBAAoB,GAAG,CAACC,oBAAoB,CAACR,SAAD,EAAYD,kBAAkB,CAAC,CAAD,CAA9B,CAApB,GAAyDG,MAA1D,EAAkEM,oBAAoB,CAACR,SAAD,EAAYD,kBAAkB,CAAC,CAAD,CAA9B,CAApB,GAAyDG,MAA3H,CAA3B;AACAK,IAAAA,oBAAoB,CAAC,CAAD,CAApB,GAA0BA,oBAAoB,CAAC,CAAD,CAA9C,IAAqDA,oBAAoB,CAACE,OAArB,EAArD;AACApB,IAAAA,cAAc,GAAGkB,oBAAoB,CAACF,SAAD,CAArC;AACD,GAJD,MAIO,IAAIN,kBAAkB,IAAI,IAA1B,EAAgC;AACrCV,IAAAA,cAAc,GAAGmB,oBAAoB,CAACR,SAAD,EAAYD,kBAAZ,CAApB,GAAsDG,MAAvE;AACD,GAFM,MAEA,IAAI/B,YAAJ,EAAkB;AACvBkB,IAAAA,cAAc,GAAG5D,GAAG,CAACO,cAAJ,CAAmBG,QAAQ,CAACtC,KAA5B,EAAmCwG,SAAnC,IAAgDH,MAAjE;AACD,GAFM,MAEA;AACLb,IAAAA,cAAc,GAAGpB,MAAM,CAAC9B,QAAQ,CAACvC,EAAV,CAAvB;AACD;;AAEDkG,EAAAA,gBAAgB,CAACT,cAAjB,GAAkCA,cAAlC;;AAEA,MAAIlB,YAAJ,EAAkB;AAChB2B,IAAAA,gBAAgB,CAACD,eAAjB,GAAmC5B,MAAM,CAAC9B,QAAQ,CAACvC,EAAV,CAAzC;AACD;;AAEDkG,EAAAA,gBAAgB,CAACR,MAAjB,GAA0BD,cAAc,GAAG,CAAjB,GAAqB,CAArB,GAAyBA,cAAc,GAAG,CAAjB,GAAqB,CAAC,CAAtB,GAA0B,CAA7E;AACD;;AAED,SAASmB,oBAAT,CAA8BE,IAA9B,EAAoCC,KAApC,EAA2C;AACzC,SAAOD,IAAI,CAACP,aAAL,CAAmBO,IAAI,CAACN,WAAL,CAAiBM,IAAI,CAACE,KAAL,CAAWC,KAAX,CAAiBF,KAAjB,CAAjB,CAAnB,CAAP;AACD,C,CAAC;;;AAGF,SAASvB,iBAAT,CAA2BvE,IAA3B,EAAiC0B,SAAjC,EAA4C0B,MAA5C,EAAoDE,YAApD,EAAkEC,UAAlE,EAA8EiB,cAA9E,EAA8FC,MAA9F,EAAsGZ,iBAAtG,EAAyHjD,GAAzH,EAA8HqE,gBAA9H,EAAgJ;AAC9I,MAAI3D,QAAQ,GAAGV,GAAG,CAACU,QAAnB;AACA,MAAIC,WAAW,GAAGX,GAAG,CAACW,WAAtB;AACA,MAAI0E,YAAY,GAAGtC,IAAI,CAACuC,GAAL,CAAS9C,MAAM,CAAC7B,WAAW,CAACxC,EAAb,CAAf,CAAnB;AACA,MAAI6F,UAAU,GAAG5E,IAAI,CAACgE,aAAL,CAAmBtC,SAAnB,EAA8B,YAA9B,CAAjB;AACA,MAAIyE,gBAAJ;;AAEA,MAAIpI,MAAM,CAAC0H,OAAP,CAAeb,UAAf,CAAJ,EAAgC;AAC9BuB,IAAAA,gBAAgB,GAAGvB,UAAU,CAACwB,KAAX,EAAnB;AACD,GAFD,MAEO;AACL,QAAIxB,UAAU,IAAI,IAAlB,EAAwB;AACtB;AACAuB,MAAAA,gBAAgB,GAAG,CAAC,MAAD,EAAS,MAAT,CAAnB;AACD,KAHD,MAGO;AACLA,MAAAA,gBAAgB,GAAG,CAACvB,UAAD,EAAaA,UAAb,CAAnB;AACD;AACF,GAhB6I,CAgB5I;AACF;AACA;AACA;;;AAGAuB,EAAAA,gBAAgB,CAAC5E,WAAW,CAACvC,KAAb,CAAhB,GAAsCZ,YAAY,CAAC+H,gBAAgB,CAAC5E,WAAW,CAACvC,KAAb,CAAjB,EAAsCiH,YAAtC,CAAlD;AACAE,EAAAA,gBAAgB,CAAC7E,QAAQ,CAACtC,KAAV,CAAhB,GAAmCZ,YAAY,CAAC+H,gBAAgB,CAAC7E,QAAQ,CAACtC,KAAV,CAAjB,EAAmCsE,YAAY,GAAG2C,YAAH,GAAkBtC,IAAI,CAACuC,GAAL,CAAS1B,cAAT,CAAjE,CAA/C;AACAS,EAAAA,gBAAgB,CAACL,UAAjB,GAA8BuB,gBAA9B,CAxB8I,CAwB9F;;AAEhD,MAAIxB,WAAW,GAAGM,gBAAgB,CAACN,WAAjB,GAA+B,CAACwB,gBAAgB,CAAC,CAAD,CAAhB,GAAsBtC,iBAAvB,EAA0CsC,gBAAgB,CAAC,CAAD,CAAhB,GAAsBtC,iBAAhE,CAAjD,CA1B8I,CA0BT;;AAErIc,EAAAA,WAAW,CAACrD,QAAQ,CAACtC,KAAV,CAAX,IAA+B,CAAC4B,GAAG,CAACJ,YAAJ,GAAmB,CAAC,CAApB,GAAwB,CAAzB,IAA8BiE,MAA7D;AACD;;AAED,SAASC,gBAAT,CAA0B9C,SAA1B,EAAqC+C,WAArC,EAAkDjB,QAAlD,EAA4D9C,GAA5D,EAAiEqE,gBAAjE,EAAmF;AACjF;AACA;AACA;AACA,MAAIF,cAAc,GAAGnD,SAAS,CAACqB,GAAV,CAAcrE,sBAAd,KAAyC,CAA9D;;AAEA,MAAImG,cAAJ,EAAoB;AAClB7F,IAAAA,gBAAgB,CAACmH,IAAjB,CAAsB;AACpBC,MAAAA,MAAM,EAAE3B,WAAW,CAAC,CAAD,CADC;AAEpB4B,MAAAA,MAAM,EAAE5B,WAAW,CAAC,CAAD,CAFC;AAGpBjB,MAAAA,QAAQ,EAAEA;AAHU,KAAtB;AAKAxE,IAAAA,gBAAgB,CAACsH,eAAjB;AACAzB,IAAAA,cAAc,IAAI7F,gBAAgB,CAACuH,YAAjB,EAAlB;AACA1B,IAAAA,cAAc,IAAIJ,WAAW,CAAC/D,GAAG,CAACU,QAAJ,CAAatC,KAAd,CAA7B;AACD;;AAEDiG,EAAAA,gBAAgB,CAACF,cAAjB,GAAkCA,cAAlC;AACD;;AAED,SAASD,iBAAT,CAA2BlD,SAA3B,EAAsCgD,UAAtC,EAAkDxB,MAAlD,EAA0DE,YAA1D,EAAwEC,UAAxE,EAAoFsB,YAApF,EAAkGrB,cAAlG,EAAkHuB,cAAlH,EAAkIP,cAAlI,EAAkJQ,eAAlJ,EAAmKpE,GAAnK,EAAwKqE,gBAAxK,EAA0L;AACxL,MAAI1D,WAAW,GAAGX,GAAG,CAACW,WAAtB;AACA,MAAID,QAAQ,GAAGV,GAAG,CAACU,QAAnB;AACA,MAAImD,MAAM,GAAGQ,gBAAgB,CAACR,MAA9B;AACA,MAAIiC,UAAU,GAAG/C,IAAI,CAACgD,GAAL,CAAS/B,UAAU,CAACtD,QAAQ,CAACtC,KAAV,CAAV,GAA6B+F,cAAtC,EAAsD,CAAtD,CAAjB;AACA,MAAI6B,OAAO,GAAGF,UAAd,CALwL,CAK9J;AAC1B;AACA;;AAEA,MAAIpD,YAAJ,EAAkB;AAChB,QAAIuD,iBAAiB,GAAGlD,IAAI,CAACuC,GAAL,CAAS1B,cAAT,CAAxB;AACA,QAAIsC,YAAY,GAAG/I,MAAM,CAACgJ,QAAP,CAAgBnF,SAAS,CAACqB,GAAV,CAAc,cAAd,CAAhB,EAA+C,KAA/C,IAAwD,EAA3E;AACA,QAAI+D,SAAS,GAAG,KAAhB;;AAEA,QAAIF,YAAY,CAACG,WAAb,CAAyB,GAAzB,MAAkCH,YAAY,CAACI,MAAb,GAAsB,CAA5D,EAA+D;AAC7DF,MAAAA,SAAS,GAAG,IAAZ;AACAF,MAAAA,YAAY,GAAGA,YAAY,CAACV,KAAb,CAAmB,CAAnB,EAAsBU,YAAY,CAACI,MAAb,GAAsB,CAA5C,CAAf;AACD;;AAED,QAAIC,mBAAmB,GAAG/I,YAAY,CAAC0I,YAAD,EAAelC,UAAU,CAACtD,QAAQ,CAACtC,KAAV,CAAzB,CAAtC;AACA,QAAIoI,cAAc,GAAGzD,IAAI,CAACgD,GAAL,CAASD,UAAU,GAAGS,mBAAmB,GAAG,CAA5C,EAA+C,CAA/C,CAArB,CAXgB,CAWwD;AACxE;;AAEA,QAAIE,MAAM,GAAGL,SAAS,GAAG,CAAH,GAAOG,mBAAmB,GAAG,CAAnD,CAdgB,CAcsC;AACtD;;AAEA,QAAIG,eAAe,GAAGjJ,SAAS,CAACiF,YAAD,CAA/B;AACA,QAAIiE,WAAW,GAAGD,eAAe,GAAGhE,YAAH,GAAkBkE,UAAU,CAAC,CAACX,iBAAiB,GAAGQ,MAArB,IAA+BD,cAAhC,CAA7D,CAlBgB,CAkB8F;AAC9G;;AAEA,QAAIK,KAAK,GAAGZ,iBAAiB,GAAGU,WAAW,GAAGb,UAA9C;AACAS,IAAAA,mBAAmB,GAAGM,KAAK,GAAG,CAAR,IAAaT,SAAS,GAAGO,WAAH,GAAiB5D,IAAI,CAACgD,GAAL,CAASY,WAAW,GAAG,CAAvB,EAA0B,CAA1B,CAAvC,CAAtB;AACAH,IAAAA,cAAc,GAAGV,UAAU,GAAGS,mBAAmB,GAAG,CAApD;AACAE,IAAAA,MAAM,GAAGL,SAAS,GAAG,CAAH,GAAOG,mBAAmB,GAAG,CAA/C,CAxBgB,CAwBkC;;AAElD,QAAI,CAACG,eAAD,IAAoBhE,YAAY,KAAK,OAAzC,EAAkD;AAChDiE,MAAAA,WAAW,GAAGvC,eAAe,GAAGwC,UAAU,CAAC,CAAC7D,IAAI,CAACuC,GAAL,CAASlB,eAAT,IAA4BqC,MAA7B,IAAuCD,cAAxC,CAAb,GAAuE,CAApG;AACD;;AAEDR,IAAAA,OAAO,GAAGW,WAAW,GAAGH,cAAd,GAA+BC,MAAzC;AACApC,IAAAA,gBAAgB,CAACsC,WAAjB,GAA+BA,WAA/B;AACAtC,IAAAA,gBAAgB,CAAC6B,YAAjB,GAAgCK,mBAAhC;AACD;;AAED,MAAIO,OAAO,GAAGjD,MAAM,IAAImC,OAAO,GAAG,CAAd,CAApB;AACA,MAAIe,YAAY,GAAG1C,gBAAgB,CAAC0C,YAAjB,GAAgC,EAAnD;AACAA,EAAAA,YAAY,CAACpG,WAAW,CAACvC,KAAb,CAAZ,GAAkCoE,MAAM,CAAC7B,WAAW,CAACxC,EAAb,CAAN,GAAyB,CAA3D;AACA4I,EAAAA,YAAY,CAACrG,QAAQ,CAACtC,KAAV,CAAZ,GAA+BwE,cAAc,KAAK,OAAnB,GAA6BkE,OAA7B,GAAuClE,cAAc,KAAK,KAAnB,GAA2BgB,cAAc,GAAGkD,OAA5C,GAAsDlD,cAAc,GAAG,CAA7I,CA/CwL,CA+CxC;;AAEhJ,MAAIK,YAAJ,EAAkB;AAChB8C,IAAAA,YAAY,CAAC,CAAD,CAAZ,IAAmB9C,YAAY,CAAC,CAAD,CAA/B;AACA8C,IAAAA,YAAY,CAAC,CAAD,CAAZ,IAAmB9C,YAAY,CAAC,CAAD,CAA/B;AACD;;AAED,MAAI+C,cAAc,GAAG3C,gBAAgB,CAAC2C,cAAjB,GAAkC,EAAvD;AACAA,EAAAA,cAAc,CAACrG,WAAW,CAACvC,KAAb,CAAd,GAAoCoE,MAAM,CAAC7B,WAAW,CAACzC,EAAb,CAA1C;AACA8I,EAAAA,cAAc,CAACtG,QAAQ,CAACtC,KAAV,CAAd,GAAiCoE,MAAM,CAAC9B,QAAQ,CAACxC,EAAV,CAAvC;AACA,MAAI+I,YAAY,GAAG5C,gBAAgB,CAAC4C,YAAjB,GAAgC9J,MAAM,CAAC+J,MAAP,CAAc,EAAd,EAAkB1E,MAAlB,CAAnD;AACAyE,EAAAA,YAAY,CAACvG,QAAQ,CAACvC,EAAV,CAAZ,GAA4B0F,MAAM,GAAGd,IAAI,CAACgD,GAAL,CAAShD,IAAI,CAACuC,GAAL,CAAS9C,MAAM,CAAC9B,QAAQ,CAACvC,EAAV,CAAf,CAAT,EAAwC4E,IAAI,CAACuC,GAAL,CAASyB,YAAY,CAACrG,QAAQ,CAACtC,KAAV,CAAZ,GAA+B0I,OAAxC,CAAxC,CAArC;AACAG,EAAAA,YAAY,CAACtG,WAAW,CAACxC,EAAb,CAAZ,GAA+BqE,MAAM,CAAC7B,WAAW,CAACxC,EAAb,CAArC;AACA,MAAIgJ,SAAS,GAAG9C,gBAAgB,CAAC8C,SAAjB,GAA6B,EAA7C,CA5DwL,CA4DvI;;AAEjDA,EAAAA,SAAS,CAACxG,WAAW,CAACzC,EAAb,CAAT,GAA4B,CAACsE,MAAM,CAAC7B,WAAW,CAACzC,EAAb,CAAnC;AACAiJ,EAAAA,SAAS,CAACxG,WAAW,CAACxC,EAAb,CAAT,GAA4B6B,GAAG,CAACC,MAAJ,CAAWU,WAAW,CAACxC,EAAvB,CAA5B;AACAgJ,EAAAA,SAAS,CAACzG,QAAQ,CAACxC,EAAV,CAAT,GAAyB,CAAzB;AACAiJ,EAAAA,SAAS,CAACzG,QAAQ,CAACvC,EAAV,CAAT,GAAyBqE,MAAM,CAAC9B,QAAQ,CAACvC,EAAV,CAA/B;AACD;;AAED,SAASiJ,UAAT,CAAoBlG,UAApB,EAAgC;AAC9B,MAAI+B,iBAAiB,GAAG/B,UAAU,CAAC+B,iBAAnC;AACA,MAAIoE,IAAI,GAAG/J,YAAY,EAAE;AACzB4D,EAAAA,UAAU,CAACiC,UADY,EACA,CAACF,iBAAD,GAAqB,CADrB,EACwB,CAACA,iBAAD,GAAqB,CAD7C,EACgDA,iBADhD,EACmEA,iBADnE,CAAvB;AAEAoE,EAAAA,IAAI,CAAC5B,IAAL,CAAU;AACR6B,IAAAA,OAAO,EAAE;AADD,GAAV;AAGAD,EAAAA,IAAI,CAACxI,IAAL,KAAc,OAAd,IAAyBwI,IAAI,CAACE,QAAL,CAAc;AACrCC,IAAAA,aAAa,EAAE;AADsB,GAAd,CAAzB;AAGA,SAAOH,IAAP;AACD;;AAED,SAASI,2BAAT,CAAqCrG,GAArC,EAA0CpB,GAA1C,EAA+CkB,UAA/C,EAA2DwG,QAA3D,EAAqE;AACnE,MAAIC,MAAM,GAAGvG,GAAG,CAACwG,iBAAjB;AACA,MAAI5D,UAAU,GAAG9C,UAAU,CAAC8C,UAA5B;AACA,MAAIG,cAAc,GAAGjD,UAAU,CAACiD,cAAhC;AACA,MAAI4C,YAAY,GAAG7F,UAAU,CAAC6F,YAA9B;AACA,MAAIrG,QAAQ,GAAGV,GAAG,CAACU,QAAnB;AACA,MAAIiG,WAAW,GAAGzF,UAAU,CAACyF,WAAX,IAA0B,CAA5C;AACA,MAAIvI,KAAK,GAAG,CAAZ;AACA,MAAIyJ,IAAI,GAAG7D,UAAU,CAAChE,GAAG,CAACU,QAAJ,CAAatC,KAAd,CAAV,GAAiC+F,cAAjC,GAAkDjD,UAAU,CAACgF,YAAX,GAA0B,CAAvF;AACA4B,EAAAA,QAAQ,CAAC1G,GAAD,EAAM,UAAUiG,IAAV,EAAgB;AAC5BA,IAAAA,IAAI,CAACU,yBAAL,GAAiC3J,KAAjC;AACAiJ,IAAAA,IAAI,CAACW,sBAAL,GAA8BrB,WAA9B;;AAEA,QAAIvI,KAAK,GAAGuI,WAAZ,EAAyB;AACvBsB,MAAAA,UAAU,CAACZ,IAAD,EAAO,IAAP,EAAaa,UAAU,CAAC9J,KAAD,CAAvB,EAAgC8C,UAAhC,EAA4CwG,QAA5C,CAAV;AACD,KAFD,MAEO;AACLO,MAAAA,UAAU,CAACZ,IAAD,EAAO,IAAP,EAAa;AACrB3B,QAAAA,MAAM,EAAE,CADa;AAErBC,QAAAA,MAAM,EAAE;AAFa,OAAb,EAGPzE,UAHO,EAGKwG,QAHL,EAGe,YAAY;AACnCC,QAAAA,MAAM,CAAC/F,MAAP,CAAcyF,IAAd;AACD,OALS,CAAV;AAMD,KAb2B,CAa1B;;;AAGFjJ,IAAAA,KAAK;AACN,GAjBO,CAAR;;AAmBA,SAAOA,KAAK,GAAGuI,WAAf,EAA4BvI,KAAK,EAAjC,EAAqC;AACnC,QAAIiJ,IAAI,GAAGD,UAAU,CAAClG,UAAD,CAArB;AACAmG,IAAAA,IAAI,CAACU,yBAAL,GAAiC3J,KAAjC;AACAiJ,IAAAA,IAAI,CAACW,sBAAL,GAA8BrB,WAA9B;AACAgB,IAAAA,MAAM,CAAC9G,GAAP,CAAWwG,IAAX;AACA,QAAIc,MAAM,GAAGD,UAAU,CAAC9J,KAAD,CAAvB;AACA6J,IAAAA,UAAU,CAACZ,IAAD,EAAO;AACf7G,MAAAA,CAAC,EAAE2H,MAAM,CAAC3H,CADK;AAEfC,MAAAA,CAAC,EAAE0H,MAAM,CAAC1H,CAFK;AAGfiF,MAAAA,MAAM,EAAE,CAHO;AAIfC,MAAAA,MAAM,EAAE;AAJO,KAAP,EAKP;AACDD,MAAAA,MAAM,EAAEyC,MAAM,CAACzC,MADd;AAEDC,MAAAA,MAAM,EAAEwC,MAAM,CAACxC,MAFd;AAGD7C,MAAAA,QAAQ,EAAEqF,MAAM,CAACrF;AAHhB,KALO,EASP5B,UATO,EASKwG,QATL,CAAV;AAUD;;AAED,WAASQ,UAAT,CAAoB9J,KAApB,EAA2B;AACzB,QAAIgK,QAAQ,GAAGrB,YAAY,CAACvB,KAAb,EAAf,CADyB,CACY;AACrC;;AAEA,QAAI3B,MAAM,GAAG3C,UAAU,CAAC2C,MAAxB;AACA,QAAIwE,CAAC,GAAGjK,KAAR;;AAEA,QAAI8C,UAAU,CAACoC,qBAAX,KAAqC,OAArC,GAA+CO,MAAM,GAAG,CAAxD,GAA4DA,MAAM,GAAG,CAAzE,EAA4E;AAC1EwE,MAAAA,CAAC,GAAG1B,WAAW,GAAG,CAAd,GAAkBvI,KAAtB;AACD;;AAEDgK,IAAAA,QAAQ,CAAC1H,QAAQ,CAACtC,KAAV,CAAR,GAA2ByJ,IAAI,IAAIQ,CAAC,GAAG1B,WAAW,GAAG,CAAlB,GAAsB,GAA1B,CAAJ,GAAqCI,YAAY,CAACrG,QAAQ,CAACtC,KAAV,CAA5E;AACA,WAAO;AACLoC,MAAAA,CAAC,EAAE4H,QAAQ,CAAC,CAAD,CADN;AAEL3H,MAAAA,CAAC,EAAE2H,QAAQ,CAAC,CAAD,CAFN;AAGL1C,MAAAA,MAAM,EAAExE,UAAU,CAAC6C,WAAX,CAAuB,CAAvB,CAHH;AAIL4B,MAAAA,MAAM,EAAEzE,UAAU,CAAC6C,WAAX,CAAuB,CAAvB,CAJH;AAKLjB,MAAAA,QAAQ,EAAE5B,UAAU,CAAC4B;AALhB,KAAP;AAOD;AACF;;AAED,SAASwF,0BAAT,CAAoClH,GAApC,EAAyCpB,GAAzC,EAA8CkB,UAA9C,EAA0DwG,QAA1D,EAAoE;AAClE,MAAIC,MAAM,GAAGvG,GAAG,CAACwG,iBAAjB;AACA,MAAIW,QAAQ,GAAGnH,GAAG,CAACoH,mBAAnB;;AAEA,MAAI,CAACD,QAAL,EAAe;AACbA,IAAAA,QAAQ,GAAGnH,GAAG,CAACoH,mBAAJ,GAA0BpB,UAAU,CAAClG,UAAD,CAA/C;AACAyG,IAAAA,MAAM,CAAC9G,GAAP,CAAW0H,QAAX;AACAN,IAAAA,UAAU,CAACM,QAAD,EAAW;AACnB/H,MAAAA,CAAC,EAAEU,UAAU,CAAC6F,YAAX,CAAwB,CAAxB,CADgB;AAEnBtG,MAAAA,CAAC,EAAES,UAAU,CAAC6F,YAAX,CAAwB,CAAxB,CAFgB;AAGnBrB,MAAAA,MAAM,EAAE,CAHW;AAInBC,MAAAA,MAAM,EAAE,CAJW;AAKnB7C,MAAAA,QAAQ,EAAE5B,UAAU,CAAC4B;AALF,KAAX,EAMP;AACD4C,MAAAA,MAAM,EAAExE,UAAU,CAAC6C,WAAX,CAAuB,CAAvB,CADP;AAED4B,MAAAA,MAAM,EAAEzE,UAAU,CAAC6C,WAAX,CAAuB,CAAvB;AAFP,KANO,EASP7C,UATO,EASKwG,QATL,CAAV;AAUD,GAbD,MAaO;AACLO,IAAAA,UAAU,CAACM,QAAD,EAAW,IAAX,EAAiB;AACzB/H,MAAAA,CAAC,EAAEU,UAAU,CAAC6F,YAAX,CAAwB,CAAxB,CADsB;AAEzBtG,MAAAA,CAAC,EAAES,UAAU,CAAC6F,YAAX,CAAwB,CAAxB,CAFsB;AAGzBrB,MAAAA,MAAM,EAAExE,UAAU,CAAC6C,WAAX,CAAuB,CAAvB,CAHiB;AAIzB4B,MAAAA,MAAM,EAAEzE,UAAU,CAAC6C,WAAX,CAAuB,CAAvB,CAJiB;AAKzBjB,MAAAA,QAAQ,EAAE5B,UAAU,CAAC4B;AALI,KAAjB,EAMP5B,UANO,EAMKwG,QANL,CAAV;AAOD;AACF,C,CAAC;;;AAGF,SAASe,qBAAT,CAA+BrH,GAA/B,EAAoCF,UAApC,EAAgDwG,QAAhD,EAA0D;AACxD,MAAIgB,SAAS,GAAGvL,MAAM,CAAC+J,MAAP,CAAc,EAAd,EAAkBhG,UAAU,CAAC+F,YAA7B,CAAhB;AACA,MAAI0B,OAAO,GAAGvH,GAAG,CAACwH,kBAAlB;;AAEA,MAAI,CAACD,OAAL,EAAc;AACZA,IAAAA,OAAO,GAAGvH,GAAG,CAACwH,kBAAJ,GAAyB,IAAIxL,OAAO,CAACyL,IAAZ,CAAiB;AAClDrF,MAAAA,EAAE,EAAE,CAD8C;AAElDsF,MAAAA,KAAK,EAAEJ,SAF2C;AAGlDK,MAAAA,MAAM,EAAE,IAH0C;AAIlD1F,MAAAA,KAAK,EAAE;AACL2F,QAAAA,MAAM,EAAE,aADH;AAELC,QAAAA,IAAI,EAAE,aAFD;AAGLC,QAAAA,SAAS,EAAE;AAHN;AAJ2C,KAAjB,CAAnC;AAUAP,IAAAA,OAAO,CAACQ,eAAR,GAA0B,IAA1B;AACA/H,IAAAA,GAAG,CAACP,GAAJ,CAAQ8H,OAAR;AACD,GAbD,MAaO;AACLV,IAAAA,UAAU,CAACU,OAAD,EAAU,IAAV,EAAgB;AACxBG,MAAAA,KAAK,EAAEJ;AADiB,KAAhB,EAEPxH,UAFO,EAEKwG,QAFL,CAAV;AAGD;AACF;;AAED,SAAS0B,kBAAT,CAA4BhI,GAA5B,EAAiCpB,GAAjC,EAAsCkB,UAAtC,EAAkDwG,QAAlD,EAA4D;AAC1D;AACA,MAAIxG,UAAU,CAACyB,UAAf,EAA2B;AACzB,QAAI0G,QAAQ,GAAGjI,GAAG,CAACkI,mBAAnB;AACA,QAAInC,SAAS,GAAGhK,MAAM,CAAC+J,MAAP,CAAc,EAAd,EAAkBhG,UAAU,CAACiG,SAA7B,CAAhB;AACA,QAAIzG,QAAQ,GAAGV,GAAG,CAACU,QAAnB;AACA,QAAIyB,cAAc,GAAGjB,UAAU,CAACiB,cAAhC;AACA,QAAIrB,SAAS,GAAGI,UAAU,CAACJ,SAA3B;;AAEA,QAAIuI,QAAJ,EAAc;AACZjM,MAAAA,OAAO,CAACmM,WAAR,CAAoBF,QAApB,EAA8B;AAC5BP,QAAAA,KAAK,EAAE3B;AADqB,OAA9B,EAEGhF,cAFH,EAEmBrB,SAFnB;AAGD,KAJD,MAIO;AACLqG,MAAAA,SAAS,CAACzG,QAAQ,CAACvC,EAAV,CAAT,GAAyB,CAAzB;AACAkL,MAAAA,QAAQ,GAAG,IAAIjM,OAAO,CAACyL,IAAZ,CAAiB;AAC1BC,QAAAA,KAAK,EAAE3B;AADmB,OAAjB,CAAX;;AAIA/F,MAAAA,GAAG,CAACwG,iBAAJ,CAAsB4B,WAAtB,CAAkCH,QAAlC;;AAEAjI,MAAAA,GAAG,CAACkI,mBAAJ,GAA0BD,QAA1B;AACA,UAAIlB,MAAM,GAAG,EAAb;AACAA,MAAAA,MAAM,CAACzH,QAAQ,CAACvC,EAAV,CAAN,GAAsB+C,UAAU,CAACiG,SAAX,CAAqBzG,QAAQ,CAACvC,EAA9B,CAAtB;AACAf,MAAAA,OAAO,CAACsK,QAAQ,GAAG,aAAH,GAAmB,WAA5B,CAAP,CAAgD2B,QAAhD,EAA0D;AACxDP,QAAAA,KAAK,EAAEX;AADiD,OAA1D,EAEGhG,cAFH,EAEmBrB,SAFnB;AAGD;AACF;AACF;;AAED,SAASG,YAAT,CAAsB7B,IAAtB,EAA4B0B,SAA5B,EAAuC;AACrC,MAAIE,SAAS,GAAG5B,IAAI,CAAC6B,YAAL,CAAkBH,SAAlB,CAAhB;AACAE,EAAAA,SAAS,CAACyI,uBAAV,GAAoCA,uBAApC;AACAzI,EAAAA,SAAS,CAACkC,kBAAV,GAA+BA,kBAA/B;AACA,SAAOlC,SAAP;AACD;;AAED,SAASyI,uBAAT,CAAiCpC,IAAjC,EAAuC;AACrC;AACA,SAAO;AACLjJ,IAAAA,KAAK,EAAEiJ,IAAI,CAACU,yBADP;AAEL2B,IAAAA,KAAK,EAAErC,IAAI,CAACW;AAFP,GAAP;AAID;;AAED,SAAS9E,kBAAT,GAA8B;AAC5B;AACA,SAAO,KAAKyG,WAAL,CAAiBzG,kBAAjB,MAAyC,CAAC,CAAC,KAAKO,UAAL,CAAgB,WAAhB,CAAlD;AACD;;AAED,SAASpC,SAAT,CAAmBjC,IAAnB,EAAyBY,GAAzB,EAA8BkB,UAA9B,EAA0CwG,QAA1C,EAAoD;AAClD;AACA,MAAItG,GAAG,GAAG,IAAIhE,OAAO,CAACwM,KAAZ,EAAV,CAFkD,CAEnB;;AAE/B,MAAIjC,MAAM,GAAG,IAAIvK,OAAO,CAACwM,KAAZ,EAAb;AACAxI,EAAAA,GAAG,CAACP,GAAJ,CAAQ8G,MAAR;AACAvG,EAAAA,GAAG,CAACwG,iBAAJ,GAAwBD,MAAxB;AACAA,EAAAA,MAAM,CAACnH,CAAP,GAAWU,UAAU,CAAC8F,cAAX,CAA0B,CAA1B,CAAX;AACAW,EAAAA,MAAM,CAAClH,CAAP,GAAWS,UAAU,CAAC8F,cAAX,CAA0B,CAA1B,CAAX;;AAEA,MAAI9F,UAAU,CAACwB,YAAf,EAA6B;AAC3B+E,IAAAA,2BAA2B,CAACrG,GAAD,EAAMpB,GAAN,EAAWkB,UAAX,CAA3B;AACD,GAFD,MAEO;AACLoH,IAAAA,0BAA0B,CAAClH,GAAD,EAAMpB,GAAN,EAAWkB,UAAX,CAA1B;AACD;;AAEDuH,EAAAA,qBAAqB,CAACrH,GAAD,EAAMF,UAAN,EAAkBwG,QAAlB,CAArB;AACA0B,EAAAA,kBAAkB,CAAChI,GAAD,EAAMpB,GAAN,EAAWkB,UAAX,EAAuBwG,QAAvB,CAAlB;AACAtG,EAAAA,GAAG,CAACW,mBAAJ,GAA0BD,WAAW,CAAC1C,IAAD,EAAO8B,UAAP,CAArC;AACAE,EAAAA,GAAG,CAACa,qBAAJ,GAA4Bf,UAA5B;AACA,SAAOE,GAAP;AACD;;AAED,SAASY,SAAT,CAAmBZ,GAAnB,EAAwBpB,GAAxB,EAA6BkB,UAA7B,EAAyC;AACvC,MAAIiB,cAAc,GAAGjB,UAAU,CAACiB,cAAhC;AACA,MAAIrB,SAAS,GAAGI,UAAU,CAACJ,SAA3B;AACA,MAAI6G,MAAM,GAAGvG,GAAG,CAACwG,iBAAjB;AACAxK,EAAAA,OAAO,CAACmM,WAAR,CAAoB5B,MAApB,EAA4B;AAC1BnH,IAAAA,CAAC,EAAEU,UAAU,CAAC8F,cAAX,CAA0B,CAA1B,CADuB;AAE1BvG,IAAAA,CAAC,EAAES,UAAU,CAAC8F,cAAX,CAA0B,CAA1B;AAFuB,GAA5B,EAGG7E,cAHH,EAGmBrB,SAHnB;;AAKA,MAAII,UAAU,CAACwB,YAAf,EAA6B;AAC3B+E,IAAAA,2BAA2B,CAACrG,GAAD,EAAMpB,GAAN,EAAWkB,UAAX,EAAuB,IAAvB,CAA3B;AACD,GAFD,MAEO;AACLoH,IAAAA,0BAA0B,CAAClH,GAAD,EAAMpB,GAAN,EAAWkB,UAAX,EAAuB,IAAvB,CAA1B;AACD;;AAEDuH,EAAAA,qBAAqB,CAACrH,GAAD,EAAMF,UAAN,EAAkB,IAAlB,CAArB;AACAkI,EAAAA,kBAAkB,CAAChI,GAAD,EAAMpB,GAAN,EAAWkB,UAAX,EAAuB,IAAvB,CAAlB;AACD;;AAED,SAASgB,SAAT,CAAmB9C,IAAnB,EAAyB0B,SAAzB,EAAoCqB,cAApC,EAAoDf,GAApD,EAAyD;AACvD;AACA,MAAIyI,SAAS,GAAGzI,GAAG,CAACwH,kBAApB;AACAiB,EAAAA,SAAS,IAAIA,SAAS,CAACC,iBAAV,EAAb;AACA,MAAIC,MAAM,GAAG,EAAb;AACAjC,EAAAA,QAAQ,CAAC1G,GAAD,EAAM,UAAUiG,IAAV,EAAgB;AAC5B0C,IAAAA,MAAM,CAACC,IAAP,CAAY3C,IAAZ;AACD,GAFO,CAAR;AAGAjG,EAAAA,GAAG,CAACoH,mBAAJ,IAA2BuB,MAAM,CAACC,IAAP,CAAY5I,GAAG,CAACoH,mBAAhB,CAA3B,CARuD,CAQU;;AAEjEpH,EAAAA,GAAG,CAACkI,mBAAJ,KAA4BnH,cAAc,GAAG,IAA7C;AACAhF,EAAAA,MAAM,CAAC8M,IAAP,CAAYF,MAAZ,EAAoB,UAAU1C,IAAV,EAAgB;AAClCjK,IAAAA,OAAO,CAAC8M,aAAR,CAAsB7C,IAAtB,EAA4B;AAC1B3B,MAAAA,MAAM,EAAE,CADkB;AAE1BC,MAAAA,MAAM,EAAE;AAFkB,KAA5B,EAGGxD,cAHH,EAGmBrB,SAHnB,EAG8B,YAAY;AACxCM,MAAAA,GAAG,CAAC+I,MAAJ,IAAc/I,GAAG,CAAC+I,MAAJ,CAAWvI,MAAX,CAAkBR,GAAlB,CAAd;AACD,KALD;AAMD,GAPD;AAQAhC,EAAAA,IAAI,CAACkC,gBAAL,CAAsBR,SAAtB,EAAiC,IAAjC;AACD;;AAED,SAASgB,WAAT,CAAqB1C,IAArB,EAA2B8B,UAA3B,EAAuC;AACrC,SAAO,CAAC9B,IAAI,CAACgE,aAAL,CAAmBlC,UAAU,CAACJ,SAA9B,EAAyC,QAAzC,KAAsD,MAAvD,EAA+D,CAAC,CAACI,UAAU,CAACwB,YAA5E,EAA0F,CAAC,CAACxB,UAAU,CAACyB,UAAvG,EAAmHyH,IAAnH,CAAwH,GAAxH,CAAP;AACD;;AAED,SAAStC,QAAT,CAAkB1G,GAAlB,EAAuBiJ,EAAvB,EAA2BC,OAA3B,EAAoC;AAClC;AACAnN,EAAAA,MAAM,CAAC8M,IAAP,CAAY7I,GAAG,CAACwG,iBAAJ,CAAsB2C,QAAtB,EAAZ,EAA8C,UAAUC,EAAV,EAAc;AAC1DA,IAAAA,EAAE,KAAKpJ,GAAG,CAACwH,kBAAX,IAAiCyB,EAAE,CAACI,IAAH,CAAQH,OAAR,EAAiBE,EAAjB,CAAjC;AACD,GAFD;AAGD;;AAED,SAASvC,UAAT,CAAoBuC,EAApB,EAAwBE,cAAxB,EAAwCC,cAAxC,EAAwDzJ,UAAxD,EAAoEwG,QAApE,EAA8E2C,EAA9E,EAAkF;AAChFK,EAAAA,cAAc,IAAIF,EAAE,CAAC/E,IAAH,CAAQiF,cAAR,CAAlB,CADgF,CACrC;;AAE3C,MAAIxJ,UAAU,CAACyB,UAAX,IAAyB,CAAC+E,QAA9B,EAAwC;AACtCiD,IAAAA,cAAc,IAAIH,EAAE,CAAC/E,IAAH,CAAQkF,cAAR,CAAlB;AACD,GAFD,MAEO;AACLA,IAAAA,cAAc,IAAIvN,OAAO,CAACsK,QAAQ,GAAG,aAAH,GAAmB,WAA5B,CAAP,CAAgD8C,EAAhD,EAAoDG,cAApD,EAAoEzJ,UAAU,CAACiB,cAA/E,EAA+FjB,UAAU,CAACJ,SAA1G,EAAqHuJ,EAArH,CAAlB;AACD;AACF;;AAED,SAAS9I,YAAT,CAAsBH,GAAtB,EAA2BpB,GAA3B,EAAgCkB,UAAhC,EAA4C;AAC1C,MAAIJ,SAAS,GAAGI,UAAU,CAACJ,SAA3B;AACA,MAAIE,SAAS,GAAGE,UAAU,CAACF,SAA3B,CAF0C,CAEJ;AACtC;;AAEA,MAAI4J,aAAa,GAAG5J,SAAS,CAAC6J,QAAV,CAAmB,UAAnB,CAApB;AACA,MAAIC,aAAa,GAAGF,aAAa,CAACC,QAAd,CAAuB,WAAvB,EAAoCE,YAApC,EAApB;AACA,MAAIC,SAAS,GAAGhK,SAAS,CAAC6J,QAAV,CAAmB,CAAC,MAAD,EAAS,WAAT,CAAnB,EAA0CE,YAA1C,EAAhB;AACA,MAAIE,WAAW,GAAGjK,SAAS,CAAC6J,QAAV,CAAmB,CAAC,QAAD,EAAW,WAAX,CAAnB,EAA4CE,YAA5C,EAAlB;AACA,MAAIG,WAAW,GAAGlK,SAAS,CAACyC,UAAV,CAAqB,QAArB,CAAlB;AACA,MAAI0H,KAAK,GAAGP,aAAa,CAACvI,GAAd,CAAkB,OAAlB,CAAZ;AACA,MAAI+I,SAAS,GAAGR,aAAa,CAACvI,GAAd,CAAkB,WAAlB,CAAhB;AACA,MAAIkB,UAAU,GAAGqH,aAAa,CAACvI,GAAd,CAAkB,OAAlB,CAAjB;AACAyF,EAAAA,QAAQ,CAAC1G,GAAD,EAAM,UAAUiG,IAAV,EAAgB;AAC5B,QAAIA,IAAI,YAAYvJ,OAApB,EAA6B;AAC3B,UAAIuN,SAAS,GAAGhE,IAAI,CAAChE,KAArB;AACAgE,MAAAA,IAAI,CAACiE,QAAL,CAAcnO,MAAM,CAAC+J,MAAP,CAAc;AAC1B;AACAqE,QAAAA,KAAK,EAAEF,SAAS,CAACE,KAFS;AAG1B/K,QAAAA,CAAC,EAAE6K,SAAS,CAAC7K,CAHa;AAI1BC,QAAAA,CAAC,EAAE4K,SAAS,CAAC5K,CAJa;AAK1BP,QAAAA,KAAK,EAAEmL,SAAS,CAACnL,KALS;AAM1BE,QAAAA,MAAM,EAAEiL,SAAS,CAACjL;AANQ,OAAd,EAOXc,UAAU,CAACmC,KAPA,CAAd;AAQD,KAVD,MAUO;AACLgE,MAAAA,IAAI,CAACiE,QAAL,CAAcpK,UAAU,CAACmC,KAAzB;AACD;;AAED,QAAImI,aAAa,GAAGnE,IAAI,CAACoE,WAAL,CAAiB,UAAjB,CAApB;AACAD,IAAAA,aAAa,CAACnI,KAAd,GAAsByH,aAAtB;;AAEA,QAAIvH,UAAJ,EAAgB;AACd;AACAiI,MAAAA,aAAa,CAAC9F,MAAd,GAAuB2B,IAAI,CAAC3B,MAAL,GAAc,GAArC;AACA8F,MAAAA,aAAa,CAAC7F,MAAd,GAAuB0B,IAAI,CAAC1B,MAAL,GAAc,GAArC;AACD;;AAED0B,IAAAA,IAAI,CAACoE,WAAL,CAAiB,MAAjB,EAAyBpI,KAAzB,GAAiC2H,SAAjC;AACA3D,IAAAA,IAAI,CAACoE,WAAL,CAAiB,QAAjB,EAA2BpI,KAA3B,GAAmC4H,WAAnC;AACAC,IAAAA,WAAW,KAAK7D,IAAI,CAACqE,MAAL,GAAcR,WAAnB,CAAX;AACA7D,IAAAA,IAAI,CAAC7D,EAAL,GAAUtC,UAAU,CAACsC,EAArB;AACD,GA5BO,CAAR;AA6BA,MAAImI,kBAAkB,GAAG3L,GAAG,CAACU,QAAJ,CAAarC,OAAb,CAAqB,EAAE6C,UAAU,CAAC0C,cAAX,GAA4B,CAA9B,CAArB,CAAzB;AACA,MAAI+E,OAAO,GAAGvH,GAAG,CAACwH,kBAAlB;AACAhL,EAAAA,aAAa,CAAC+K,OAAD,EAAU9K,oBAAoB,CAACmD,SAAD,CAA9B,EAA2C;AACtD4K,IAAAA,YAAY,EAAE5L,GAAG,CAAChB,WADoC;AAEtD6M,IAAAA,cAAc,EAAE/K,SAFsC;AAGtDgL,IAAAA,WAAW,EAAEnO,eAAe,CAACqC,GAAG,CAAChB,WAAJ,CAAgBK,OAAhB,EAAD,EAA4ByB,SAA5B,CAH0B;AAItDiL,IAAAA,YAAY,EAAE7K,UAAU,CAACmC,KAAX,CAAiB4F,IAJuB;AAKtD+C,IAAAA,cAAc,EAAE9K,UAAU,CAACmC,KAAX,CAAiB4I,OALqB;AAMtDC,IAAAA,sBAAsB,EAAEP;AAN8B,GAA3C,CAAb;AAQAtO,EAAAA,mBAAmB,CAAC+D,GAAD,EAAM+J,KAAN,EAAaC,SAAb,CAAnB;AACD;;AAED,SAASxE,UAAT,CAAoBuF,KAApB,EAA2B;AACzB,MAAIC,YAAY,GAAGrJ,IAAI,CAACsJ,KAAL,CAAWF,KAAX,CAAnB,CADyB,CACa;;AAEtC,SAAOpJ,IAAI,CAACuC,GAAL,CAAS6G,KAAK,GAAGC,YAAjB,IAAiC,IAAjC,GAAwCA,YAAxC,GAAuDrJ,IAAI,CAACuJ,IAAL,CAAUH,KAAV,CAA9D;AACD;;AAED,eAAe3N,gBAAf","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport * as zrUtil from 'zrender/lib/core/util';\nimport * as graphic from '../../util/graphic';\nimport { enableHoverEmphasis } from '../../util/states';\nimport { createSymbol, normalizeSymbolOffset } from '../../util/symbol';\nimport { parsePercent, isNumeric } from '../../util/number';\nimport ChartView from '../../view/Chart';\nimport { getDefaultLabel } from '../helper/labelHelper';\nimport { setLabelStyle, getLabelStatesModels } from '../../label/labelStyle';\nimport ZRImage from 'zrender/lib/graphic/Image';\nimport { getECData } from '../../util/innerStore';\nvar BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'borderWidth']; // index: +isHorizontal\n\nvar LAYOUT_ATTRS = [{\n  xy: 'x',\n  wh: 'width',\n  index: 0,\n  posDesc: ['left', 'right']\n}, {\n  xy: 'y',\n  wh: 'height',\n  index: 1,\n  posDesc: ['top', 'bottom']\n}];\nvar pathForLineWidth = new graphic.Circle();\n\nvar PictorialBarView =\n/** @class */\nfunction (_super) {\n  __extends(PictorialBarView, _super);\n\n  function PictorialBarView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = PictorialBarView.type;\n    return _this;\n  }\n\n  PictorialBarView.prototype.render = function (seriesModel, ecModel, api) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var isHorizontal = baseAxis.isHorizontal();\n    var coordSysRect = cartesian.master.getRect();\n    var opt = {\n      ecSize: {\n        width: api.getWidth(),\n        height: api.getHeight()\n      },\n      seriesModel: seriesModel,\n      coordSys: cartesian,\n      coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],\n      isHorizontal: isHorizontal,\n      valueDim: LAYOUT_ATTRS[+isHorizontal],\n      categoryDim: LAYOUT_ATTRS[1 - +isHorizontal]\n    };\n    data.diff(oldData).add(function (dataIndex) {\n      if (!data.hasValue(dataIndex)) {\n        return;\n      }\n\n      var itemModel = getItemModel(data, dataIndex);\n      var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);\n      var bar = createBar(data, opt, symbolMeta);\n      data.setItemGraphicEl(dataIndex, bar);\n      group.add(bar);\n      updateCommon(bar, opt, symbolMeta);\n    }).update(function (newIndex, oldIndex) {\n      var bar = oldData.getItemGraphicEl(oldIndex);\n\n      if (!data.hasValue(newIndex)) {\n        group.remove(bar);\n        return;\n      }\n\n      var itemModel = getItemModel(data, newIndex);\n      var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);\n      var pictorialShapeStr = getShapeStr(data, symbolMeta);\n\n      if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {\n        group.remove(bar);\n        data.setItemGraphicEl(newIndex, null);\n        bar = null;\n      }\n\n      if (bar) {\n        updateBar(bar, opt, symbolMeta);\n      } else {\n        bar = createBar(data, opt, symbolMeta, true);\n      }\n\n      data.setItemGraphicEl(newIndex, bar);\n      bar.__pictorialSymbolMeta = symbolMeta; // Add back\n\n      group.add(bar);\n      updateCommon(bar, opt, symbolMeta);\n    }).remove(function (dataIndex) {\n      var bar = oldData.getItemGraphicEl(dataIndex);\n      bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);\n    }).execute();\n    this._data = data;\n    return this.group;\n  };\n\n  PictorialBarView.prototype.remove = function (ecModel, api) {\n    var group = this.group;\n    var data = this._data;\n\n    if (ecModel.get('animation')) {\n      if (data) {\n        data.eachItemGraphicEl(function (bar) {\n          removeBar(data, getECData(bar).dataIndex, ecModel, bar);\n        });\n      }\n    } else {\n      group.removeAll();\n    }\n  };\n\n  PictorialBarView.type = 'pictorialBar';\n  return PictorialBarView;\n}(ChartView); // Set or calculate default value about symbol, and calculate layout info.\n\n\nfunction getSymbolMeta(data, dataIndex, itemModel, opt) {\n  var layout = data.getItemLayout(dataIndex);\n  var symbolRepeat = itemModel.get('symbolRepeat');\n  var symbolClip = itemModel.get('symbolClip');\n  var symbolPosition = itemModel.get('symbolPosition') || 'start';\n  var symbolRotate = itemModel.get('symbolRotate');\n  var rotation = (symbolRotate || 0) * Math.PI / 180 || 0;\n  var symbolPatternSize = itemModel.get('symbolPatternSize') || 2;\n  var isAnimationEnabled = itemModel.isAnimationEnabled();\n  var symbolMeta = {\n    dataIndex: dataIndex,\n    layout: layout,\n    itemModel: itemModel,\n    symbolType: data.getItemVisual(dataIndex, 'symbol') || 'circle',\n    style: data.getItemVisual(dataIndex, 'style'),\n    symbolClip: symbolClip,\n    symbolRepeat: symbolRepeat,\n    symbolRepeatDirection: itemModel.get('symbolRepeatDirection'),\n    symbolPatternSize: symbolPatternSize,\n    rotation: rotation,\n    animationModel: isAnimationEnabled ? itemModel : null,\n    hoverScale: isAnimationEnabled && itemModel.get(['emphasis', 'scale']),\n    z2: itemModel.getShallow('z', true) || 0\n  };\n  prepareBarLength(itemModel, symbolRepeat, layout, opt, symbolMeta);\n  prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);\n  prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);\n  var symbolSize = symbolMeta.symbolSize;\n  var symbolOffset = normalizeSymbolOffset(itemModel.get('symbolOffset'), symbolSize);\n  prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);\n  return symbolMeta;\n} // bar length can be negative.\n\n\nfunction prepareBarLength(itemModel, symbolRepeat, layout, opt, outputSymbolMeta) {\n  var valueDim = opt.valueDim;\n  var symbolBoundingData = itemModel.get('symbolBoundingData');\n  var valueAxis = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());\n  var zeroPx = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0));\n  var pxSignIdx = 1 - +(layout[valueDim.wh] <= 0);\n  var boundingLength;\n\n  if (zrUtil.isArray(symbolBoundingData)) {\n    var symbolBoundingExtent = [convertToCoordOnAxis(valueAxis, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis, symbolBoundingData[1]) - zeroPx];\n    symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();\n    boundingLength = symbolBoundingExtent[pxSignIdx];\n  } else if (symbolBoundingData != null) {\n    boundingLength = convertToCoordOnAxis(valueAxis, symbolBoundingData) - zeroPx;\n  } else if (symbolRepeat) {\n    boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;\n  } else {\n    boundingLength = layout[valueDim.wh];\n  }\n\n  outputSymbolMeta.boundingLength = boundingLength;\n\n  if (symbolRepeat) {\n    outputSymbolMeta.repeatCutLength = layout[valueDim.wh];\n  }\n\n  outputSymbolMeta.pxSign = boundingLength > 0 ? 1 : boundingLength < 0 ? -1 : 0;\n}\n\nfunction convertToCoordOnAxis(axis, value) {\n  return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));\n} // Support ['100%', '100%']\n\n\nfunction prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, outputSymbolMeta) {\n  var valueDim = opt.valueDim;\n  var categoryDim = opt.categoryDim;\n  var categorySize = Math.abs(layout[categoryDim.wh]);\n  var symbolSize = data.getItemVisual(dataIndex, 'symbolSize');\n  var parsedSymbolSize;\n\n  if (zrUtil.isArray(symbolSize)) {\n    parsedSymbolSize = symbolSize.slice();\n  } else {\n    if (symbolSize == null) {\n      // will parse to number below\n      parsedSymbolSize = ['100%', '100%'];\n    } else {\n      parsedSymbolSize = [symbolSize, symbolSize];\n    }\n  } // Note: percentage symbolSize (like '100%') do not consider lineWidth, because it is\n  // to complicated to calculate real percent value if considering scaled lineWidth.\n  // So the actual size will bigger than layout size if lineWidth is bigger than zero,\n  // which can be tolerated in pictorial chart.\n\n\n  parsedSymbolSize[categoryDim.index] = parsePercent(parsedSymbolSize[categoryDim.index], categorySize);\n  parsedSymbolSize[valueDim.index] = parsePercent(parsedSymbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));\n  outputSymbolMeta.symbolSize = parsedSymbolSize; // If x or y is less than zero, show reversed shape.\n\n  var symbolScale = outputSymbolMeta.symbolScale = [parsedSymbolSize[0] / symbolPatternSize, parsedSymbolSize[1] / symbolPatternSize]; // Follow convention, 'right' and 'top' is the normal scale.\n\n  symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;\n}\n\nfunction prepareLineWidth(itemModel, symbolScale, rotation, opt, outputSymbolMeta) {\n  // In symbols are drawn with scale, so do not need to care about the case that width\n  // or height are too small. But symbol use strokeNoScale, where acture lineWidth should\n  // be calculated.\n  var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n\n  if (valueLineWidth) {\n    pathForLineWidth.attr({\n      scaleX: symbolScale[0],\n      scaleY: symbolScale[1],\n      rotation: rotation\n    });\n    pathForLineWidth.updateTransform();\n    valueLineWidth /= pathForLineWidth.getLineScale();\n    valueLineWidth *= symbolScale[opt.valueDim.index];\n  }\n\n  outputSymbolMeta.valueLineWidth = valueLineWidth;\n}\n\nfunction prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, outputSymbolMeta) {\n  var categoryDim = opt.categoryDim;\n  var valueDim = opt.valueDim;\n  var pxSign = outputSymbolMeta.pxSign;\n  var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);\n  var pathLen = unitLength; // Note: rotation will not effect the layout of symbols, because user may\n  // want symbols to rotate on its center, which should not be translated\n  // when rotating.\n\n  if (symbolRepeat) {\n    var absBoundingLength = Math.abs(boundingLength);\n    var symbolMargin = zrUtil.retrieve(itemModel.get('symbolMargin'), '15%') + '';\n    var hasEndGap = false;\n\n    if (symbolMargin.lastIndexOf('!') === symbolMargin.length - 1) {\n      hasEndGap = true;\n      symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);\n    }\n\n    var symbolMarginNumeric = parsePercent(symbolMargin, symbolSize[valueDim.index]);\n    var uLenWithMargin = Math.max(unitLength + symbolMarginNumeric * 2, 0); // When symbol margin is less than 0, margin at both ends will be subtracted\n    // to ensure that all of the symbols will not be overflow the given area.\n\n    var endFix = hasEndGap ? 0 : symbolMarginNumeric * 2; // Both final repeatTimes and final symbolMarginNumeric area calculated based on\n    // boundingLength.\n\n    var repeatSpecified = isNumeric(symbolRepeat);\n    var repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin); // Adjust calculate margin, to ensure each symbol is displayed\n    // entirely in the given layout area.\n\n    var mDiff = absBoundingLength - repeatTimes * unitLength;\n    symbolMarginNumeric = mDiff / 2 / (hasEndGap ? repeatTimes : Math.max(repeatTimes - 1, 1));\n    uLenWithMargin = unitLength + symbolMarginNumeric * 2;\n    endFix = hasEndGap ? 0 : symbolMarginNumeric * 2; // Update repeatTimes when not all symbol will be shown.\n\n    if (!repeatSpecified && symbolRepeat !== 'fixed') {\n      repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;\n    }\n\n    pathLen = repeatTimes * uLenWithMargin - endFix;\n    outputSymbolMeta.repeatTimes = repeatTimes;\n    outputSymbolMeta.symbolMargin = symbolMarginNumeric;\n  }\n\n  var sizeFix = pxSign * (pathLen / 2);\n  var pathPosition = outputSymbolMeta.pathPosition = [];\n  pathPosition[categoryDim.index] = layout[categoryDim.wh] / 2;\n  pathPosition[valueDim.index] = symbolPosition === 'start' ? sizeFix : symbolPosition === 'end' ? boundingLength - sizeFix : boundingLength / 2; // 'center'\n\n  if (symbolOffset) {\n    pathPosition[0] += symbolOffset[0];\n    pathPosition[1] += symbolOffset[1];\n  }\n\n  var bundlePosition = outputSymbolMeta.bundlePosition = [];\n  bundlePosition[categoryDim.index] = layout[categoryDim.xy];\n  bundlePosition[valueDim.index] = layout[valueDim.xy];\n  var barRectShape = outputSymbolMeta.barRectShape = zrUtil.extend({}, layout);\n  barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));\n  barRectShape[categoryDim.wh] = layout[categoryDim.wh];\n  var clipShape = outputSymbolMeta.clipShape = {}; // Consider that symbol may be overflow layout rect.\n\n  clipShape[categoryDim.xy] = -layout[categoryDim.xy];\n  clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];\n  clipShape[valueDim.xy] = 0;\n  clipShape[valueDim.wh] = layout[valueDim.wh];\n}\n\nfunction createPath(symbolMeta) {\n  var symbolPatternSize = symbolMeta.symbolPatternSize;\n  var path = createSymbol( // Consider texture img, make a big size.\n  symbolMeta.symbolType, -symbolPatternSize / 2, -symbolPatternSize / 2, symbolPatternSize, symbolPatternSize);\n  path.attr({\n    culling: true\n  });\n  path.type !== 'image' && path.setStyle({\n    strokeNoScale: true\n  });\n  return path;\n}\n\nfunction createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {\n  var bundle = bar.__pictorialBundle;\n  var symbolSize = symbolMeta.symbolSize;\n  var valueLineWidth = symbolMeta.valueLineWidth;\n  var pathPosition = symbolMeta.pathPosition;\n  var valueDim = opt.valueDim;\n  var repeatTimes = symbolMeta.repeatTimes || 0;\n  var index = 0;\n  var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;\n  eachPath(bar, function (path) {\n    path.__pictorialAnimationIndex = index;\n    path.__pictorialRepeatTimes = repeatTimes;\n\n    if (index < repeatTimes) {\n      updateAttr(path, null, makeTarget(index), symbolMeta, isUpdate);\n    } else {\n      updateAttr(path, null, {\n        scaleX: 0,\n        scaleY: 0\n      }, symbolMeta, isUpdate, function () {\n        bundle.remove(path);\n      });\n    } // updateHoverAnimation(path, symbolMeta);\n\n\n    index++;\n  });\n\n  for (; index < repeatTimes; index++) {\n    var path = createPath(symbolMeta);\n    path.__pictorialAnimationIndex = index;\n    path.__pictorialRepeatTimes = repeatTimes;\n    bundle.add(path);\n    var target = makeTarget(index);\n    updateAttr(path, {\n      x: target.x,\n      y: target.y,\n      scaleX: 0,\n      scaleY: 0\n    }, {\n      scaleX: target.scaleX,\n      scaleY: target.scaleY,\n      rotation: target.rotation\n    }, symbolMeta, isUpdate);\n  }\n\n  function makeTarget(index) {\n    var position = pathPosition.slice(); // (start && pxSign > 0) || (end && pxSign < 0): i = repeatTimes - index\n    // Otherwise: i = index;\n\n    var pxSign = symbolMeta.pxSign;\n    var i = index;\n\n    if (symbolMeta.symbolRepeatDirection === 'start' ? pxSign > 0 : pxSign < 0) {\n      i = repeatTimes - 1 - index;\n    }\n\n    position[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];\n    return {\n      x: position[0],\n      y: position[1],\n      scaleX: symbolMeta.symbolScale[0],\n      scaleY: symbolMeta.symbolScale[1],\n      rotation: symbolMeta.rotation\n    };\n  }\n}\n\nfunction createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {\n  var bundle = bar.__pictorialBundle;\n  var mainPath = bar.__pictorialMainPath;\n\n  if (!mainPath) {\n    mainPath = bar.__pictorialMainPath = createPath(symbolMeta);\n    bundle.add(mainPath);\n    updateAttr(mainPath, {\n      x: symbolMeta.pathPosition[0],\n      y: symbolMeta.pathPosition[1],\n      scaleX: 0,\n      scaleY: 0,\n      rotation: symbolMeta.rotation\n    }, {\n      scaleX: symbolMeta.symbolScale[0],\n      scaleY: symbolMeta.symbolScale[1]\n    }, symbolMeta, isUpdate);\n  } else {\n    updateAttr(mainPath, null, {\n      x: symbolMeta.pathPosition[0],\n      y: symbolMeta.pathPosition[1],\n      scaleX: symbolMeta.symbolScale[0],\n      scaleY: symbolMeta.symbolScale[1],\n      rotation: symbolMeta.rotation\n    }, symbolMeta, isUpdate);\n  }\n} // bar rect is used for label.\n\n\nfunction createOrUpdateBarRect(bar, symbolMeta, isUpdate) {\n  var rectShape = zrUtil.extend({}, symbolMeta.barRectShape);\n  var barRect = bar.__pictorialBarRect;\n\n  if (!barRect) {\n    barRect = bar.__pictorialBarRect = new graphic.Rect({\n      z2: 2,\n      shape: rectShape,\n      silent: true,\n      style: {\n        stroke: 'transparent',\n        fill: 'transparent',\n        lineWidth: 0\n      }\n    });\n    barRect.disableMorphing = true;\n    bar.add(barRect);\n  } else {\n    updateAttr(barRect, null, {\n      shape: rectShape\n    }, symbolMeta, isUpdate);\n  }\n}\n\nfunction createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {\n  // If not clip, symbol will be remove and rebuilt.\n  if (symbolMeta.symbolClip) {\n    var clipPath = bar.__pictorialClipPath;\n    var clipShape = zrUtil.extend({}, symbolMeta.clipShape);\n    var valueDim = opt.valueDim;\n    var animationModel = symbolMeta.animationModel;\n    var dataIndex = symbolMeta.dataIndex;\n\n    if (clipPath) {\n      graphic.updateProps(clipPath, {\n        shape: clipShape\n      }, animationModel, dataIndex);\n    } else {\n      clipShape[valueDim.wh] = 0;\n      clipPath = new graphic.Rect({\n        shape: clipShape\n      });\n\n      bar.__pictorialBundle.setClipPath(clipPath);\n\n      bar.__pictorialClipPath = clipPath;\n      var target = {};\n      target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](clipPath, {\n        shape: target\n      }, animationModel, dataIndex);\n    }\n  }\n}\n\nfunction getItemModel(data, dataIndex) {\n  var itemModel = data.getItemModel(dataIndex);\n  itemModel.getAnimationDelayParams = getAnimationDelayParams;\n  itemModel.isAnimationEnabled = isAnimationEnabled;\n  return itemModel;\n}\n\nfunction getAnimationDelayParams(path) {\n  // The order is the same as the z-order, see `symbolRepeatDiretion`.\n  return {\n    index: path.__pictorialAnimationIndex,\n    count: path.__pictorialRepeatTimes\n  };\n}\n\nfunction isAnimationEnabled() {\n  // `animation` prop can be set on itemModel in pictorial bar chart.\n  return this.parentModel.isAnimationEnabled() && !!this.getShallow('animation');\n}\n\nfunction createBar(data, opt, symbolMeta, isUpdate) {\n  // bar is the main element for each data.\n  var bar = new graphic.Group(); // bundle is used for location and clip.\n\n  var bundle = new graphic.Group();\n  bar.add(bundle);\n  bar.__pictorialBundle = bundle;\n  bundle.x = symbolMeta.bundlePosition[0];\n  bundle.y = symbolMeta.bundlePosition[1];\n\n  if (symbolMeta.symbolRepeat) {\n    createOrUpdateRepeatSymbols(bar, opt, symbolMeta);\n  } else {\n    createOrUpdateSingleSymbol(bar, opt, symbolMeta);\n  }\n\n  createOrUpdateBarRect(bar, symbolMeta, isUpdate);\n  createOrUpdateClip(bar, opt, symbolMeta, isUpdate);\n  bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);\n  bar.__pictorialSymbolMeta = symbolMeta;\n  return bar;\n}\n\nfunction updateBar(bar, opt, symbolMeta) {\n  var animationModel = symbolMeta.animationModel;\n  var dataIndex = symbolMeta.dataIndex;\n  var bundle = bar.__pictorialBundle;\n  graphic.updateProps(bundle, {\n    x: symbolMeta.bundlePosition[0],\n    y: symbolMeta.bundlePosition[1]\n  }, animationModel, dataIndex);\n\n  if (symbolMeta.symbolRepeat) {\n    createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);\n  } else {\n    createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);\n  }\n\n  createOrUpdateBarRect(bar, symbolMeta, true);\n  createOrUpdateClip(bar, opt, symbolMeta, true);\n}\n\nfunction removeBar(data, dataIndex, animationModel, bar) {\n  // Not show text when animating\n  var labelRect = bar.__pictorialBarRect;\n  labelRect && labelRect.removeTextContent();\n  var pathes = [];\n  eachPath(bar, function (path) {\n    pathes.push(path);\n  });\n  bar.__pictorialMainPath && pathes.push(bar.__pictorialMainPath); // I do not find proper remove animation for clip yet.\n\n  bar.__pictorialClipPath && (animationModel = null);\n  zrUtil.each(pathes, function (path) {\n    graphic.removeElement(path, {\n      scaleX: 0,\n      scaleY: 0\n    }, animationModel, dataIndex, function () {\n      bar.parent && bar.parent.remove(bar);\n    });\n  });\n  data.setItemGraphicEl(dataIndex, null);\n}\n\nfunction getShapeStr(data, symbolMeta) {\n  return [data.getItemVisual(symbolMeta.dataIndex, 'symbol') || 'none', !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip].join(':');\n}\n\nfunction eachPath(bar, cb, context) {\n  // Do not use Group#eachChild, because it do not support remove.\n  zrUtil.each(bar.__pictorialBundle.children(), function (el) {\n    el !== bar.__pictorialBarRect && cb.call(context, el);\n  });\n}\n\nfunction updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {\n  immediateAttrs && el.attr(immediateAttrs); // when symbolCip used, only clip path has init animation, otherwise it would be weird effect.\n\n  if (symbolMeta.symbolClip && !isUpdate) {\n    animationAttrs && el.attr(animationAttrs);\n  } else {\n    animationAttrs && graphic[isUpdate ? 'updateProps' : 'initProps'](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);\n  }\n}\n\nfunction updateCommon(bar, opt, symbolMeta) {\n  var dataIndex = symbolMeta.dataIndex;\n  var itemModel = symbolMeta.itemModel; // Color must be excluded.\n  // Because symbol provide setColor individually to set fill and stroke\n\n  var emphasisModel = itemModel.getModel('emphasis');\n  var emphasisStyle = emphasisModel.getModel('itemStyle').getItemStyle();\n  var blurStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle();\n  var selectStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle();\n  var cursorStyle = itemModel.getShallow('cursor');\n  var focus = emphasisModel.get('focus');\n  var blurScope = emphasisModel.get('blurScope');\n  var hoverScale = emphasisModel.get('scale');\n  eachPath(bar, function (path) {\n    if (path instanceof ZRImage) {\n      var pathStyle = path.style;\n      path.useStyle(zrUtil.extend({\n        // TODO other properties like dx, dy ?\n        image: pathStyle.image,\n        x: pathStyle.x,\n        y: pathStyle.y,\n        width: pathStyle.width,\n        height: pathStyle.height\n      }, symbolMeta.style));\n    } else {\n      path.useStyle(symbolMeta.style);\n    }\n\n    var emphasisState = path.ensureState('emphasis');\n    emphasisState.style = emphasisStyle;\n\n    if (hoverScale) {\n      // NOTE: Must after scale is set after updateAttr\n      emphasisState.scaleX = path.scaleX * 1.1;\n      emphasisState.scaleY = path.scaleY * 1.1;\n    }\n\n    path.ensureState('blur').style = blurStyle;\n    path.ensureState('select').style = selectStyle;\n    cursorStyle && (path.cursor = cursorStyle);\n    path.z2 = symbolMeta.z2;\n  });\n  var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];\n  var barRect = bar.__pictorialBarRect;\n  setLabelStyle(barRect, getLabelStatesModels(itemModel), {\n    labelFetcher: opt.seriesModel,\n    labelDataIndex: dataIndex,\n    defaultText: getDefaultLabel(opt.seriesModel.getData(), dataIndex),\n    inheritColor: symbolMeta.style.fill,\n    defaultOpacity: symbolMeta.style.opacity,\n    defaultOutsidePosition: barPositionOutside\n  });\n  enableHoverEmphasis(bar, focus, blurScope);\n}\n\nfunction toIntTimes(times) {\n  var roundedTimes = Math.round(times); // Escapse accurate error\n\n  return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);\n}\n\nexport default PictorialBarView;"]},"metadata":{},"sourceType":"module"}