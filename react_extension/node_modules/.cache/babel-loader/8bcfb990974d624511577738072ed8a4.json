{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport BoundingRect from 'zrender/lib/core/BoundingRect';\nimport * as matrix from 'zrender/lib/core/matrix';\nimport * as graphic from '../../util/graphic';\nimport { createTextStyle } from '../../label/labelStyle';\nimport * as layout from '../../util/layout';\nimport TimelineView from './TimelineView';\nimport TimelineAxis from './TimelineAxis';\nimport { createSymbol, normalizeSymbolOffset, normalizeSymbolSize } from '../../util/symbol';\nimport * as numberUtil from '../../util/number';\nimport { merge, each, extend, isString, bind, defaults, retrieve2 } from 'zrender/lib/core/util';\nimport OrdinalScale from '../../scale/Ordinal';\nimport TimeScale from '../../scale/Time';\nimport IntervalScale from '../../scale/Interval';\nimport { parsePercent } from 'zrender/lib/contain/text';\nimport { makeInner } from '../../util/model';\nimport { getECData } from '../../util/innerStore';\nimport { enableHoverEmphasis } from '../../util/states';\nimport { createTooltipMarkup } from '../tooltip/tooltipMarkup';\nvar PI = Math.PI;\nvar labelDataIndexStore = makeInner();\n\nvar SliderTimelineView =\n/** @class */\nfunction (_super) {\n  __extends(SliderTimelineView, _super);\n\n  function SliderTimelineView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = SliderTimelineView.type;\n    return _this;\n  }\n\n  SliderTimelineView.prototype.init = function (ecModel, api) {\n    this.api = api;\n  };\n  /**\n   * @override\n   */\n\n\n  SliderTimelineView.prototype.render = function (timelineModel, ecModel, api) {\n    this.model = timelineModel;\n    this.api = api;\n    this.ecModel = ecModel;\n    this.group.removeAll();\n\n    if (timelineModel.get('show', true)) {\n      var layoutInfo_1 = this._layout(timelineModel, api);\n\n      var mainGroup_1 = this._createGroup('_mainGroup');\n\n      var labelGroup = this._createGroup('_labelGroup');\n\n      var axis_1 = this._axis = this._createAxis(layoutInfo_1, timelineModel);\n\n      timelineModel.formatTooltip = function (dataIndex) {\n        var name = axis_1.scale.getLabel({\n          value: dataIndex\n        });\n        return createTooltipMarkup('nameValue', {\n          noName: true,\n          value: name\n        });\n      };\n\n      each(['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'], function (name) {\n        this['_render' + name](layoutInfo_1, mainGroup_1, axis_1, timelineModel);\n      }, this);\n\n      this._renderAxisLabel(layoutInfo_1, labelGroup, axis_1, timelineModel);\n\n      this._position(layoutInfo_1, timelineModel);\n    }\n\n    this._doPlayStop();\n\n    this._updateTicksStatus();\n  };\n  /**\n   * @override\n   */\n\n\n  SliderTimelineView.prototype.remove = function () {\n    this._clearTimer();\n\n    this.group.removeAll();\n  };\n  /**\n   * @override\n   */\n\n\n  SliderTimelineView.prototype.dispose = function () {\n    this._clearTimer();\n  };\n\n  SliderTimelineView.prototype._layout = function (timelineModel, api) {\n    var labelPosOpt = timelineModel.get(['label', 'position']);\n    var orient = timelineModel.get('orient');\n    var viewRect = getViewRect(timelineModel, api);\n    var parsedLabelPos; // Auto label offset.\n\n    if (labelPosOpt == null || labelPosOpt === 'auto') {\n      parsedLabelPos = orient === 'horizontal' ? viewRect.y + viewRect.height / 2 < api.getHeight() / 2 ? '-' : '+' : viewRect.x + viewRect.width / 2 < api.getWidth() / 2 ? '+' : '-';\n    } else if (isString(labelPosOpt)) {\n      parsedLabelPos = {\n        horizontal: {\n          top: '-',\n          bottom: '+'\n        },\n        vertical: {\n          left: '-',\n          right: '+'\n        }\n      }[orient][labelPosOpt];\n    } else {\n      // is number\n      parsedLabelPos = labelPosOpt;\n    }\n\n    var labelAlignMap = {\n      horizontal: 'center',\n      vertical: parsedLabelPos >= 0 || parsedLabelPos === '+' ? 'left' : 'right'\n    };\n    var labelBaselineMap = {\n      horizontal: parsedLabelPos >= 0 || parsedLabelPos === '+' ? 'top' : 'bottom',\n      vertical: 'middle'\n    };\n    var rotationMap = {\n      horizontal: 0,\n      vertical: PI / 2\n    }; // Position\n\n    var mainLength = orient === 'vertical' ? viewRect.height : viewRect.width;\n    var controlModel = timelineModel.getModel('controlStyle');\n    var showControl = controlModel.get('show', true);\n    var controlSize = showControl ? controlModel.get('itemSize') : 0;\n    var controlGap = showControl ? controlModel.get('itemGap') : 0;\n    var sizePlusGap = controlSize + controlGap; // Special label rotate.\n\n    var labelRotation = timelineModel.get(['label', 'rotate']) || 0;\n    labelRotation = labelRotation * PI / 180; // To radian.\n\n    var playPosition;\n    var prevBtnPosition;\n    var nextBtnPosition;\n    var controlPosition = controlModel.get('position', true);\n    var showPlayBtn = showControl && controlModel.get('showPlayBtn', true);\n    var showPrevBtn = showControl && controlModel.get('showPrevBtn', true);\n    var showNextBtn = showControl && controlModel.get('showNextBtn', true);\n    var xLeft = 0;\n    var xRight = mainLength; // position[0] means left, position[1] means middle.\n\n    if (controlPosition === 'left' || controlPosition === 'bottom') {\n      showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);\n      showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);\n      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n    } else {\n      // 'top' 'right'\n      showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n      showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);\n      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n    }\n\n    var axisExtent = [xLeft, xRight];\n\n    if (timelineModel.get('inverse')) {\n      axisExtent.reverse();\n    }\n\n    return {\n      viewRect: viewRect,\n      mainLength: mainLength,\n      orient: orient,\n      rotation: rotationMap[orient],\n      labelRotation: labelRotation,\n      labelPosOpt: parsedLabelPos,\n      labelAlign: timelineModel.get(['label', 'align']) || labelAlignMap[orient],\n      labelBaseline: timelineModel.get(['label', 'verticalAlign']) || timelineModel.get(['label', 'baseline']) || labelBaselineMap[orient],\n      // Based on mainGroup.\n      playPosition: playPosition,\n      prevBtnPosition: prevBtnPosition,\n      nextBtnPosition: nextBtnPosition,\n      axisExtent: axisExtent,\n      controlSize: controlSize,\n      controlGap: controlGap\n    };\n  };\n\n  SliderTimelineView.prototype._position = function (layoutInfo, timelineModel) {\n    // Position is be called finally, because bounding rect is needed for\n    // adapt content to fill viewRect (auto adapt offset).\n    // Timeline may be not all in the viewRect when 'offset' is specified\n    // as a number, because it is more appropriate that label aligns at\n    // 'offset' but not the other edge defined by viewRect.\n    var mainGroup = this._mainGroup;\n    var labelGroup = this._labelGroup;\n    var viewRect = layoutInfo.viewRect;\n\n    if (layoutInfo.orient === 'vertical') {\n      // transform to horizontal, inverse rotate by left-top point.\n      var m = matrix.create();\n      var rotateOriginX = viewRect.x;\n      var rotateOriginY = viewRect.y + viewRect.height;\n      matrix.translate(m, m, [-rotateOriginX, -rotateOriginY]);\n      matrix.rotate(m, m, -PI / 2);\n      matrix.translate(m, m, [rotateOriginX, rotateOriginY]);\n      viewRect = viewRect.clone();\n      viewRect.applyTransform(m);\n    }\n\n    var viewBound = getBound(viewRect);\n    var mainBound = getBound(mainGroup.getBoundingRect());\n    var labelBound = getBound(labelGroup.getBoundingRect());\n    var mainPosition = [mainGroup.x, mainGroup.y];\n    var labelsPosition = [labelGroup.x, labelGroup.y];\n    labelsPosition[0] = mainPosition[0] = viewBound[0][0];\n    var labelPosOpt = layoutInfo.labelPosOpt;\n\n    if (labelPosOpt == null || isString(labelPosOpt)) {\n      // '+' or '-'\n      var mainBoundIdx = labelPosOpt === '+' ? 0 : 1;\n      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);\n      toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);\n    } else {\n      var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;\n      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);\n      labelsPosition[1] = mainPosition[1] + labelPosOpt;\n    }\n\n    mainGroup.setPosition(mainPosition);\n    labelGroup.setPosition(labelsPosition);\n    mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;\n    setOrigin(mainGroup);\n    setOrigin(labelGroup);\n\n    function setOrigin(targetGroup) {\n      targetGroup.originX = viewBound[0][0] - targetGroup.x;\n      targetGroup.originY = viewBound[1][0] - targetGroup.y;\n    }\n\n    function getBound(rect) {\n      // [[xmin, xmax], [ymin, ymax]]\n      return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];\n    }\n\n    function toBound(fromPos, from, to, dimIdx, boundIdx) {\n      fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];\n    }\n  };\n\n  SliderTimelineView.prototype._createAxis = function (layoutInfo, timelineModel) {\n    var data = timelineModel.getData();\n    var axisType = timelineModel.get('axisType');\n    var scale = createScaleByModel(timelineModel, axisType); // Customize scale. The `tickValue` is `dataIndex`.\n\n    scale.getTicks = function () {\n      return data.mapArray(['value'], function (value) {\n        return {\n          value: value\n        };\n      });\n    };\n\n    var dataExtent = data.getDataExtent('value');\n    scale.setExtent(dataExtent[0], dataExtent[1]);\n    scale.niceTicks();\n    var axis = new TimelineAxis('value', scale, layoutInfo.axisExtent, axisType);\n    axis.model = timelineModel;\n    return axis;\n  };\n\n  SliderTimelineView.prototype._createGroup = function (key) {\n    var newGroup = this[key] = new graphic.Group();\n    this.group.add(newGroup);\n    return newGroup;\n  };\n\n  SliderTimelineView.prototype._renderAxisLine = function (layoutInfo, group, axis, timelineModel) {\n    var axisExtent = axis.getExtent();\n\n    if (!timelineModel.get(['lineStyle', 'show'])) {\n      return;\n    }\n\n    var line = new graphic.Line({\n      shape: {\n        x1: axisExtent[0],\n        y1: 0,\n        x2: axisExtent[1],\n        y2: 0\n      },\n      style: extend({\n        lineCap: 'round'\n      }, timelineModel.getModel('lineStyle').getLineStyle()),\n      silent: true,\n      z2: 1\n    });\n    group.add(line);\n    var progressLine = this._progressLine = new graphic.Line({\n      shape: {\n        x1: axisExtent[0],\n        x2: this._currentPointer ? this._currentPointer.x : axisExtent[0],\n        y1: 0,\n        y2: 0\n      },\n      style: defaults({\n        lineCap: 'round',\n        lineWidth: line.style.lineWidth\n      }, timelineModel.getModel(['progress', 'lineStyle']).getLineStyle()),\n      silent: true,\n      z2: 1\n    });\n    group.add(progressLine);\n  };\n\n  SliderTimelineView.prototype._renderAxisTick = function (layoutInfo, group, axis, timelineModel) {\n    var _this = this;\n\n    var data = timelineModel.getData(); // Show all ticks, despite ignoring strategy.\n\n    var ticks = axis.scale.getTicks();\n    this._tickSymbols = []; // The value is dataIndex, see the costomized scale.\n\n    each(ticks, function (tick) {\n      var tickCoord = axis.dataToCoord(tick.value);\n      var itemModel = data.getItemModel(tick.value);\n      var itemStyleModel = itemModel.getModel('itemStyle');\n      var hoverStyleModel = itemModel.getModel(['emphasis', 'itemStyle']);\n      var progressStyleModel = itemModel.getModel(['progress', 'itemStyle']);\n      var symbolOpt = {\n        x: tickCoord,\n        y: 0,\n        onclick: bind(_this._changeTimeline, _this, tick.value)\n      };\n      var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);\n      el.ensureState('emphasis').style = hoverStyleModel.getItemStyle();\n      el.ensureState('progress').style = progressStyleModel.getItemStyle();\n      enableHoverEmphasis(el);\n      var ecData = getECData(el);\n\n      if (itemModel.get('tooltip')) {\n        ecData.dataIndex = tick.value;\n        ecData.dataModel = timelineModel;\n      } else {\n        ecData.dataIndex = ecData.dataModel = null;\n      }\n\n      _this._tickSymbols.push(el);\n    });\n  };\n\n  SliderTimelineView.prototype._renderAxisLabel = function (layoutInfo, group, axis, timelineModel) {\n    var _this = this;\n\n    var labelModel = axis.getLabelModel();\n\n    if (!labelModel.get('show')) {\n      return;\n    }\n\n    var data = timelineModel.getData();\n    var labels = axis.getViewLabels();\n    this._tickLabels = [];\n    each(labels, function (labelItem) {\n      // The tickValue is dataIndex, see the costomized scale.\n      var dataIndex = labelItem.tickValue;\n      var itemModel = data.getItemModel(dataIndex);\n      var normalLabelModel = itemModel.getModel('label');\n      var hoverLabelModel = itemModel.getModel(['emphasis', 'label']);\n      var progressLabelModel = itemModel.getModel(['progress', 'label']);\n      var tickCoord = axis.dataToCoord(labelItem.tickValue);\n      var textEl = new graphic.Text({\n        x: tickCoord,\n        y: 0,\n        rotation: layoutInfo.labelRotation - layoutInfo.rotation,\n        onclick: bind(_this._changeTimeline, _this, dataIndex),\n        silent: false,\n        style: createTextStyle(normalLabelModel, {\n          text: labelItem.formattedLabel,\n          align: layoutInfo.labelAlign,\n          verticalAlign: layoutInfo.labelBaseline\n        })\n      });\n      textEl.ensureState('emphasis').style = createTextStyle(hoverLabelModel);\n      textEl.ensureState('progress').style = createTextStyle(progressLabelModel);\n      group.add(textEl);\n      enableHoverEmphasis(textEl);\n      labelDataIndexStore(textEl).dataIndex = dataIndex;\n\n      _this._tickLabels.push(textEl);\n    });\n  };\n\n  SliderTimelineView.prototype._renderControl = function (layoutInfo, group, axis, timelineModel) {\n    var controlSize = layoutInfo.controlSize;\n    var rotation = layoutInfo.rotation;\n    var itemStyle = timelineModel.getModel('controlStyle').getItemStyle();\n    var hoverStyle = timelineModel.getModel(['emphasis', 'controlStyle']).getItemStyle();\n    var playState = timelineModel.getPlayState();\n    var inverse = timelineModel.get('inverse', true);\n    makeBtn(layoutInfo.nextBtnPosition, 'next', bind(this._changeTimeline, this, inverse ? '-' : '+'));\n    makeBtn(layoutInfo.prevBtnPosition, 'prev', bind(this._changeTimeline, this, inverse ? '+' : '-'));\n    makeBtn(layoutInfo.playPosition, playState ? 'stop' : 'play', bind(this._handlePlayClick, this, !playState), true);\n\n    function makeBtn(position, iconName, onclick, willRotate) {\n      if (!position) {\n        return;\n      }\n\n      var iconSize = parsePercent(retrieve2(timelineModel.get(['controlStyle', iconName + 'BtnSize']), controlSize), controlSize);\n      var rect = [0, -iconSize / 2, iconSize, iconSize];\n      var btn = makeControlIcon(timelineModel, iconName + 'Icon', rect, {\n        x: position[0],\n        y: position[1],\n        originX: controlSize / 2,\n        originY: 0,\n        rotation: willRotate ? -rotation : 0,\n        rectHover: true,\n        style: itemStyle,\n        onclick: onclick\n      });\n      btn.ensureState('emphasis').style = hoverStyle;\n      group.add(btn);\n      enableHoverEmphasis(btn);\n    }\n  };\n\n  SliderTimelineView.prototype._renderCurrentPointer = function (layoutInfo, group, axis, timelineModel) {\n    var data = timelineModel.getData();\n    var currentIndex = timelineModel.getCurrentIndex();\n    var pointerModel = data.getItemModel(currentIndex).getModel('checkpointStyle');\n    var me = this;\n    var callback = {\n      onCreate: function (pointer) {\n        pointer.draggable = true;\n        pointer.drift = bind(me._handlePointerDrag, me);\n        pointer.ondragend = bind(me._handlePointerDragend, me);\n        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel, true);\n      },\n      onUpdate: function (pointer) {\n        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel);\n      }\n    }; // Reuse when exists, for animation and drag.\n\n    this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);\n  };\n\n  SliderTimelineView.prototype._handlePlayClick = function (nextState) {\n    this._clearTimer();\n\n    this.api.dispatchAction({\n      type: 'timelinePlayChange',\n      playState: nextState,\n      from: this.uid\n    });\n  };\n\n  SliderTimelineView.prototype._handlePointerDrag = function (dx, dy, e) {\n    this._clearTimer();\n\n    this._pointerChangeTimeline([e.offsetX, e.offsetY]);\n  };\n\n  SliderTimelineView.prototype._handlePointerDragend = function (e) {\n    this._pointerChangeTimeline([e.offsetX, e.offsetY], true);\n  };\n\n  SliderTimelineView.prototype._pointerChangeTimeline = function (mousePos, trigger) {\n    var toCoord = this._toAxisCoord(mousePos)[0];\n\n    var axis = this._axis;\n    var axisExtent = numberUtil.asc(axis.getExtent().slice());\n    toCoord > axisExtent[1] && (toCoord = axisExtent[1]);\n    toCoord < axisExtent[0] && (toCoord = axisExtent[0]);\n    this._currentPointer.x = toCoord;\n\n    this._currentPointer.markRedraw();\n\n    this._progressLine.shape.x2 = toCoord;\n\n    this._progressLine.dirty();\n\n    var targetDataIndex = this._findNearestTick(toCoord);\n\n    var timelineModel = this.model;\n\n    if (trigger || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get('realtime')) {\n      this._changeTimeline(targetDataIndex);\n    }\n  };\n\n  SliderTimelineView.prototype._doPlayStop = function () {\n    var _this = this;\n\n    this._clearTimer();\n\n    if (this.model.getPlayState()) {\n      this._timer = setTimeout(function () {\n        // Do not cache\n        var timelineModel = _this.model;\n\n        _this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get('rewind', true) ? -1 : 1));\n      }, this.model.get('playInterval'));\n    }\n  };\n\n  SliderTimelineView.prototype._toAxisCoord = function (vertex) {\n    var trans = this._mainGroup.getLocalTransform();\n\n    return graphic.applyTransform(vertex, trans, true);\n  };\n\n  SliderTimelineView.prototype._findNearestTick = function (axisCoord) {\n    var data = this.model.getData();\n    var dist = Infinity;\n    var targetDataIndex;\n    var axis = this._axis;\n    data.each(['value'], function (value, dataIndex) {\n      var coord = axis.dataToCoord(value);\n      var d = Math.abs(coord - axisCoord);\n\n      if (d < dist) {\n        dist = d;\n        targetDataIndex = dataIndex;\n      }\n    });\n    return targetDataIndex;\n  };\n\n  SliderTimelineView.prototype._clearTimer = function () {\n    if (this._timer) {\n      clearTimeout(this._timer);\n      this._timer = null;\n    }\n  };\n\n  SliderTimelineView.prototype._changeTimeline = function (nextIndex) {\n    var currentIndex = this.model.getCurrentIndex();\n\n    if (nextIndex === '+') {\n      nextIndex = currentIndex + 1;\n    } else if (nextIndex === '-') {\n      nextIndex = currentIndex - 1;\n    }\n\n    this.api.dispatchAction({\n      type: 'timelineChange',\n      currentIndex: nextIndex,\n      from: this.uid\n    });\n  };\n\n  SliderTimelineView.prototype._updateTicksStatus = function () {\n    var currentIndex = this.model.getCurrentIndex();\n    var tickSymbols = this._tickSymbols;\n    var tickLabels = this._tickLabels;\n\n    if (tickSymbols) {\n      for (var i = 0; i < tickSymbols.length; i++) {\n        tickSymbols && tickSymbols[i] && tickSymbols[i].toggleState('progress', i < currentIndex);\n      }\n    }\n\n    if (tickLabels) {\n      for (var i = 0; i < tickLabels.length; i++) {\n        tickLabels && tickLabels[i] && tickLabels[i].toggleState('progress', labelDataIndexStore(tickLabels[i]).dataIndex <= currentIndex);\n      }\n    }\n  };\n\n  SliderTimelineView.type = 'timeline.slider';\n  return SliderTimelineView;\n}(TimelineView);\n\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new OrdinalScale({\n          ordinalMeta: model.getCategories(),\n          extent: [Infinity, -Infinity]\n        });\n\n      case 'time':\n        return new TimeScale({\n          locale: model.ecModel.getLocaleModel(),\n          useUTC: model.ecModel.get('useUTC')\n        });\n\n      default:\n        // default to be value\n        return new IntervalScale();\n    }\n  }\n}\n\nfunction getViewRect(model, api) {\n  return layout.getLayoutRect(model.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  }, model.get('padding'));\n}\n\nfunction makeControlIcon(timelineModel, objPath, rect, opts) {\n  var style = opts.style;\n  var icon = graphic.createIcon(timelineModel.get(['controlStyle', objPath]), opts || {}, new BoundingRect(rect[0], rect[1], rect[2], rect[3])); // TODO createIcon won't use style in opt.\n\n  if (style) {\n    icon.setStyle(style);\n  }\n\n  return icon;\n}\n/**\n * Create symbol or update symbol\n * opt: basic position and event handlers\n */\n\n\nfunction giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {\n  var color = itemStyleModel.get('color');\n\n  if (!symbol) {\n    var symbolType = hostModel.get('symbol');\n    symbol = createSymbol(symbolType, -1, -1, 2, 2, color);\n    symbol.setStyle('strokeNoScale', true);\n    group.add(symbol);\n    callback && callback.onCreate(symbol);\n  } else {\n    symbol.setColor(color);\n    group.add(symbol); // Group may be new, also need to add.\n\n    callback && callback.onUpdate(symbol);\n  } // Style\n\n\n  var itemStyle = itemStyleModel.getItemStyle(['color']);\n  symbol.setStyle(itemStyle); // Transform and events.\n\n  opt = merge({\n    rectHover: true,\n    z2: 100\n  }, opt, true);\n  var symbolSize = normalizeSymbolSize(hostModel.get('symbolSize'));\n  opt.scaleX = symbolSize[0] / 2;\n  opt.scaleY = symbolSize[1] / 2;\n  var symbolOffset = normalizeSymbolOffset(hostModel.get('symbolOffset'), symbolSize);\n\n  if (symbolOffset) {\n    opt.x = (opt.x || 0) + symbolOffset[0];\n    opt.y = (opt.y || 0) + symbolOffset[1];\n  }\n\n  var symbolRotate = hostModel.get('symbolRotate');\n  opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;\n  symbol.attr(opt); // FIXME\n  // (1) When symbol.style.strokeNoScale is true and updateTransform is not performed,\n  // getBoundingRect will return wrong result.\n  // (This is supposed to be resolved in zrender, but it is a little difficult to\n  // leverage performance and auto updateTransform)\n  // (2) All of ancesters of symbol do not scale, so we can just updateTransform symbol.\n\n  symbol.updateTransform();\n  return symbol;\n}\n\nfunction pointerMoveTo(pointer, progressLine, dataIndex, axis, timelineModel, noAnimation) {\n  if (pointer.dragging) {\n    return;\n  }\n\n  var pointerModel = timelineModel.getModel('checkpointStyle');\n  var toCoord = axis.dataToCoord(timelineModel.getData().get('value', dataIndex));\n\n  if (noAnimation || !pointerModel.get('animation', true)) {\n    pointer.attr({\n      x: toCoord,\n      y: 0\n    });\n    progressLine && progressLine.attr({\n      shape: {\n        x2: toCoord\n      }\n    });\n  } else {\n    var animationCfg = {\n      duration: pointerModel.get('animationDuration', true),\n      easing: pointerModel.get('animationEasing', true)\n    };\n    pointer.stopAnimation(null, true);\n    pointer.animateTo({\n      x: toCoord,\n      y: 0\n    }, animationCfg);\n    progressLine && progressLine.animateTo({\n      shape: {\n        x2: toCoord\n      }\n    }, animationCfg);\n  }\n}\n\nexport default SliderTimelineView;","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/component/timeline/SliderTimelineView.js"],"names":["__extends","BoundingRect","matrix","graphic","createTextStyle","layout","TimelineView","TimelineAxis","createSymbol","normalizeSymbolOffset","normalizeSymbolSize","numberUtil","merge","each","extend","isString","bind","defaults","retrieve2","OrdinalScale","TimeScale","IntervalScale","parsePercent","makeInner","getECData","enableHoverEmphasis","createTooltipMarkup","PI","Math","labelDataIndexStore","SliderTimelineView","_super","_this","apply","arguments","type","prototype","init","ecModel","api","render","timelineModel","model","group","removeAll","get","layoutInfo_1","_layout","mainGroup_1","_createGroup","labelGroup","axis_1","_axis","_createAxis","formatTooltip","dataIndex","name","scale","getLabel","value","noName","_renderAxisLabel","_position","_doPlayStop","_updateTicksStatus","remove","_clearTimer","dispose","labelPosOpt","orient","viewRect","getViewRect","parsedLabelPos","y","height","getHeight","x","width","getWidth","horizontal","top","bottom","vertical","left","right","labelAlignMap","labelBaselineMap","rotationMap","mainLength","controlModel","getModel","showControl","controlSize","controlGap","sizePlusGap","labelRotation","playPosition","prevBtnPosition","nextBtnPosition","controlPosition","showPlayBtn","showPrevBtn","showNextBtn","xLeft","xRight","axisExtent","reverse","rotation","labelAlign","labelBaseline","layoutInfo","mainGroup","_mainGroup","_labelGroup","m","create","rotateOriginX","rotateOriginY","translate","rotate","clone","applyTransform","viewBound","getBound","mainBound","getBoundingRect","labelBound","mainPosition","labelsPosition","mainBoundIdx","toBound","setPosition","setOrigin","targetGroup","originX","originY","rect","fromPos","from","to","dimIdx","boundIdx","data","getData","axisType","createScaleByModel","getTicks","mapArray","dataExtent","getDataExtent","setExtent","niceTicks","axis","key","newGroup","Group","add","_renderAxisLine","getExtent","line","Line","shape","x1","y1","x2","y2","style","lineCap","getLineStyle","silent","z2","progressLine","_progressLine","_currentPointer","lineWidth","_renderAxisTick","ticks","_tickSymbols","tick","tickCoord","dataToCoord","itemModel","getItemModel","itemStyleModel","hoverStyleModel","progressStyleModel","symbolOpt","onclick","_changeTimeline","el","giveSymbol","ensureState","getItemStyle","ecData","dataModel","push","labelModel","getLabelModel","labels","getViewLabels","_tickLabels","labelItem","tickValue","normalLabelModel","hoverLabelModel","progressLabelModel","textEl","Text","text","formattedLabel","align","verticalAlign","_renderControl","itemStyle","hoverStyle","playState","getPlayState","inverse","makeBtn","_handlePlayClick","position","iconName","willRotate","iconSize","btn","makeControlIcon","rectHover","_renderCurrentPointer","currentIndex","getCurrentIndex","pointerModel","me","callback","onCreate","pointer","draggable","drift","_handlePointerDrag","ondragend","_handlePointerDragend","pointerMoveTo","onUpdate","nextState","dispatchAction","uid","dx","dy","e","_pointerChangeTimeline","offsetX","offsetY","mousePos","trigger","toCoord","_toAxisCoord","asc","slice","markRedraw","dirty","targetDataIndex","_findNearestTick","_timer","setTimeout","vertex","trans","getLocalTransform","axisCoord","dist","Infinity","coord","d","abs","clearTimeout","nextIndex","tickSymbols","tickLabels","i","length","toggleState","ordinalMeta","getCategories","extent","locale","getLocaleModel","useUTC","getLayoutRect","getBoxLayoutParams","objPath","opts","icon","createIcon","setStyle","hostModel","opt","symbol","color","symbolType","setColor","symbolSize","scaleX","scaleY","symbolOffset","symbolRotate","attr","updateTransform","noAnimation","dragging","animationCfg","duration","easing","stopAnimation","animateTo"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport BoundingRect from 'zrender/lib/core/BoundingRect';\nimport * as matrix from 'zrender/lib/core/matrix';\nimport * as graphic from '../../util/graphic';\nimport { createTextStyle } from '../../label/labelStyle';\nimport * as layout from '../../util/layout';\nimport TimelineView from './TimelineView';\nimport TimelineAxis from './TimelineAxis';\nimport { createSymbol, normalizeSymbolOffset, normalizeSymbolSize } from '../../util/symbol';\nimport * as numberUtil from '../../util/number';\nimport { merge, each, extend, isString, bind, defaults, retrieve2 } from 'zrender/lib/core/util';\nimport OrdinalScale from '../../scale/Ordinal';\nimport TimeScale from '../../scale/Time';\nimport IntervalScale from '../../scale/Interval';\nimport { parsePercent } from 'zrender/lib/contain/text';\nimport { makeInner } from '../../util/model';\nimport { getECData } from '../../util/innerStore';\nimport { enableHoverEmphasis } from '../../util/states';\nimport { createTooltipMarkup } from '../tooltip/tooltipMarkup';\nvar PI = Math.PI;\nvar labelDataIndexStore = makeInner();\n\nvar SliderTimelineView =\n/** @class */\nfunction (_super) {\n  __extends(SliderTimelineView, _super);\n\n  function SliderTimelineView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = SliderTimelineView.type;\n    return _this;\n  }\n\n  SliderTimelineView.prototype.init = function (ecModel, api) {\n    this.api = api;\n  };\n  /**\n   * @override\n   */\n\n\n  SliderTimelineView.prototype.render = function (timelineModel, ecModel, api) {\n    this.model = timelineModel;\n    this.api = api;\n    this.ecModel = ecModel;\n    this.group.removeAll();\n\n    if (timelineModel.get('show', true)) {\n      var layoutInfo_1 = this._layout(timelineModel, api);\n\n      var mainGroup_1 = this._createGroup('_mainGroup');\n\n      var labelGroup = this._createGroup('_labelGroup');\n\n      var axis_1 = this._axis = this._createAxis(layoutInfo_1, timelineModel);\n\n      timelineModel.formatTooltip = function (dataIndex) {\n        var name = axis_1.scale.getLabel({\n          value: dataIndex\n        });\n        return createTooltipMarkup('nameValue', {\n          noName: true,\n          value: name\n        });\n      };\n\n      each(['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'], function (name) {\n        this['_render' + name](layoutInfo_1, mainGroup_1, axis_1, timelineModel);\n      }, this);\n\n      this._renderAxisLabel(layoutInfo_1, labelGroup, axis_1, timelineModel);\n\n      this._position(layoutInfo_1, timelineModel);\n    }\n\n    this._doPlayStop();\n\n    this._updateTicksStatus();\n  };\n  /**\n   * @override\n   */\n\n\n  SliderTimelineView.prototype.remove = function () {\n    this._clearTimer();\n\n    this.group.removeAll();\n  };\n  /**\n   * @override\n   */\n\n\n  SliderTimelineView.prototype.dispose = function () {\n    this._clearTimer();\n  };\n\n  SliderTimelineView.prototype._layout = function (timelineModel, api) {\n    var labelPosOpt = timelineModel.get(['label', 'position']);\n    var orient = timelineModel.get('orient');\n    var viewRect = getViewRect(timelineModel, api);\n    var parsedLabelPos; // Auto label offset.\n\n    if (labelPosOpt == null || labelPosOpt === 'auto') {\n      parsedLabelPos = orient === 'horizontal' ? viewRect.y + viewRect.height / 2 < api.getHeight() / 2 ? '-' : '+' : viewRect.x + viewRect.width / 2 < api.getWidth() / 2 ? '+' : '-';\n    } else if (isString(labelPosOpt)) {\n      parsedLabelPos = {\n        horizontal: {\n          top: '-',\n          bottom: '+'\n        },\n        vertical: {\n          left: '-',\n          right: '+'\n        }\n      }[orient][labelPosOpt];\n    } else {\n      // is number\n      parsedLabelPos = labelPosOpt;\n    }\n\n    var labelAlignMap = {\n      horizontal: 'center',\n      vertical: parsedLabelPos >= 0 || parsedLabelPos === '+' ? 'left' : 'right'\n    };\n    var labelBaselineMap = {\n      horizontal: parsedLabelPos >= 0 || parsedLabelPos === '+' ? 'top' : 'bottom',\n      vertical: 'middle'\n    };\n    var rotationMap = {\n      horizontal: 0,\n      vertical: PI / 2\n    }; // Position\n\n    var mainLength = orient === 'vertical' ? viewRect.height : viewRect.width;\n    var controlModel = timelineModel.getModel('controlStyle');\n    var showControl = controlModel.get('show', true);\n    var controlSize = showControl ? controlModel.get('itemSize') : 0;\n    var controlGap = showControl ? controlModel.get('itemGap') : 0;\n    var sizePlusGap = controlSize + controlGap; // Special label rotate.\n\n    var labelRotation = timelineModel.get(['label', 'rotate']) || 0;\n    labelRotation = labelRotation * PI / 180; // To radian.\n\n    var playPosition;\n    var prevBtnPosition;\n    var nextBtnPosition;\n    var controlPosition = controlModel.get('position', true);\n    var showPlayBtn = showControl && controlModel.get('showPlayBtn', true);\n    var showPrevBtn = showControl && controlModel.get('showPrevBtn', true);\n    var showNextBtn = showControl && controlModel.get('showNextBtn', true);\n    var xLeft = 0;\n    var xRight = mainLength; // position[0] means left, position[1] means middle.\n\n    if (controlPosition === 'left' || controlPosition === 'bottom') {\n      showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);\n      showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);\n      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n    } else {\n      // 'top' 'right'\n      showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n      showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);\n      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n    }\n\n    var axisExtent = [xLeft, xRight];\n\n    if (timelineModel.get('inverse')) {\n      axisExtent.reverse();\n    }\n\n    return {\n      viewRect: viewRect,\n      mainLength: mainLength,\n      orient: orient,\n      rotation: rotationMap[orient],\n      labelRotation: labelRotation,\n      labelPosOpt: parsedLabelPos,\n      labelAlign: timelineModel.get(['label', 'align']) || labelAlignMap[orient],\n      labelBaseline: timelineModel.get(['label', 'verticalAlign']) || timelineModel.get(['label', 'baseline']) || labelBaselineMap[orient],\n      // Based on mainGroup.\n      playPosition: playPosition,\n      prevBtnPosition: prevBtnPosition,\n      nextBtnPosition: nextBtnPosition,\n      axisExtent: axisExtent,\n      controlSize: controlSize,\n      controlGap: controlGap\n    };\n  };\n\n  SliderTimelineView.prototype._position = function (layoutInfo, timelineModel) {\n    // Position is be called finally, because bounding rect is needed for\n    // adapt content to fill viewRect (auto adapt offset).\n    // Timeline may be not all in the viewRect when 'offset' is specified\n    // as a number, because it is more appropriate that label aligns at\n    // 'offset' but not the other edge defined by viewRect.\n    var mainGroup = this._mainGroup;\n    var labelGroup = this._labelGroup;\n    var viewRect = layoutInfo.viewRect;\n\n    if (layoutInfo.orient === 'vertical') {\n      // transform to horizontal, inverse rotate by left-top point.\n      var m = matrix.create();\n      var rotateOriginX = viewRect.x;\n      var rotateOriginY = viewRect.y + viewRect.height;\n      matrix.translate(m, m, [-rotateOriginX, -rotateOriginY]);\n      matrix.rotate(m, m, -PI / 2);\n      matrix.translate(m, m, [rotateOriginX, rotateOriginY]);\n      viewRect = viewRect.clone();\n      viewRect.applyTransform(m);\n    }\n\n    var viewBound = getBound(viewRect);\n    var mainBound = getBound(mainGroup.getBoundingRect());\n    var labelBound = getBound(labelGroup.getBoundingRect());\n    var mainPosition = [mainGroup.x, mainGroup.y];\n    var labelsPosition = [labelGroup.x, labelGroup.y];\n    labelsPosition[0] = mainPosition[0] = viewBound[0][0];\n    var labelPosOpt = layoutInfo.labelPosOpt;\n\n    if (labelPosOpt == null || isString(labelPosOpt)) {\n      // '+' or '-'\n      var mainBoundIdx = labelPosOpt === '+' ? 0 : 1;\n      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);\n      toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);\n    } else {\n      var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;\n      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);\n      labelsPosition[1] = mainPosition[1] + labelPosOpt;\n    }\n\n    mainGroup.setPosition(mainPosition);\n    labelGroup.setPosition(labelsPosition);\n    mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;\n    setOrigin(mainGroup);\n    setOrigin(labelGroup);\n\n    function setOrigin(targetGroup) {\n      targetGroup.originX = viewBound[0][0] - targetGroup.x;\n      targetGroup.originY = viewBound[1][0] - targetGroup.y;\n    }\n\n    function getBound(rect) {\n      // [[xmin, xmax], [ymin, ymax]]\n      return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];\n    }\n\n    function toBound(fromPos, from, to, dimIdx, boundIdx) {\n      fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];\n    }\n  };\n\n  SliderTimelineView.prototype._createAxis = function (layoutInfo, timelineModel) {\n    var data = timelineModel.getData();\n    var axisType = timelineModel.get('axisType');\n    var scale = createScaleByModel(timelineModel, axisType); // Customize scale. The `tickValue` is `dataIndex`.\n\n    scale.getTicks = function () {\n      return data.mapArray(['value'], function (value) {\n        return {\n          value: value\n        };\n      });\n    };\n\n    var dataExtent = data.getDataExtent('value');\n    scale.setExtent(dataExtent[0], dataExtent[1]);\n    scale.niceTicks();\n    var axis = new TimelineAxis('value', scale, layoutInfo.axisExtent, axisType);\n    axis.model = timelineModel;\n    return axis;\n  };\n\n  SliderTimelineView.prototype._createGroup = function (key) {\n    var newGroup = this[key] = new graphic.Group();\n    this.group.add(newGroup);\n    return newGroup;\n  };\n\n  SliderTimelineView.prototype._renderAxisLine = function (layoutInfo, group, axis, timelineModel) {\n    var axisExtent = axis.getExtent();\n\n    if (!timelineModel.get(['lineStyle', 'show'])) {\n      return;\n    }\n\n    var line = new graphic.Line({\n      shape: {\n        x1: axisExtent[0],\n        y1: 0,\n        x2: axisExtent[1],\n        y2: 0\n      },\n      style: extend({\n        lineCap: 'round'\n      }, timelineModel.getModel('lineStyle').getLineStyle()),\n      silent: true,\n      z2: 1\n    });\n    group.add(line);\n    var progressLine = this._progressLine = new graphic.Line({\n      shape: {\n        x1: axisExtent[0],\n        x2: this._currentPointer ? this._currentPointer.x : axisExtent[0],\n        y1: 0,\n        y2: 0\n      },\n      style: defaults({\n        lineCap: 'round',\n        lineWidth: line.style.lineWidth\n      }, timelineModel.getModel(['progress', 'lineStyle']).getLineStyle()),\n      silent: true,\n      z2: 1\n    });\n    group.add(progressLine);\n  };\n\n  SliderTimelineView.prototype._renderAxisTick = function (layoutInfo, group, axis, timelineModel) {\n    var _this = this;\n\n    var data = timelineModel.getData(); // Show all ticks, despite ignoring strategy.\n\n    var ticks = axis.scale.getTicks();\n    this._tickSymbols = []; // The value is dataIndex, see the costomized scale.\n\n    each(ticks, function (tick) {\n      var tickCoord = axis.dataToCoord(tick.value);\n      var itemModel = data.getItemModel(tick.value);\n      var itemStyleModel = itemModel.getModel('itemStyle');\n      var hoverStyleModel = itemModel.getModel(['emphasis', 'itemStyle']);\n      var progressStyleModel = itemModel.getModel(['progress', 'itemStyle']);\n      var symbolOpt = {\n        x: tickCoord,\n        y: 0,\n        onclick: bind(_this._changeTimeline, _this, tick.value)\n      };\n      var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);\n      el.ensureState('emphasis').style = hoverStyleModel.getItemStyle();\n      el.ensureState('progress').style = progressStyleModel.getItemStyle();\n      enableHoverEmphasis(el);\n      var ecData = getECData(el);\n\n      if (itemModel.get('tooltip')) {\n        ecData.dataIndex = tick.value;\n        ecData.dataModel = timelineModel;\n      } else {\n        ecData.dataIndex = ecData.dataModel = null;\n      }\n\n      _this._tickSymbols.push(el);\n    });\n  };\n\n  SliderTimelineView.prototype._renderAxisLabel = function (layoutInfo, group, axis, timelineModel) {\n    var _this = this;\n\n    var labelModel = axis.getLabelModel();\n\n    if (!labelModel.get('show')) {\n      return;\n    }\n\n    var data = timelineModel.getData();\n    var labels = axis.getViewLabels();\n    this._tickLabels = [];\n    each(labels, function (labelItem) {\n      // The tickValue is dataIndex, see the costomized scale.\n      var dataIndex = labelItem.tickValue;\n      var itemModel = data.getItemModel(dataIndex);\n      var normalLabelModel = itemModel.getModel('label');\n      var hoverLabelModel = itemModel.getModel(['emphasis', 'label']);\n      var progressLabelModel = itemModel.getModel(['progress', 'label']);\n      var tickCoord = axis.dataToCoord(labelItem.tickValue);\n      var textEl = new graphic.Text({\n        x: tickCoord,\n        y: 0,\n        rotation: layoutInfo.labelRotation - layoutInfo.rotation,\n        onclick: bind(_this._changeTimeline, _this, dataIndex),\n        silent: false,\n        style: createTextStyle(normalLabelModel, {\n          text: labelItem.formattedLabel,\n          align: layoutInfo.labelAlign,\n          verticalAlign: layoutInfo.labelBaseline\n        })\n      });\n      textEl.ensureState('emphasis').style = createTextStyle(hoverLabelModel);\n      textEl.ensureState('progress').style = createTextStyle(progressLabelModel);\n      group.add(textEl);\n      enableHoverEmphasis(textEl);\n      labelDataIndexStore(textEl).dataIndex = dataIndex;\n\n      _this._tickLabels.push(textEl);\n    });\n  };\n\n  SliderTimelineView.prototype._renderControl = function (layoutInfo, group, axis, timelineModel) {\n    var controlSize = layoutInfo.controlSize;\n    var rotation = layoutInfo.rotation;\n    var itemStyle = timelineModel.getModel('controlStyle').getItemStyle();\n    var hoverStyle = timelineModel.getModel(['emphasis', 'controlStyle']).getItemStyle();\n    var playState = timelineModel.getPlayState();\n    var inverse = timelineModel.get('inverse', true);\n    makeBtn(layoutInfo.nextBtnPosition, 'next', bind(this._changeTimeline, this, inverse ? '-' : '+'));\n    makeBtn(layoutInfo.prevBtnPosition, 'prev', bind(this._changeTimeline, this, inverse ? '+' : '-'));\n    makeBtn(layoutInfo.playPosition, playState ? 'stop' : 'play', bind(this._handlePlayClick, this, !playState), true);\n\n    function makeBtn(position, iconName, onclick, willRotate) {\n      if (!position) {\n        return;\n      }\n\n      var iconSize = parsePercent(retrieve2(timelineModel.get(['controlStyle', iconName + 'BtnSize']), controlSize), controlSize);\n      var rect = [0, -iconSize / 2, iconSize, iconSize];\n      var btn = makeControlIcon(timelineModel, iconName + 'Icon', rect, {\n        x: position[0],\n        y: position[1],\n        originX: controlSize / 2,\n        originY: 0,\n        rotation: willRotate ? -rotation : 0,\n        rectHover: true,\n        style: itemStyle,\n        onclick: onclick\n      });\n      btn.ensureState('emphasis').style = hoverStyle;\n      group.add(btn);\n      enableHoverEmphasis(btn);\n    }\n  };\n\n  SliderTimelineView.prototype._renderCurrentPointer = function (layoutInfo, group, axis, timelineModel) {\n    var data = timelineModel.getData();\n    var currentIndex = timelineModel.getCurrentIndex();\n    var pointerModel = data.getItemModel(currentIndex).getModel('checkpointStyle');\n    var me = this;\n    var callback = {\n      onCreate: function (pointer) {\n        pointer.draggable = true;\n        pointer.drift = bind(me._handlePointerDrag, me);\n        pointer.ondragend = bind(me._handlePointerDragend, me);\n        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel, true);\n      },\n      onUpdate: function (pointer) {\n        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel);\n      }\n    }; // Reuse when exists, for animation and drag.\n\n    this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);\n  };\n\n  SliderTimelineView.prototype._handlePlayClick = function (nextState) {\n    this._clearTimer();\n\n    this.api.dispatchAction({\n      type: 'timelinePlayChange',\n      playState: nextState,\n      from: this.uid\n    });\n  };\n\n  SliderTimelineView.prototype._handlePointerDrag = function (dx, dy, e) {\n    this._clearTimer();\n\n    this._pointerChangeTimeline([e.offsetX, e.offsetY]);\n  };\n\n  SliderTimelineView.prototype._handlePointerDragend = function (e) {\n    this._pointerChangeTimeline([e.offsetX, e.offsetY], true);\n  };\n\n  SliderTimelineView.prototype._pointerChangeTimeline = function (mousePos, trigger) {\n    var toCoord = this._toAxisCoord(mousePos)[0];\n\n    var axis = this._axis;\n    var axisExtent = numberUtil.asc(axis.getExtent().slice());\n    toCoord > axisExtent[1] && (toCoord = axisExtent[1]);\n    toCoord < axisExtent[0] && (toCoord = axisExtent[0]);\n    this._currentPointer.x = toCoord;\n\n    this._currentPointer.markRedraw();\n\n    this._progressLine.shape.x2 = toCoord;\n\n    this._progressLine.dirty();\n\n    var targetDataIndex = this._findNearestTick(toCoord);\n\n    var timelineModel = this.model;\n\n    if (trigger || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get('realtime')) {\n      this._changeTimeline(targetDataIndex);\n    }\n  };\n\n  SliderTimelineView.prototype._doPlayStop = function () {\n    var _this = this;\n\n    this._clearTimer();\n\n    if (this.model.getPlayState()) {\n      this._timer = setTimeout(function () {\n        // Do not cache\n        var timelineModel = _this.model;\n\n        _this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get('rewind', true) ? -1 : 1));\n      }, this.model.get('playInterval'));\n    }\n  };\n\n  SliderTimelineView.prototype._toAxisCoord = function (vertex) {\n    var trans = this._mainGroup.getLocalTransform();\n\n    return graphic.applyTransform(vertex, trans, true);\n  };\n\n  SliderTimelineView.prototype._findNearestTick = function (axisCoord) {\n    var data = this.model.getData();\n    var dist = Infinity;\n    var targetDataIndex;\n    var axis = this._axis;\n    data.each(['value'], function (value, dataIndex) {\n      var coord = axis.dataToCoord(value);\n      var d = Math.abs(coord - axisCoord);\n\n      if (d < dist) {\n        dist = d;\n        targetDataIndex = dataIndex;\n      }\n    });\n    return targetDataIndex;\n  };\n\n  SliderTimelineView.prototype._clearTimer = function () {\n    if (this._timer) {\n      clearTimeout(this._timer);\n      this._timer = null;\n    }\n  };\n\n  SliderTimelineView.prototype._changeTimeline = function (nextIndex) {\n    var currentIndex = this.model.getCurrentIndex();\n\n    if (nextIndex === '+') {\n      nextIndex = currentIndex + 1;\n    } else if (nextIndex === '-') {\n      nextIndex = currentIndex - 1;\n    }\n\n    this.api.dispatchAction({\n      type: 'timelineChange',\n      currentIndex: nextIndex,\n      from: this.uid\n    });\n  };\n\n  SliderTimelineView.prototype._updateTicksStatus = function () {\n    var currentIndex = this.model.getCurrentIndex();\n    var tickSymbols = this._tickSymbols;\n    var tickLabels = this._tickLabels;\n\n    if (tickSymbols) {\n      for (var i = 0; i < tickSymbols.length; i++) {\n        tickSymbols && tickSymbols[i] && tickSymbols[i].toggleState('progress', i < currentIndex);\n      }\n    }\n\n    if (tickLabels) {\n      for (var i = 0; i < tickLabels.length; i++) {\n        tickLabels && tickLabels[i] && tickLabels[i].toggleState('progress', labelDataIndexStore(tickLabels[i]).dataIndex <= currentIndex);\n      }\n    }\n  };\n\n  SliderTimelineView.type = 'timeline.slider';\n  return SliderTimelineView;\n}(TimelineView);\n\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new OrdinalScale({\n          ordinalMeta: model.getCategories(),\n          extent: [Infinity, -Infinity]\n        });\n\n      case 'time':\n        return new TimeScale({\n          locale: model.ecModel.getLocaleModel(),\n          useUTC: model.ecModel.get('useUTC')\n        });\n\n      default:\n        // default to be value\n        return new IntervalScale();\n    }\n  }\n}\n\nfunction getViewRect(model, api) {\n  return layout.getLayoutRect(model.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  }, model.get('padding'));\n}\n\nfunction makeControlIcon(timelineModel, objPath, rect, opts) {\n  var style = opts.style;\n  var icon = graphic.createIcon(timelineModel.get(['controlStyle', objPath]), opts || {}, new BoundingRect(rect[0], rect[1], rect[2], rect[3])); // TODO createIcon won't use style in opt.\n\n  if (style) {\n    icon.setStyle(style);\n  }\n\n  return icon;\n}\n/**\n * Create symbol or update symbol\n * opt: basic position and event handlers\n */\n\n\nfunction giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {\n  var color = itemStyleModel.get('color');\n\n  if (!symbol) {\n    var symbolType = hostModel.get('symbol');\n    symbol = createSymbol(symbolType, -1, -1, 2, 2, color);\n    symbol.setStyle('strokeNoScale', true);\n    group.add(symbol);\n    callback && callback.onCreate(symbol);\n  } else {\n    symbol.setColor(color);\n    group.add(symbol); // Group may be new, also need to add.\n\n    callback && callback.onUpdate(symbol);\n  } // Style\n\n\n  var itemStyle = itemStyleModel.getItemStyle(['color']);\n  symbol.setStyle(itemStyle); // Transform and events.\n\n  opt = merge({\n    rectHover: true,\n    z2: 100\n  }, opt, true);\n  var symbolSize = normalizeSymbolSize(hostModel.get('symbolSize'));\n  opt.scaleX = symbolSize[0] / 2;\n  opt.scaleY = symbolSize[1] / 2;\n  var symbolOffset = normalizeSymbolOffset(hostModel.get('symbolOffset'), symbolSize);\n\n  if (symbolOffset) {\n    opt.x = (opt.x || 0) + symbolOffset[0];\n    opt.y = (opt.y || 0) + symbolOffset[1];\n  }\n\n  var symbolRotate = hostModel.get('symbolRotate');\n  opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;\n  symbol.attr(opt); // FIXME\n  // (1) When symbol.style.strokeNoScale is true and updateTransform is not performed,\n  // getBoundingRect will return wrong result.\n  // (This is supposed to be resolved in zrender, but it is a little difficult to\n  // leverage performance and auto updateTransform)\n  // (2) All of ancesters of symbol do not scale, so we can just updateTransform symbol.\n\n  symbol.updateTransform();\n  return symbol;\n}\n\nfunction pointerMoveTo(pointer, progressLine, dataIndex, axis, timelineModel, noAnimation) {\n  if (pointer.dragging) {\n    return;\n  }\n\n  var pointerModel = timelineModel.getModel('checkpointStyle');\n  var toCoord = axis.dataToCoord(timelineModel.getData().get('value', dataIndex));\n\n  if (noAnimation || !pointerModel.get('animation', true)) {\n    pointer.attr({\n      x: toCoord,\n      y: 0\n    });\n    progressLine && progressLine.attr({\n      shape: {\n        x2: toCoord\n      }\n    });\n  } else {\n    var animationCfg = {\n      duration: pointerModel.get('animationDuration', true),\n      easing: pointerModel.get('animationEasing', true)\n    };\n    pointer.stopAnimation(null, true);\n    pointer.animateTo({\n      x: toCoord,\n      y: 0\n    }, animationCfg);\n    progressLine && progressLine.animateTo({\n      shape: {\n        x2: toCoord\n      }\n    }, animationCfg);\n  }\n}\n\nexport default SliderTimelineView;"]},"metadata":{},"sourceType":"module"}