{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util';\nimport * as zrColor from 'zrender/lib/tool/color';\nimport { linearMap } from '../util/number';\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar CATEGORY_DEFAULT_VISUAL_INDEX = -1;\n\nvar VisualMapping =\n/** @class */\nfunction () {\n  function VisualMapping(option) {\n    var mappingMethod = option.mappingMethod;\n    var visualType = option.type;\n    var thisOption = this.option = zrUtil.clone(option);\n    this.type = visualType;\n    this.mappingMethod = mappingMethod;\n    this._normalizeData = normalizers[mappingMethod];\n    var visualHandler = VisualMapping.visualHandlers[visualType];\n    this.applyVisual = visualHandler.applyVisual;\n    this.getColorMapper = visualHandler.getColorMapper;\n    this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];\n\n    if (mappingMethod === 'piecewise') {\n      normalizeVisualRange(thisOption);\n      preprocessForPiecewise(thisOption);\n    } else if (mappingMethod === 'category') {\n      thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,\n      // which need no more preprocess except normalize visual.\n      : normalizeVisualRange(thisOption, true);\n    } else {\n      // mappingMethod === 'linear' or 'fixed'\n      zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);\n      normalizeVisualRange(thisOption);\n    }\n  }\n\n  VisualMapping.prototype.mapValueToVisual = function (value) {\n    var normalized = this._normalizeData(value);\n\n    return this._normalizedToVisual(normalized, value);\n  };\n\n  VisualMapping.prototype.getNormalizer = function () {\n    return zrUtil.bind(this._normalizeData, this);\n  };\n  /**\n   * List available visual types.\n   *\n   * @public\n   * @return {Array.<string>}\n   */\n\n\n  VisualMapping.listVisualTypes = function () {\n    return zrUtil.keys(VisualMapping.visualHandlers);\n  }; // /**\n  //  * @public\n  //  */\n  // static addVisualHandler(name, handler) {\n  //     visualHandlers[name] = handler;\n  // }\n\n  /**\n   * @public\n   */\n\n\n  VisualMapping.isValidType = function (visualType) {\n    return VisualMapping.visualHandlers.hasOwnProperty(visualType);\n  };\n  /**\n   * Convinent method.\n   * Visual can be Object or Array or primary type.\n   */\n\n\n  VisualMapping.eachVisual = function (visual, callback, context) {\n    if (zrUtil.isObject(visual)) {\n      zrUtil.each(visual, callback, context);\n    } else {\n      callback.call(context, visual);\n    }\n  };\n\n  VisualMapping.mapVisual = function (visual, callback, context) {\n    var isPrimary;\n    var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);\n    VisualMapping.eachVisual(visual, function (v, key) {\n      var newVal = callback.call(context, v, key);\n      isPrimary ? newVisual = newVal : newVisual[key] = newVal;\n    });\n    return newVisual;\n  };\n  /**\n   * Retrieve visual properties from given object.\n   */\n\n\n  VisualMapping.retrieveVisuals = function (obj) {\n    var ret = {};\n    var hasVisual;\n    obj && each(VisualMapping.visualHandlers, function (h, visualType) {\n      if (obj.hasOwnProperty(visualType)) {\n        ret[visualType] = obj[visualType];\n        hasVisual = true;\n      }\n    });\n    return hasVisual ? ret : null;\n  };\n  /**\n   * Give order to visual types, considering colorSaturation, colorAlpha depends on color.\n   *\n   * @public\n   * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}\n   *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']\n   * @return {Array.<string>} Sorted visual types.\n   */\n\n\n  VisualMapping.prepareVisualTypes = function (visualTypes) {\n    if (zrUtil.isArray(visualTypes)) {\n      visualTypes = visualTypes.slice();\n    } else if (isObject(visualTypes)) {\n      var types_1 = [];\n      each(visualTypes, function (item, type) {\n        types_1.push(type);\n      });\n      visualTypes = types_1;\n    } else {\n      return [];\n    }\n\n    visualTypes.sort(function (type1, type2) {\n      // color should be front of colorSaturation, colorAlpha, ...\n      // symbol and symbolSize do not matter.\n      return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;\n    });\n    return visualTypes;\n  };\n  /**\n   * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.\n   * Other visuals are only depends on themself.\n   */\n\n\n  VisualMapping.dependsOn = function (visualType1, visualType2) {\n    return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;\n  };\n  /**\n   * @param value\n   * @param pieceList [{value: ..., interval: [min, max]}, ...]\n   *                         Always from small to big.\n   * @param findClosestWhenOutside Default to be false\n   * @return index\n   */\n\n\n  VisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\n    var possibleI;\n    var abs = Infinity; // value has the higher priority.\n\n    for (var i = 0, len = pieceList.length; i < len; i++) {\n      var pieceValue = pieceList[i].value;\n\n      if (pieceValue != null) {\n        if (pieceValue === value // FIXME\n        // It is supposed to compare value according to value type of dimension,\n        // but currently value type can exactly be string or number.\n        // Compromise for numeric-like string (like '12'), especially\n        // in the case that visualMap.categories is ['22', '33'].\n        || typeof pieceValue === 'string' && pieceValue === value + '') {\n          return i;\n        }\n\n        findClosestWhenOutside && updatePossible(pieceValue, i);\n      }\n    }\n\n    for (var i = 0, len = pieceList.length; i < len; i++) {\n      var piece = pieceList[i];\n      var interval = piece.interval;\n      var close_1 = piece.close;\n\n      if (interval) {\n        if (interval[0] === -Infinity) {\n          if (littleThan(close_1[1], value, interval[1])) {\n            return i;\n          }\n        } else if (interval[1] === Infinity) {\n          if (littleThan(close_1[0], interval[0], value)) {\n            return i;\n          }\n        } else if (littleThan(close_1[0], interval[0], value) && littleThan(close_1[1], value, interval[1])) {\n          return i;\n        }\n\n        findClosestWhenOutside && updatePossible(interval[0], i);\n        findClosestWhenOutside && updatePossible(interval[1], i);\n      }\n    }\n\n    if (findClosestWhenOutside) {\n      return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;\n    }\n\n    function updatePossible(val, index) {\n      var newAbs = Math.abs(val - value);\n\n      if (newAbs < abs) {\n        abs = newAbs;\n        possibleI = index;\n      }\n    }\n  };\n\n  VisualMapping.visualHandlers = {\n    color: {\n      applyVisual: makeApplyVisual('color'),\n      getColorMapper: function () {\n        var thisOption = this.option;\n        return zrUtil.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {\n          !isNormalized && (value = this._normalizeData(value));\n          return doMapCategory.call(this, value);\n        } : function (value, isNormalized, out) {\n          // If output rgb array\n          // which will be much faster and useful in pixel manipulation\n          var returnRGBArray = !!out;\n          !isNormalized && (value = this._normalizeData(value));\n          out = zrColor.fastLerp(value, thisOption.parsedVisual, out);\n          return returnRGBArray ? out : zrColor.stringify(out, 'rgba');\n        }, this);\n      },\n      _normalizedToVisual: {\n        linear: function (normalized) {\n          return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n        },\n        category: doMapCategory,\n        piecewise: function (normalized, value) {\n          var result = getSpecifiedVisual.call(this, value);\n\n          if (result == null) {\n            result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n          }\n\n          return result;\n        },\n        fixed: doMapFixed\n      }\n    },\n    colorHue: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, value);\n    }),\n    colorSaturation: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, null, value);\n    }),\n    colorLightness: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, null, null, value);\n    }),\n    colorAlpha: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyAlpha(color, value);\n    }),\n    decal: {\n      applyVisual: makeApplyVisual('decal'),\n      _normalizedToVisual: {\n        linear: null,\n        category: doMapCategory,\n        piecewise: null,\n        fixed: null\n      }\n    },\n    opacity: {\n      applyVisual: makeApplyVisual('opacity'),\n      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n    },\n    liftZ: {\n      applyVisual: makeApplyVisual('liftZ'),\n      _normalizedToVisual: {\n        linear: doMapFixed,\n        category: doMapFixed,\n        piecewise: doMapFixed,\n        fixed: doMapFixed\n      }\n    },\n    symbol: {\n      applyVisual: function (value, getter, setter) {\n        var symbolCfg = this.mapValueToVisual(value);\n        setter('symbol', symbolCfg);\n      },\n      _normalizedToVisual: {\n        linear: doMapToArray,\n        category: doMapCategory,\n        piecewise: function (normalized, value) {\n          var result = getSpecifiedVisual.call(this, value);\n\n          if (result == null) {\n            result = doMapToArray.call(this, normalized);\n          }\n\n          return result;\n        },\n        fixed: doMapFixed\n      }\n    },\n    symbolSize: {\n      applyVisual: makeApplyVisual('symbolSize'),\n      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n    }\n  };\n  return VisualMapping;\n}();\n\nfunction preprocessForPiecewise(thisOption) {\n  var pieceList = thisOption.pieceList;\n  thisOption.hasSpecialVisual = false;\n  zrUtil.each(pieceList, function (piece, index) {\n    piece.originIndex = index; // piece.visual is \"result visual value\" but not\n    // a visual range, so it does not need to be normalized.\n\n    if (piece.visual != null) {\n      thisOption.hasSpecialVisual = true;\n    }\n  });\n}\n\nfunction preprocessForSpecifiedCategory(thisOption) {\n  // Hash categories.\n  var categories = thisOption.categories;\n  var categoryMap = thisOption.categoryMap = {};\n  var visual = thisOption.visual;\n  each(categories, function (cate, index) {\n    categoryMap[cate] = index;\n  }); // Process visual map input.\n\n  if (!zrUtil.isArray(visual)) {\n    var visualArr_1 = [];\n\n    if (zrUtil.isObject(visual)) {\n      each(visual, function (v, cate) {\n        var index = categoryMap[cate];\n        visualArr_1[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\n      });\n    } else {\n      // Is primary type, represents default visual.\n      visualArr_1[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\n    }\n\n    visual = setVisualToOption(thisOption, visualArr_1);\n  } // Remove categories that has no visual,\n  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.\n\n\n  for (var i = categories.length - 1; i >= 0; i--) {\n    if (visual[i] == null) {\n      delete categoryMap[categories[i]];\n      categories.pop();\n    }\n  }\n}\n\nfunction normalizeVisualRange(thisOption, isCategory) {\n  var visual = thisOption.visual;\n  var visualArr = [];\n\n  if (zrUtil.isObject(visual)) {\n    each(visual, function (v) {\n      visualArr.push(v);\n    });\n  } else if (visual != null) {\n    visualArr.push(visual);\n  }\n\n  var doNotNeedPair = {\n    color: 1,\n    symbol: 1\n  };\n\n  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {\n    // Do not care visualArr.length === 0, which is illegal.\n    visualArr[1] = visualArr[0];\n  }\n\n  setVisualToOption(thisOption, visualArr);\n}\n\nfunction makePartialColorVisualHandler(applyValue) {\n  return {\n    applyVisual: function (value, getter, setter) {\n      // Only used in HSL\n      var colorChannel = this.mapValueToVisual(value); // Must not be array value\n\n      setter('color', applyValue(getter('color'), colorChannel));\n    },\n    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n  };\n}\n\nfunction doMapToArray(normalized) {\n  var visual = this.option.visual;\n  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {}; // TODO {}?\n}\n\nfunction makeApplyVisual(visualType) {\n  return function (value, getter, setter) {\n    setter(visualType, this.mapValueToVisual(value));\n  };\n}\n\nfunction doMapCategory(normalized) {\n  var visual = this.option.visual;\n  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];\n}\n\nfunction doMapFixed() {\n  // visual will be convert to array.\n  return this.option.visual[0];\n}\n/**\n * Create mapped to numeric visual\n */\n\n\nfunction createNormalizedToNumericVisual(sourceExtent) {\n  return {\n    linear: function (normalized) {\n      return linearMap(normalized, sourceExtent, this.option.visual, true);\n    },\n    category: doMapCategory,\n    piecewise: function (normalized, value) {\n      var result = getSpecifiedVisual.call(this, value);\n\n      if (result == null) {\n        result = linearMap(normalized, sourceExtent, this.option.visual, true);\n      }\n\n      return result;\n    },\n    fixed: doMapFixed\n  };\n}\n\nfunction getSpecifiedVisual(value) {\n  var thisOption = this.option;\n  var pieceList = thisOption.pieceList;\n\n  if (thisOption.hasSpecialVisual) {\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\n    var piece = pieceList[pieceIndex];\n\n    if (piece && piece.visual) {\n      return piece.visual[this.type];\n    }\n  }\n}\n\nfunction setVisualToOption(thisOption, visualArr) {\n  thisOption.visual = visualArr;\n\n  if (thisOption.type === 'color') {\n    thisOption.parsedVisual = zrUtil.map(visualArr, function (item) {\n      return zrColor.parse(item);\n    });\n  }\n\n  return visualArr;\n}\n/**\n * Normalizers by mapping methods.\n */\n\n\nvar normalizers = {\n  linear: function (value) {\n    return linearMap(value, this.option.dataExtent, [0, 1], true);\n  },\n  piecewise: function (value) {\n    var pieceList = this.option.pieceList;\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\n\n    if (pieceIndex != null) {\n      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\n    }\n  },\n  category: function (value) {\n    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal value\n\n    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\n  },\n  fixed: zrUtil.noop\n};\n\nfunction littleThan(close, a, b) {\n  return close ? a <= b : a < b;\n}\n\nexport default VisualMapping;","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/visual/VisualMapping.js"],"names":["zrUtil","zrColor","linearMap","each","isObject","CATEGORY_DEFAULT_VISUAL_INDEX","VisualMapping","option","mappingMethod","visualType","type","thisOption","clone","_normalizeData","normalizers","visualHandler","visualHandlers","applyVisual","getColorMapper","_normalizedToVisual","normalizeVisualRange","preprocessForPiecewise","categories","preprocessForSpecifiedCategory","assert","dataExtent","prototype","mapValueToVisual","value","normalized","getNormalizer","bind","listVisualTypes","keys","isValidType","hasOwnProperty","eachVisual","visual","callback","context","call","mapVisual","isPrimary","newVisual","isArray","v","key","newVal","retrieveVisuals","obj","ret","hasVisual","h","prepareVisualTypes","visualTypes","slice","types_1","item","push","sort","type1","type2","indexOf","dependsOn","visualType1","visualType2","findPieceIndex","pieceList","findClosestWhenOutside","possibleI","abs","Infinity","i","len","length","pieceValue","updatePossible","piece","interval","close_1","close","littleThan","val","index","newAbs","Math","color","makeApplyVisual","isNormalized","doMapCategory","out","returnRGBArray","fastLerp","parsedVisual","stringify","linear","category","piecewise","result","getSpecifiedVisual","fixed","doMapFixed","colorHue","makePartialColorVisualHandler","modifyHSL","colorSaturation","colorLightness","colorAlpha","modifyAlpha","decal","opacity","createNormalizedToNumericVisual","liftZ","symbol","getter","setter","symbolCfg","doMapToArray","symbolSize","hasSpecialVisual","originIndex","categoryMap","cate","visualArr_1","setVisualToOption","pop","isCategory","visualArr","doNotNeedPair","applyValue","colorChannel","round","loop","sourceExtent","pieceIndex","map","parse","noop","a","b"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util';\nimport * as zrColor from 'zrender/lib/tool/color';\nimport { linearMap } from '../util/number';\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar CATEGORY_DEFAULT_VISUAL_INDEX = -1;\n\nvar VisualMapping =\n/** @class */\nfunction () {\n  function VisualMapping(option) {\n    var mappingMethod = option.mappingMethod;\n    var visualType = option.type;\n    var thisOption = this.option = zrUtil.clone(option);\n    this.type = visualType;\n    this.mappingMethod = mappingMethod;\n    this._normalizeData = normalizers[mappingMethod];\n    var visualHandler = VisualMapping.visualHandlers[visualType];\n    this.applyVisual = visualHandler.applyVisual;\n    this.getColorMapper = visualHandler.getColorMapper;\n    this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];\n\n    if (mappingMethod === 'piecewise') {\n      normalizeVisualRange(thisOption);\n      preprocessForPiecewise(thisOption);\n    } else if (mappingMethod === 'category') {\n      thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,\n      // which need no more preprocess except normalize visual.\n      : normalizeVisualRange(thisOption, true);\n    } else {\n      // mappingMethod === 'linear' or 'fixed'\n      zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);\n      normalizeVisualRange(thisOption);\n    }\n  }\n\n  VisualMapping.prototype.mapValueToVisual = function (value) {\n    var normalized = this._normalizeData(value);\n\n    return this._normalizedToVisual(normalized, value);\n  };\n\n  VisualMapping.prototype.getNormalizer = function () {\n    return zrUtil.bind(this._normalizeData, this);\n  };\n  /**\n   * List available visual types.\n   *\n   * @public\n   * @return {Array.<string>}\n   */\n\n\n  VisualMapping.listVisualTypes = function () {\n    return zrUtil.keys(VisualMapping.visualHandlers);\n  }; // /**\n  //  * @public\n  //  */\n  // static addVisualHandler(name, handler) {\n  //     visualHandlers[name] = handler;\n  // }\n\n  /**\n   * @public\n   */\n\n\n  VisualMapping.isValidType = function (visualType) {\n    return VisualMapping.visualHandlers.hasOwnProperty(visualType);\n  };\n  /**\n   * Convinent method.\n   * Visual can be Object or Array or primary type.\n   */\n\n\n  VisualMapping.eachVisual = function (visual, callback, context) {\n    if (zrUtil.isObject(visual)) {\n      zrUtil.each(visual, callback, context);\n    } else {\n      callback.call(context, visual);\n    }\n  };\n\n  VisualMapping.mapVisual = function (visual, callback, context) {\n    var isPrimary;\n    var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);\n    VisualMapping.eachVisual(visual, function (v, key) {\n      var newVal = callback.call(context, v, key);\n      isPrimary ? newVisual = newVal : newVisual[key] = newVal;\n    });\n    return newVisual;\n  };\n  /**\n   * Retrieve visual properties from given object.\n   */\n\n\n  VisualMapping.retrieveVisuals = function (obj) {\n    var ret = {};\n    var hasVisual;\n    obj && each(VisualMapping.visualHandlers, function (h, visualType) {\n      if (obj.hasOwnProperty(visualType)) {\n        ret[visualType] = obj[visualType];\n        hasVisual = true;\n      }\n    });\n    return hasVisual ? ret : null;\n  };\n  /**\n   * Give order to visual types, considering colorSaturation, colorAlpha depends on color.\n   *\n   * @public\n   * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}\n   *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']\n   * @return {Array.<string>} Sorted visual types.\n   */\n\n\n  VisualMapping.prepareVisualTypes = function (visualTypes) {\n    if (zrUtil.isArray(visualTypes)) {\n      visualTypes = visualTypes.slice();\n    } else if (isObject(visualTypes)) {\n      var types_1 = [];\n      each(visualTypes, function (item, type) {\n        types_1.push(type);\n      });\n      visualTypes = types_1;\n    } else {\n      return [];\n    }\n\n    visualTypes.sort(function (type1, type2) {\n      // color should be front of colorSaturation, colorAlpha, ...\n      // symbol and symbolSize do not matter.\n      return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;\n    });\n    return visualTypes;\n  };\n  /**\n   * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.\n   * Other visuals are only depends on themself.\n   */\n\n\n  VisualMapping.dependsOn = function (visualType1, visualType2) {\n    return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;\n  };\n  /**\n   * @param value\n   * @param pieceList [{value: ..., interval: [min, max]}, ...]\n   *                         Always from small to big.\n   * @param findClosestWhenOutside Default to be false\n   * @return index\n   */\n\n\n  VisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\n    var possibleI;\n    var abs = Infinity; // value has the higher priority.\n\n    for (var i = 0, len = pieceList.length; i < len; i++) {\n      var pieceValue = pieceList[i].value;\n\n      if (pieceValue != null) {\n        if (pieceValue === value // FIXME\n        // It is supposed to compare value according to value type of dimension,\n        // but currently value type can exactly be string or number.\n        // Compromise for numeric-like string (like '12'), especially\n        // in the case that visualMap.categories is ['22', '33'].\n        || typeof pieceValue === 'string' && pieceValue === value + '') {\n          return i;\n        }\n\n        findClosestWhenOutside && updatePossible(pieceValue, i);\n      }\n    }\n\n    for (var i = 0, len = pieceList.length; i < len; i++) {\n      var piece = pieceList[i];\n      var interval = piece.interval;\n      var close_1 = piece.close;\n\n      if (interval) {\n        if (interval[0] === -Infinity) {\n          if (littleThan(close_1[1], value, interval[1])) {\n            return i;\n          }\n        } else if (interval[1] === Infinity) {\n          if (littleThan(close_1[0], interval[0], value)) {\n            return i;\n          }\n        } else if (littleThan(close_1[0], interval[0], value) && littleThan(close_1[1], value, interval[1])) {\n          return i;\n        }\n\n        findClosestWhenOutside && updatePossible(interval[0], i);\n        findClosestWhenOutside && updatePossible(interval[1], i);\n      }\n    }\n\n    if (findClosestWhenOutside) {\n      return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;\n    }\n\n    function updatePossible(val, index) {\n      var newAbs = Math.abs(val - value);\n\n      if (newAbs < abs) {\n        abs = newAbs;\n        possibleI = index;\n      }\n    }\n  };\n\n  VisualMapping.visualHandlers = {\n    color: {\n      applyVisual: makeApplyVisual('color'),\n      getColorMapper: function () {\n        var thisOption = this.option;\n        return zrUtil.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {\n          !isNormalized && (value = this._normalizeData(value));\n          return doMapCategory.call(this, value);\n        } : function (value, isNormalized, out) {\n          // If output rgb array\n          // which will be much faster and useful in pixel manipulation\n          var returnRGBArray = !!out;\n          !isNormalized && (value = this._normalizeData(value));\n          out = zrColor.fastLerp(value, thisOption.parsedVisual, out);\n          return returnRGBArray ? out : zrColor.stringify(out, 'rgba');\n        }, this);\n      },\n      _normalizedToVisual: {\n        linear: function (normalized) {\n          return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n        },\n        category: doMapCategory,\n        piecewise: function (normalized, value) {\n          var result = getSpecifiedVisual.call(this, value);\n\n          if (result == null) {\n            result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n          }\n\n          return result;\n        },\n        fixed: doMapFixed\n      }\n    },\n    colorHue: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, value);\n    }),\n    colorSaturation: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, null, value);\n    }),\n    colorLightness: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, null, null, value);\n    }),\n    colorAlpha: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyAlpha(color, value);\n    }),\n    decal: {\n      applyVisual: makeApplyVisual('decal'),\n      _normalizedToVisual: {\n        linear: null,\n        category: doMapCategory,\n        piecewise: null,\n        fixed: null\n      }\n    },\n    opacity: {\n      applyVisual: makeApplyVisual('opacity'),\n      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n    },\n    liftZ: {\n      applyVisual: makeApplyVisual('liftZ'),\n      _normalizedToVisual: {\n        linear: doMapFixed,\n        category: doMapFixed,\n        piecewise: doMapFixed,\n        fixed: doMapFixed\n      }\n    },\n    symbol: {\n      applyVisual: function (value, getter, setter) {\n        var symbolCfg = this.mapValueToVisual(value);\n        setter('symbol', symbolCfg);\n      },\n      _normalizedToVisual: {\n        linear: doMapToArray,\n        category: doMapCategory,\n        piecewise: function (normalized, value) {\n          var result = getSpecifiedVisual.call(this, value);\n\n          if (result == null) {\n            result = doMapToArray.call(this, normalized);\n          }\n\n          return result;\n        },\n        fixed: doMapFixed\n      }\n    },\n    symbolSize: {\n      applyVisual: makeApplyVisual('symbolSize'),\n      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n    }\n  };\n  return VisualMapping;\n}();\n\nfunction preprocessForPiecewise(thisOption) {\n  var pieceList = thisOption.pieceList;\n  thisOption.hasSpecialVisual = false;\n  zrUtil.each(pieceList, function (piece, index) {\n    piece.originIndex = index; // piece.visual is \"result visual value\" but not\n    // a visual range, so it does not need to be normalized.\n\n    if (piece.visual != null) {\n      thisOption.hasSpecialVisual = true;\n    }\n  });\n}\n\nfunction preprocessForSpecifiedCategory(thisOption) {\n  // Hash categories.\n  var categories = thisOption.categories;\n  var categoryMap = thisOption.categoryMap = {};\n  var visual = thisOption.visual;\n  each(categories, function (cate, index) {\n    categoryMap[cate] = index;\n  }); // Process visual map input.\n\n  if (!zrUtil.isArray(visual)) {\n    var visualArr_1 = [];\n\n    if (zrUtil.isObject(visual)) {\n      each(visual, function (v, cate) {\n        var index = categoryMap[cate];\n        visualArr_1[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\n      });\n    } else {\n      // Is primary type, represents default visual.\n      visualArr_1[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\n    }\n\n    visual = setVisualToOption(thisOption, visualArr_1);\n  } // Remove categories that has no visual,\n  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.\n\n\n  for (var i = categories.length - 1; i >= 0; i--) {\n    if (visual[i] == null) {\n      delete categoryMap[categories[i]];\n      categories.pop();\n    }\n  }\n}\n\nfunction normalizeVisualRange(thisOption, isCategory) {\n  var visual = thisOption.visual;\n  var visualArr = [];\n\n  if (zrUtil.isObject(visual)) {\n    each(visual, function (v) {\n      visualArr.push(v);\n    });\n  } else if (visual != null) {\n    visualArr.push(visual);\n  }\n\n  var doNotNeedPair = {\n    color: 1,\n    symbol: 1\n  };\n\n  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {\n    // Do not care visualArr.length === 0, which is illegal.\n    visualArr[1] = visualArr[0];\n  }\n\n  setVisualToOption(thisOption, visualArr);\n}\n\nfunction makePartialColorVisualHandler(applyValue) {\n  return {\n    applyVisual: function (value, getter, setter) {\n      // Only used in HSL\n      var colorChannel = this.mapValueToVisual(value); // Must not be array value\n\n      setter('color', applyValue(getter('color'), colorChannel));\n    },\n    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n  };\n}\n\nfunction doMapToArray(normalized) {\n  var visual = this.option.visual;\n  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {}; // TODO {}?\n}\n\nfunction makeApplyVisual(visualType) {\n  return function (value, getter, setter) {\n    setter(visualType, this.mapValueToVisual(value));\n  };\n}\n\nfunction doMapCategory(normalized) {\n  var visual = this.option.visual;\n  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];\n}\n\nfunction doMapFixed() {\n  // visual will be convert to array.\n  return this.option.visual[0];\n}\n/**\n * Create mapped to numeric visual\n */\n\n\nfunction createNormalizedToNumericVisual(sourceExtent) {\n  return {\n    linear: function (normalized) {\n      return linearMap(normalized, sourceExtent, this.option.visual, true);\n    },\n    category: doMapCategory,\n    piecewise: function (normalized, value) {\n      var result = getSpecifiedVisual.call(this, value);\n\n      if (result == null) {\n        result = linearMap(normalized, sourceExtent, this.option.visual, true);\n      }\n\n      return result;\n    },\n    fixed: doMapFixed\n  };\n}\n\nfunction getSpecifiedVisual(value) {\n  var thisOption = this.option;\n  var pieceList = thisOption.pieceList;\n\n  if (thisOption.hasSpecialVisual) {\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\n    var piece = pieceList[pieceIndex];\n\n    if (piece && piece.visual) {\n      return piece.visual[this.type];\n    }\n  }\n}\n\nfunction setVisualToOption(thisOption, visualArr) {\n  thisOption.visual = visualArr;\n\n  if (thisOption.type === 'color') {\n    thisOption.parsedVisual = zrUtil.map(visualArr, function (item) {\n      return zrColor.parse(item);\n    });\n  }\n\n  return visualArr;\n}\n/**\n * Normalizers by mapping methods.\n */\n\n\nvar normalizers = {\n  linear: function (value) {\n    return linearMap(value, this.option.dataExtent, [0, 1], true);\n  },\n  piecewise: function (value) {\n    var pieceList = this.option.pieceList;\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\n\n    if (pieceIndex != null) {\n      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\n    }\n  },\n  category: function (value) {\n    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal value\n\n    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\n  },\n  fixed: zrUtil.noop\n};\n\nfunction littleThan(close, a, b) {\n  return close ? a <= b : a < b;\n}\n\nexport default VisualMapping;"]},"metadata":{},"sourceType":"module"}