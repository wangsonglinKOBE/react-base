{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { BoundingRect, OrientedBoundingRect } from '../util/graphic';\nexport function prepareLayoutList(input) {\n  var list = [];\n\n  for (var i = 0; i < input.length; i++) {\n    var rawItem = input[i];\n\n    if (rawItem.defaultAttr.ignore) {\n      continue;\n    }\n\n    var label = rawItem.label;\n    var transform = label.getComputedTransform(); // NOTE: Get bounding rect after getComputedTransform, or label may not been updated by the host el.\n\n    var localRect = label.getBoundingRect();\n    var isAxisAligned = !transform || transform[1] < 1e-5 && transform[2] < 1e-5;\n    var minMargin = label.style.margin || 0;\n    var globalRect = localRect.clone();\n    globalRect.applyTransform(transform);\n    globalRect.x -= minMargin / 2;\n    globalRect.y -= minMargin / 2;\n    globalRect.width += minMargin;\n    globalRect.height += minMargin;\n    var obb = isAxisAligned ? new OrientedBoundingRect(localRect, transform) : null;\n    list.push({\n      label: label,\n      labelLine: rawItem.labelLine,\n      rect: globalRect,\n      localRect: localRect,\n      obb: obb,\n      priority: rawItem.priority,\n      defaultAttr: rawItem.defaultAttr,\n      layoutOption: rawItem.computedLayoutOption,\n      axisAligned: isAxisAligned,\n      transform: transform\n    });\n  }\n\n  return list;\n}\n\nfunction shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {\n  var len = list.length;\n\n  if (len < 2) {\n    return;\n  }\n\n  list.sort(function (a, b) {\n    return a.rect[xyDim] - b.rect[xyDim];\n  });\n  var lastPos = 0;\n  var delta;\n  var adjusted = false;\n  var shifts = [];\n  var totalShifts = 0;\n\n  for (var i = 0; i < len; i++) {\n    var item = list[i];\n    var rect = item.rect;\n    delta = rect[xyDim] - lastPos;\n\n    if (delta < 0) {\n      // shiftForward(i, len, -delta);\n      rect[xyDim] -= delta;\n      item.label[xyDim] -= delta;\n      adjusted = true;\n    }\n\n    var shift = Math.max(-delta, 0);\n    shifts.push(shift);\n    totalShifts += shift;\n    lastPos = rect[xyDim] + rect[sizeDim];\n  }\n\n  if (totalShifts > 0 && balanceShift) {\n    // Shift back to make the distribution more equally.\n    shiftList(-totalShifts / len, 0, len);\n  } // TODO bleedMargin?\n\n\n  var first = list[0];\n  var last = list[len - 1];\n  var minGap;\n  var maxGap;\n  updateMinMaxGap(); // If ends exceed two bounds, squeeze at most 80%, then take the gap of two bounds.\n\n  minGap < 0 && squeezeGaps(-minGap, 0.8);\n  maxGap < 0 && squeezeGaps(maxGap, 0.8);\n  updateMinMaxGap();\n  takeBoundsGap(minGap, maxGap, 1);\n  takeBoundsGap(maxGap, minGap, -1); // Handle bailout when there is not enough space.\n\n  updateMinMaxGap();\n\n  if (minGap < 0) {\n    squeezeWhenBailout(-minGap);\n  }\n\n  if (maxGap < 0) {\n    squeezeWhenBailout(maxGap);\n  }\n\n  function updateMinMaxGap() {\n    minGap = first.rect[xyDim] - minBound;\n    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];\n  }\n\n  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {\n    if (gapThisBound < 0) {\n      // Move from other gap if can.\n      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);\n\n      if (moveFromMaxGap > 0) {\n        shiftList(moveFromMaxGap * moveDir, 0, len);\n        var remained = moveFromMaxGap + gapThisBound;\n\n        if (remained < 0) {\n          squeezeGaps(-remained * moveDir, 1);\n        }\n      } else {\n        squeezeGaps(-gapThisBound * moveDir, 1);\n      }\n    }\n  }\n\n  function shiftList(delta, start, end) {\n    if (delta !== 0) {\n      adjusted = true;\n    }\n\n    for (var i = start; i < end; i++) {\n      var item = list[i];\n      var rect = item.rect;\n      rect[xyDim] += delta;\n      item.label[xyDim] += delta;\n    }\n  } // Squeeze gaps if the labels exceed margin.\n\n\n  function squeezeGaps(delta, maxSqeezePercent) {\n    var gaps = [];\n    var totalGaps = 0;\n\n    for (var i = 1; i < len; i++) {\n      var prevItemRect = list[i - 1].rect;\n      var gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);\n      gaps.push(gap);\n      totalGaps += gap;\n    }\n\n    if (!totalGaps) {\n      return;\n    }\n\n    var squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent);\n\n    if (delta > 0) {\n      for (var i = 0; i < len - 1; i++) {\n        // Distribute the shift delta to all gaps.\n        var movement = gaps[i] * squeezePercent; // Forward\n\n        shiftList(movement, 0, i + 1);\n      }\n    } else {\n      // Backward\n      for (var i = len - 1; i > 0; i--) {\n        // Distribute the shift delta to all gaps.\n        var movement = gaps[i - 1] * squeezePercent;\n        shiftList(-movement, i, len);\n      }\n    }\n  }\n  /**\n   * Squeeze to allow overlap if there is no more space available.\n   * Let other overlapping strategy like hideOverlap do the job instead of keep exceeding the bounds.\n   */\n\n\n  function squeezeWhenBailout(delta) {\n    var dir = delta < 0 ? -1 : 1;\n    delta = Math.abs(delta);\n    var moveForEachLabel = Math.ceil(delta / (len - 1));\n\n    for (var i = 0; i < len - 1; i++) {\n      if (dir > 0) {\n        // Forward\n        shiftList(moveForEachLabel, 0, i + 1);\n      } else {\n        // Backward\n        shiftList(-moveForEachLabel, len - i - 1, len);\n      }\n\n      delta -= moveForEachLabel;\n\n      if (delta <= 0) {\n        return;\n      }\n    }\n  }\n\n  return adjusted;\n}\n/**\n * Adjust labels on x direction to avoid overlap.\n */\n\n\nexport function shiftLayoutOnX(list, leftBound, rightBound, // If average the shifts on all labels and add them to 0\n// TODO: Not sure if should enable it.\n// Pros: The angle of lines will distribute more equally\n// Cons: In some layout. It may not what user wanted. like in pie. the label of last sector is usually changed unexpectedly.\nbalanceShift) {\n  return shiftLayout(list, 'x', 'width', leftBound, rightBound, balanceShift);\n}\n/**\n * Adjust labels on y direction to avoid overlap.\n */\n\nexport function shiftLayoutOnY(list, topBound, bottomBound, // If average the shifts on all labels and add them to 0\nbalanceShift) {\n  return shiftLayout(list, 'y', 'height', topBound, bottomBound, balanceShift);\n}\nexport function hideOverlap(labelList) {\n  var displayedLabels = []; // TODO, render overflow visible first, put in the displayedLabels.\n\n  labelList.sort(function (a, b) {\n    return b.priority - a.priority;\n  });\n  var globalRect = new BoundingRect(0, 0, 0, 0);\n\n  function hideEl(el) {\n    if (!el.ignore) {\n      // Show on emphasis.\n      var emphasisState = el.ensureState('emphasis');\n\n      if (emphasisState.ignore == null) {\n        emphasisState.ignore = false;\n      }\n    }\n\n    el.ignore = true;\n  }\n\n  for (var i = 0; i < labelList.length; i++) {\n    var labelItem = labelList[i];\n    var isAxisAligned = labelItem.axisAligned;\n    var localRect = labelItem.localRect;\n    var transform = labelItem.transform;\n    var label = labelItem.label;\n    var labelLine = labelItem.labelLine;\n    globalRect.copy(labelItem.rect); // Add a threshold because layout may be aligned precisely.\n\n    globalRect.width -= 0.1;\n    globalRect.height -= 0.1;\n    globalRect.x += 0.05;\n    globalRect.y += 0.05;\n    var obb = labelItem.obb;\n    var overlapped = false;\n\n    for (var j = 0; j < displayedLabels.length; j++) {\n      var existsTextCfg = displayedLabels[j]; // Fast rejection.\n\n      if (!globalRect.intersect(existsTextCfg.rect)) {\n        continue;\n      }\n\n      if (isAxisAligned && existsTextCfg.axisAligned) {\n        // Is overlapped\n        overlapped = true;\n        break;\n      }\n\n      if (!existsTextCfg.obb) {\n        // If self is not axis aligned. But other is.\n        existsTextCfg.obb = new OrientedBoundingRect(existsTextCfg.localRect, existsTextCfg.transform);\n      }\n\n      if (!obb) {\n        // If self is axis aligned. But other is not.\n        obb = new OrientedBoundingRect(localRect, transform);\n      }\n\n      if (obb.intersect(existsTextCfg.obb)) {\n        overlapped = true;\n        break;\n      }\n    } // TODO Callback to determine if this overlap should be handled?\n\n\n    if (overlapped) {\n      hideEl(label);\n      labelLine && hideEl(labelLine);\n    } else {\n      label.attr('ignore', labelItem.defaultAttr.ignore);\n      labelLine && labelLine.attr('ignore', labelItem.defaultAttr.labelGuideIgnore);\n      displayedLabels.push(labelItem);\n    }\n  }\n}","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/label/labelLayoutHelper.js"],"names":["BoundingRect","OrientedBoundingRect","prepareLayoutList","input","list","i","length","rawItem","defaultAttr","ignore","label","transform","getComputedTransform","localRect","getBoundingRect","isAxisAligned","minMargin","style","margin","globalRect","clone","applyTransform","x","y","width","height","obb","push","labelLine","rect","priority","layoutOption","computedLayoutOption","axisAligned","shiftLayout","xyDim","sizeDim","minBound","maxBound","balanceShift","len","sort","a","b","lastPos","delta","adjusted","shifts","totalShifts","item","shift","Math","max","shiftList","first","last","minGap","maxGap","updateMinMaxGap","squeezeGaps","takeBoundsGap","squeezeWhenBailout","gapThisBound","gapOtherBound","moveDir","moveFromMaxGap","min","remained","start","end","maxSqeezePercent","gaps","totalGaps","prevItemRect","gap","squeezePercent","abs","movement","dir","moveForEachLabel","ceil","shiftLayoutOnX","leftBound","rightBound","shiftLayoutOnY","topBound","bottomBound","hideOverlap","labelList","displayedLabels","hideEl","el","emphasisState","ensureState","labelItem","copy","overlapped","j","existsTextCfg","intersect","attr","labelGuideIgnore"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,YAAT,EAAuBC,oBAAvB,QAAmD,iBAAnD;AACA,OAAO,SAASC,iBAAT,CAA2BC,KAA3B,EAAkC;AACvC,MAAIC,IAAI,GAAG,EAAX;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACG,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACrC,QAAIE,OAAO,GAAGJ,KAAK,CAACE,CAAD,CAAnB;;AAEA,QAAIE,OAAO,CAACC,WAAR,CAAoBC,MAAxB,EAAgC;AAC9B;AACD;;AAED,QAAIC,KAAK,GAAGH,OAAO,CAACG,KAApB;AACA,QAAIC,SAAS,GAAGD,KAAK,CAACE,oBAAN,EAAhB,CARqC,CAQS;;AAE9C,QAAIC,SAAS,GAAGH,KAAK,CAACI,eAAN,EAAhB;AACA,QAAIC,aAAa,GAAG,CAACJ,SAAD,IAAcA,SAAS,CAAC,CAAD,CAAT,GAAe,IAAf,IAAuBA,SAAS,CAAC,CAAD,CAAT,GAAe,IAAxE;AACA,QAAIK,SAAS,GAAGN,KAAK,CAACO,KAAN,CAAYC,MAAZ,IAAsB,CAAtC;AACA,QAAIC,UAAU,GAAGN,SAAS,CAACO,KAAV,EAAjB;AACAD,IAAAA,UAAU,CAACE,cAAX,CAA0BV,SAA1B;AACAQ,IAAAA,UAAU,CAACG,CAAX,IAAgBN,SAAS,GAAG,CAA5B;AACAG,IAAAA,UAAU,CAACI,CAAX,IAAgBP,SAAS,GAAG,CAA5B;AACAG,IAAAA,UAAU,CAACK,KAAX,IAAoBR,SAApB;AACAG,IAAAA,UAAU,CAACM,MAAX,IAAqBT,SAArB;AACA,QAAIU,GAAG,GAAGX,aAAa,GAAG,IAAId,oBAAJ,CAAyBY,SAAzB,EAAoCF,SAApC,CAAH,GAAoD,IAA3E;AACAP,IAAAA,IAAI,CAACuB,IAAL,CAAU;AACRjB,MAAAA,KAAK,EAAEA,KADC;AAERkB,MAAAA,SAAS,EAAErB,OAAO,CAACqB,SAFX;AAGRC,MAAAA,IAAI,EAAEV,UAHE;AAIRN,MAAAA,SAAS,EAAEA,SAJH;AAKRa,MAAAA,GAAG,EAAEA,GALG;AAMRI,MAAAA,QAAQ,EAAEvB,OAAO,CAACuB,QANV;AAORtB,MAAAA,WAAW,EAAED,OAAO,CAACC,WAPb;AAQRuB,MAAAA,YAAY,EAAExB,OAAO,CAACyB,oBARd;AASRC,MAAAA,WAAW,EAAElB,aATL;AAURJ,MAAAA,SAAS,EAAEA;AAVH,KAAV;AAYD;;AAED,SAAOP,IAAP;AACD;;AAED,SAAS8B,WAAT,CAAqB9B,IAArB,EAA2B+B,KAA3B,EAAkCC,OAAlC,EAA2CC,QAA3C,EAAqDC,QAArD,EAA+DC,YAA/D,EAA6E;AAC3E,MAAIC,GAAG,GAAGpC,IAAI,CAACE,MAAf;;AAEA,MAAIkC,GAAG,GAAG,CAAV,EAAa;AACX;AACD;;AAEDpC,EAAAA,IAAI,CAACqC,IAAL,CAAU,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AACxB,WAAOD,CAAC,CAACb,IAAF,CAAOM,KAAP,IAAgBQ,CAAC,CAACd,IAAF,CAAOM,KAAP,CAAvB;AACD,GAFD;AAGA,MAAIS,OAAO,GAAG,CAAd;AACA,MAAIC,KAAJ;AACA,MAAIC,QAAQ,GAAG,KAAf;AACA,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,WAAW,GAAG,CAAlB;;AAEA,OAAK,IAAI3C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmC,GAApB,EAAyBnC,CAAC,EAA1B,EAA8B;AAC5B,QAAI4C,IAAI,GAAG7C,IAAI,CAACC,CAAD,CAAf;AACA,QAAIwB,IAAI,GAAGoB,IAAI,CAACpB,IAAhB;AACAgB,IAAAA,KAAK,GAAGhB,IAAI,CAACM,KAAD,CAAJ,GAAcS,OAAtB;;AAEA,QAAIC,KAAK,GAAG,CAAZ,EAAe;AACb;AACAhB,MAAAA,IAAI,CAACM,KAAD,CAAJ,IAAeU,KAAf;AACAI,MAAAA,IAAI,CAACvC,KAAL,CAAWyB,KAAX,KAAqBU,KAArB;AACAC,MAAAA,QAAQ,GAAG,IAAX;AACD;;AAED,QAAII,KAAK,GAAGC,IAAI,CAACC,GAAL,CAAS,CAACP,KAAV,EAAiB,CAAjB,CAAZ;AACAE,IAAAA,MAAM,CAACpB,IAAP,CAAYuB,KAAZ;AACAF,IAAAA,WAAW,IAAIE,KAAf;AACAN,IAAAA,OAAO,GAAGf,IAAI,CAACM,KAAD,CAAJ,GAAcN,IAAI,CAACO,OAAD,CAA5B;AACD;;AAED,MAAIY,WAAW,GAAG,CAAd,IAAmBT,YAAvB,EAAqC;AACnC;AACAc,IAAAA,SAAS,CAAC,CAACL,WAAD,GAAeR,GAAhB,EAAqB,CAArB,EAAwBA,GAAxB,CAAT;AACD,GArC0E,CAqCzE;;;AAGF,MAAIc,KAAK,GAAGlD,IAAI,CAAC,CAAD,CAAhB;AACA,MAAImD,IAAI,GAAGnD,IAAI,CAACoC,GAAG,GAAG,CAAP,CAAf;AACA,MAAIgB,MAAJ;AACA,MAAIC,MAAJ;AACAC,EAAAA,eAAe,GA5C4D,CA4CxD;;AAEnBF,EAAAA,MAAM,GAAG,CAAT,IAAcG,WAAW,CAAC,CAACH,MAAF,EAAU,GAAV,CAAzB;AACAC,EAAAA,MAAM,GAAG,CAAT,IAAcE,WAAW,CAACF,MAAD,EAAS,GAAT,CAAzB;AACAC,EAAAA,eAAe;AACfE,EAAAA,aAAa,CAACJ,MAAD,EAASC,MAAT,EAAiB,CAAjB,CAAb;AACAG,EAAAA,aAAa,CAACH,MAAD,EAASD,MAAT,EAAiB,CAAC,CAAlB,CAAb,CAlD2E,CAkDxC;;AAEnCE,EAAAA,eAAe;;AAEf,MAAIF,MAAM,GAAG,CAAb,EAAgB;AACdK,IAAAA,kBAAkB,CAAC,CAACL,MAAF,CAAlB;AACD;;AAED,MAAIC,MAAM,GAAG,CAAb,EAAgB;AACdI,IAAAA,kBAAkB,CAACJ,MAAD,CAAlB;AACD;;AAED,WAASC,eAAT,GAA2B;AACzBF,IAAAA,MAAM,GAAGF,KAAK,CAACzB,IAAN,CAAWM,KAAX,IAAoBE,QAA7B;AACAoB,IAAAA,MAAM,GAAGnB,QAAQ,GAAGiB,IAAI,CAAC1B,IAAL,CAAUM,KAAV,CAAX,GAA8BoB,IAAI,CAAC1B,IAAL,CAAUO,OAAV,CAAvC;AACD;;AAED,WAASwB,aAAT,CAAuBE,YAAvB,EAAqCC,aAArC,EAAoDC,OAApD,EAA6D;AAC3D,QAAIF,YAAY,GAAG,CAAnB,EAAsB;AACpB;AACA,UAAIG,cAAc,GAAGd,IAAI,CAACe,GAAL,CAASH,aAAT,EAAwB,CAACD,YAAzB,CAArB;;AAEA,UAAIG,cAAc,GAAG,CAArB,EAAwB;AACtBZ,QAAAA,SAAS,CAACY,cAAc,GAAGD,OAAlB,EAA2B,CAA3B,EAA8BxB,GAA9B,CAAT;AACA,YAAI2B,QAAQ,GAAGF,cAAc,GAAGH,YAAhC;;AAEA,YAAIK,QAAQ,GAAG,CAAf,EAAkB;AAChBR,UAAAA,WAAW,CAAC,CAACQ,QAAD,GAAYH,OAAb,EAAsB,CAAtB,CAAX;AACD;AACF,OAPD,MAOO;AACLL,QAAAA,WAAW,CAAC,CAACG,YAAD,GAAgBE,OAAjB,EAA0B,CAA1B,CAAX;AACD;AACF;AACF;;AAED,WAASX,SAAT,CAAmBR,KAAnB,EAA0BuB,KAA1B,EAAiCC,GAAjC,EAAsC;AACpC,QAAIxB,KAAK,KAAK,CAAd,EAAiB;AACfC,MAAAA,QAAQ,GAAG,IAAX;AACD;;AAED,SAAK,IAAIzC,CAAC,GAAG+D,KAAb,EAAoB/D,CAAC,GAAGgE,GAAxB,EAA6BhE,CAAC,EAA9B,EAAkC;AAChC,UAAI4C,IAAI,GAAG7C,IAAI,CAACC,CAAD,CAAf;AACA,UAAIwB,IAAI,GAAGoB,IAAI,CAACpB,IAAhB;AACAA,MAAAA,IAAI,CAACM,KAAD,CAAJ,IAAeU,KAAf;AACAI,MAAAA,IAAI,CAACvC,KAAL,CAAWyB,KAAX,KAAqBU,KAArB;AACD;AACF,GAhG0E,CAgGzE;;;AAGF,WAASc,WAAT,CAAqBd,KAArB,EAA4ByB,gBAA5B,EAA8C;AAC5C,QAAIC,IAAI,GAAG,EAAX;AACA,QAAIC,SAAS,GAAG,CAAhB;;AAEA,SAAK,IAAInE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmC,GAApB,EAAyBnC,CAAC,EAA1B,EAA8B;AAC5B,UAAIoE,YAAY,GAAGrE,IAAI,CAACC,CAAC,GAAG,CAAL,CAAJ,CAAYwB,IAA/B;AACA,UAAI6C,GAAG,GAAGvB,IAAI,CAACC,GAAL,CAAShD,IAAI,CAACC,CAAD,CAAJ,CAAQwB,IAAR,CAAaM,KAAb,IAAsBsC,YAAY,CAACtC,KAAD,CAAlC,GAA4CsC,YAAY,CAACrC,OAAD,CAAjE,EAA4E,CAA5E,CAAV;AACAmC,MAAAA,IAAI,CAAC5C,IAAL,CAAU+C,GAAV;AACAF,MAAAA,SAAS,IAAIE,GAAb;AACD;;AAED,QAAI,CAACF,SAAL,EAAgB;AACd;AACD;;AAED,QAAIG,cAAc,GAAGxB,IAAI,CAACe,GAAL,CAASf,IAAI,CAACyB,GAAL,CAAS/B,KAAT,IAAkB2B,SAA3B,EAAsCF,gBAAtC,CAArB;;AAEA,QAAIzB,KAAK,GAAG,CAAZ,EAAe;AACb,WAAK,IAAIxC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmC,GAAG,GAAG,CAA1B,EAA6BnC,CAAC,EAA9B,EAAkC;AAChC;AACA,YAAIwE,QAAQ,GAAGN,IAAI,CAAClE,CAAD,CAAJ,GAAUsE,cAAzB,CAFgC,CAES;;AAEzCtB,QAAAA,SAAS,CAACwB,QAAD,EAAW,CAAX,EAAcxE,CAAC,GAAG,CAAlB,CAAT;AACD;AACF,KAPD,MAOO;AACL;AACA,WAAK,IAAIA,CAAC,GAAGmC,GAAG,GAAG,CAAnB,EAAsBnC,CAAC,GAAG,CAA1B,EAA6BA,CAAC,EAA9B,EAAkC;AAChC;AACA,YAAIwE,QAAQ,GAAGN,IAAI,CAAClE,CAAC,GAAG,CAAL,CAAJ,GAAcsE,cAA7B;AACAtB,QAAAA,SAAS,CAAC,CAACwB,QAAF,EAAYxE,CAAZ,EAAemC,GAAf,CAAT;AACD;AACF;AACF;AACD;AACF;AACA;AACA;;;AAGE,WAASqB,kBAAT,CAA4BhB,KAA5B,EAAmC;AACjC,QAAIiC,GAAG,GAAGjC,KAAK,GAAG,CAAR,GAAY,CAAC,CAAb,GAAiB,CAA3B;AACAA,IAAAA,KAAK,GAAGM,IAAI,CAACyB,GAAL,CAAS/B,KAAT,CAAR;AACA,QAAIkC,gBAAgB,GAAG5B,IAAI,CAAC6B,IAAL,CAAUnC,KAAK,IAAIL,GAAG,GAAG,CAAV,CAAf,CAAvB;;AAEA,SAAK,IAAInC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmC,GAAG,GAAG,CAA1B,EAA6BnC,CAAC,EAA9B,EAAkC;AAChC,UAAIyE,GAAG,GAAG,CAAV,EAAa;AACX;AACAzB,QAAAA,SAAS,CAAC0B,gBAAD,EAAmB,CAAnB,EAAsB1E,CAAC,GAAG,CAA1B,CAAT;AACD,OAHD,MAGO;AACL;AACAgD,QAAAA,SAAS,CAAC,CAAC0B,gBAAF,EAAoBvC,GAAG,GAAGnC,CAAN,GAAU,CAA9B,EAAiCmC,GAAjC,CAAT;AACD;;AAEDK,MAAAA,KAAK,IAAIkC,gBAAT;;AAEA,UAAIlC,KAAK,IAAI,CAAb,EAAgB;AACd;AACD;AACF;AACF;;AAED,SAAOC,QAAP;AACD;AACD;AACA;AACA;;;AAGA,OAAO,SAASmC,cAAT,CAAwB7E,IAAxB,EAA8B8E,SAA9B,EAAyCC,UAAzC,EAAqD;AAC5D;AACA;AACA;AACA5C,YAJO,EAIO;AACZ,SAAOL,WAAW,CAAC9B,IAAD,EAAO,GAAP,EAAY,OAAZ,EAAqB8E,SAArB,EAAgCC,UAAhC,EAA4C5C,YAA5C,CAAlB;AACD;AACD;AACA;AACA;;AAEA,OAAO,SAAS6C,cAAT,CAAwBhF,IAAxB,EAA8BiF,QAA9B,EAAwCC,WAAxC,EAAqD;AAC5D/C,YADO,EACO;AACZ,SAAOL,WAAW,CAAC9B,IAAD,EAAO,GAAP,EAAY,QAAZ,EAAsBiF,QAAtB,EAAgCC,WAAhC,EAA6C/C,YAA7C,CAAlB;AACD;AACD,OAAO,SAASgD,WAAT,CAAqBC,SAArB,EAAgC;AACrC,MAAIC,eAAe,GAAG,EAAtB,CADqC,CACX;;AAE1BD,EAAAA,SAAS,CAAC/C,IAAV,CAAe,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAC7B,WAAOA,CAAC,CAACb,QAAF,GAAaY,CAAC,CAACZ,QAAtB;AACD,GAFD;AAGA,MAAIX,UAAU,GAAG,IAAInB,YAAJ,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,CAAjB;;AAEA,WAAS0F,MAAT,CAAgBC,EAAhB,EAAoB;AAClB,QAAI,CAACA,EAAE,CAAClF,MAAR,EAAgB;AACd;AACA,UAAImF,aAAa,GAAGD,EAAE,CAACE,WAAH,CAAe,UAAf,CAApB;;AAEA,UAAID,aAAa,CAACnF,MAAd,IAAwB,IAA5B,EAAkC;AAChCmF,QAAAA,aAAa,CAACnF,MAAd,GAAuB,KAAvB;AACD;AACF;;AAEDkF,IAAAA,EAAE,CAAClF,MAAH,GAAY,IAAZ;AACD;;AAED,OAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmF,SAAS,CAAClF,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;AACzC,QAAIyF,SAAS,GAAGN,SAAS,CAACnF,CAAD,CAAzB;AACA,QAAIU,aAAa,GAAG+E,SAAS,CAAC7D,WAA9B;AACA,QAAIpB,SAAS,GAAGiF,SAAS,CAACjF,SAA1B;AACA,QAAIF,SAAS,GAAGmF,SAAS,CAACnF,SAA1B;AACA,QAAID,KAAK,GAAGoF,SAAS,CAACpF,KAAtB;AACA,QAAIkB,SAAS,GAAGkE,SAAS,CAAClE,SAA1B;AACAT,IAAAA,UAAU,CAAC4E,IAAX,CAAgBD,SAAS,CAACjE,IAA1B,EAPyC,CAOR;;AAEjCV,IAAAA,UAAU,CAACK,KAAX,IAAoB,GAApB;AACAL,IAAAA,UAAU,CAACM,MAAX,IAAqB,GAArB;AACAN,IAAAA,UAAU,CAACG,CAAX,IAAgB,IAAhB;AACAH,IAAAA,UAAU,CAACI,CAAX,IAAgB,IAAhB;AACA,QAAIG,GAAG,GAAGoE,SAAS,CAACpE,GAApB;AACA,QAAIsE,UAAU,GAAG,KAAjB;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,eAAe,CAACnF,MAApC,EAA4C2F,CAAC,EAA7C,EAAiD;AAC/C,UAAIC,aAAa,GAAGT,eAAe,CAACQ,CAAD,CAAnC,CAD+C,CACP;;AAExC,UAAI,CAAC9E,UAAU,CAACgF,SAAX,CAAqBD,aAAa,CAACrE,IAAnC,CAAL,EAA+C;AAC7C;AACD;;AAED,UAAId,aAAa,IAAImF,aAAa,CAACjE,WAAnC,EAAgD;AAC9C;AACA+D,QAAAA,UAAU,GAAG,IAAb;AACA;AACD;;AAED,UAAI,CAACE,aAAa,CAACxE,GAAnB,EAAwB;AACtB;AACAwE,QAAAA,aAAa,CAACxE,GAAd,GAAoB,IAAIzB,oBAAJ,CAAyBiG,aAAa,CAACrF,SAAvC,EAAkDqF,aAAa,CAACvF,SAAhE,CAApB;AACD;;AAED,UAAI,CAACe,GAAL,EAAU;AACR;AACAA,QAAAA,GAAG,GAAG,IAAIzB,oBAAJ,CAAyBY,SAAzB,EAAoCF,SAApC,CAAN;AACD;;AAED,UAAIe,GAAG,CAACyE,SAAJ,CAAcD,aAAa,CAACxE,GAA5B,CAAJ,EAAsC;AACpCsE,QAAAA,UAAU,GAAG,IAAb;AACA;AACD;AACF,KA3CwC,CA2CvC;;;AAGF,QAAIA,UAAJ,EAAgB;AACdN,MAAAA,MAAM,CAAChF,KAAD,CAAN;AACAkB,MAAAA,SAAS,IAAI8D,MAAM,CAAC9D,SAAD,CAAnB;AACD,KAHD,MAGO;AACLlB,MAAAA,KAAK,CAAC0F,IAAN,CAAW,QAAX,EAAqBN,SAAS,CAACtF,WAAV,CAAsBC,MAA3C;AACAmB,MAAAA,SAAS,IAAIA,SAAS,CAACwE,IAAV,CAAe,QAAf,EAAyBN,SAAS,CAACtF,WAAV,CAAsB6F,gBAA/C,CAAb;AACAZ,MAAAA,eAAe,CAAC9D,IAAhB,CAAqBmE,SAArB;AACD;AACF;AACF","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { BoundingRect, OrientedBoundingRect } from '../util/graphic';\nexport function prepareLayoutList(input) {\n  var list = [];\n\n  for (var i = 0; i < input.length; i++) {\n    var rawItem = input[i];\n\n    if (rawItem.defaultAttr.ignore) {\n      continue;\n    }\n\n    var label = rawItem.label;\n    var transform = label.getComputedTransform(); // NOTE: Get bounding rect after getComputedTransform, or label may not been updated by the host el.\n\n    var localRect = label.getBoundingRect();\n    var isAxisAligned = !transform || transform[1] < 1e-5 && transform[2] < 1e-5;\n    var minMargin = label.style.margin || 0;\n    var globalRect = localRect.clone();\n    globalRect.applyTransform(transform);\n    globalRect.x -= minMargin / 2;\n    globalRect.y -= minMargin / 2;\n    globalRect.width += minMargin;\n    globalRect.height += minMargin;\n    var obb = isAxisAligned ? new OrientedBoundingRect(localRect, transform) : null;\n    list.push({\n      label: label,\n      labelLine: rawItem.labelLine,\n      rect: globalRect,\n      localRect: localRect,\n      obb: obb,\n      priority: rawItem.priority,\n      defaultAttr: rawItem.defaultAttr,\n      layoutOption: rawItem.computedLayoutOption,\n      axisAligned: isAxisAligned,\n      transform: transform\n    });\n  }\n\n  return list;\n}\n\nfunction shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {\n  var len = list.length;\n\n  if (len < 2) {\n    return;\n  }\n\n  list.sort(function (a, b) {\n    return a.rect[xyDim] - b.rect[xyDim];\n  });\n  var lastPos = 0;\n  var delta;\n  var adjusted = false;\n  var shifts = [];\n  var totalShifts = 0;\n\n  for (var i = 0; i < len; i++) {\n    var item = list[i];\n    var rect = item.rect;\n    delta = rect[xyDim] - lastPos;\n\n    if (delta < 0) {\n      // shiftForward(i, len, -delta);\n      rect[xyDim] -= delta;\n      item.label[xyDim] -= delta;\n      adjusted = true;\n    }\n\n    var shift = Math.max(-delta, 0);\n    shifts.push(shift);\n    totalShifts += shift;\n    lastPos = rect[xyDim] + rect[sizeDim];\n  }\n\n  if (totalShifts > 0 && balanceShift) {\n    // Shift back to make the distribution more equally.\n    shiftList(-totalShifts / len, 0, len);\n  } // TODO bleedMargin?\n\n\n  var first = list[0];\n  var last = list[len - 1];\n  var minGap;\n  var maxGap;\n  updateMinMaxGap(); // If ends exceed two bounds, squeeze at most 80%, then take the gap of two bounds.\n\n  minGap < 0 && squeezeGaps(-minGap, 0.8);\n  maxGap < 0 && squeezeGaps(maxGap, 0.8);\n  updateMinMaxGap();\n  takeBoundsGap(minGap, maxGap, 1);\n  takeBoundsGap(maxGap, minGap, -1); // Handle bailout when there is not enough space.\n\n  updateMinMaxGap();\n\n  if (minGap < 0) {\n    squeezeWhenBailout(-minGap);\n  }\n\n  if (maxGap < 0) {\n    squeezeWhenBailout(maxGap);\n  }\n\n  function updateMinMaxGap() {\n    minGap = first.rect[xyDim] - minBound;\n    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];\n  }\n\n  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {\n    if (gapThisBound < 0) {\n      // Move from other gap if can.\n      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);\n\n      if (moveFromMaxGap > 0) {\n        shiftList(moveFromMaxGap * moveDir, 0, len);\n        var remained = moveFromMaxGap + gapThisBound;\n\n        if (remained < 0) {\n          squeezeGaps(-remained * moveDir, 1);\n        }\n      } else {\n        squeezeGaps(-gapThisBound * moveDir, 1);\n      }\n    }\n  }\n\n  function shiftList(delta, start, end) {\n    if (delta !== 0) {\n      adjusted = true;\n    }\n\n    for (var i = start; i < end; i++) {\n      var item = list[i];\n      var rect = item.rect;\n      rect[xyDim] += delta;\n      item.label[xyDim] += delta;\n    }\n  } // Squeeze gaps if the labels exceed margin.\n\n\n  function squeezeGaps(delta, maxSqeezePercent) {\n    var gaps = [];\n    var totalGaps = 0;\n\n    for (var i = 1; i < len; i++) {\n      var prevItemRect = list[i - 1].rect;\n      var gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);\n      gaps.push(gap);\n      totalGaps += gap;\n    }\n\n    if (!totalGaps) {\n      return;\n    }\n\n    var squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent);\n\n    if (delta > 0) {\n      for (var i = 0; i < len - 1; i++) {\n        // Distribute the shift delta to all gaps.\n        var movement = gaps[i] * squeezePercent; // Forward\n\n        shiftList(movement, 0, i + 1);\n      }\n    } else {\n      // Backward\n      for (var i = len - 1; i > 0; i--) {\n        // Distribute the shift delta to all gaps.\n        var movement = gaps[i - 1] * squeezePercent;\n        shiftList(-movement, i, len);\n      }\n    }\n  }\n  /**\n   * Squeeze to allow overlap if there is no more space available.\n   * Let other overlapping strategy like hideOverlap do the job instead of keep exceeding the bounds.\n   */\n\n\n  function squeezeWhenBailout(delta) {\n    var dir = delta < 0 ? -1 : 1;\n    delta = Math.abs(delta);\n    var moveForEachLabel = Math.ceil(delta / (len - 1));\n\n    for (var i = 0; i < len - 1; i++) {\n      if (dir > 0) {\n        // Forward\n        shiftList(moveForEachLabel, 0, i + 1);\n      } else {\n        // Backward\n        shiftList(-moveForEachLabel, len - i - 1, len);\n      }\n\n      delta -= moveForEachLabel;\n\n      if (delta <= 0) {\n        return;\n      }\n    }\n  }\n\n  return adjusted;\n}\n/**\n * Adjust labels on x direction to avoid overlap.\n */\n\n\nexport function shiftLayoutOnX(list, leftBound, rightBound, // If average the shifts on all labels and add them to 0\n// TODO: Not sure if should enable it.\n// Pros: The angle of lines will distribute more equally\n// Cons: In some layout. It may not what user wanted. like in pie. the label of last sector is usually changed unexpectedly.\nbalanceShift) {\n  return shiftLayout(list, 'x', 'width', leftBound, rightBound, balanceShift);\n}\n/**\n * Adjust labels on y direction to avoid overlap.\n */\n\nexport function shiftLayoutOnY(list, topBound, bottomBound, // If average the shifts on all labels and add them to 0\nbalanceShift) {\n  return shiftLayout(list, 'y', 'height', topBound, bottomBound, balanceShift);\n}\nexport function hideOverlap(labelList) {\n  var displayedLabels = []; // TODO, render overflow visible first, put in the displayedLabels.\n\n  labelList.sort(function (a, b) {\n    return b.priority - a.priority;\n  });\n  var globalRect = new BoundingRect(0, 0, 0, 0);\n\n  function hideEl(el) {\n    if (!el.ignore) {\n      // Show on emphasis.\n      var emphasisState = el.ensureState('emphasis');\n\n      if (emphasisState.ignore == null) {\n        emphasisState.ignore = false;\n      }\n    }\n\n    el.ignore = true;\n  }\n\n  for (var i = 0; i < labelList.length; i++) {\n    var labelItem = labelList[i];\n    var isAxisAligned = labelItem.axisAligned;\n    var localRect = labelItem.localRect;\n    var transform = labelItem.transform;\n    var label = labelItem.label;\n    var labelLine = labelItem.labelLine;\n    globalRect.copy(labelItem.rect); // Add a threshold because layout may be aligned precisely.\n\n    globalRect.width -= 0.1;\n    globalRect.height -= 0.1;\n    globalRect.x += 0.05;\n    globalRect.y += 0.05;\n    var obb = labelItem.obb;\n    var overlapped = false;\n\n    for (var j = 0; j < displayedLabels.length; j++) {\n      var existsTextCfg = displayedLabels[j]; // Fast rejection.\n\n      if (!globalRect.intersect(existsTextCfg.rect)) {\n        continue;\n      }\n\n      if (isAxisAligned && existsTextCfg.axisAligned) {\n        // Is overlapped\n        overlapped = true;\n        break;\n      }\n\n      if (!existsTextCfg.obb) {\n        // If self is not axis aligned. But other is.\n        existsTextCfg.obb = new OrientedBoundingRect(existsTextCfg.localRect, existsTextCfg.transform);\n      }\n\n      if (!obb) {\n        // If self is axis aligned. But other is not.\n        obb = new OrientedBoundingRect(localRect, transform);\n      }\n\n      if (obb.intersect(existsTextCfg.obb)) {\n        overlapped = true;\n        break;\n      }\n    } // TODO Callback to determine if this overlap should be handled?\n\n\n    if (overlapped) {\n      hideEl(label);\n      labelLine && hideEl(labelLine);\n    } else {\n      label.attr('ignore', labelItem.defaultAttr.ignore);\n      labelLine && labelLine.attr('ignore', labelItem.defaultAttr.labelGuideIgnore);\n      displayedLabels.push(labelItem);\n    }\n  }\n}"]},"metadata":{},"sourceType":"module"}