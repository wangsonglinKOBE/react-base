{"ast":null,"code":"import PathProxy from '../core/PathProxy';\nimport { applyTransform as v2ApplyTransform } from '../core/vector';\nvar CMD = PathProxy.CMD;\nvar points = [[], [], []];\nvar mathSqrt = Math.sqrt;\nvar mathAtan2 = Math.atan2;\nexport default function transformPath(path, m) {\n  if (!m) {\n    return;\n  }\n\n  var data = path.data;\n  var len = path.len();\n  var cmd;\n  var nPoint;\n  var i;\n  var j;\n  var k;\n  var p;\n  var M = CMD.M;\n  var C = CMD.C;\n  var L = CMD.L;\n  var R = CMD.R;\n  var A = CMD.A;\n  var Q = CMD.Q;\n\n  for (i = 0, j = 0; i < len;) {\n    cmd = data[i++];\n    j = i;\n    nPoint = 0;\n\n    switch (cmd) {\n      case M:\n        nPoint = 1;\n        break;\n\n      case L:\n        nPoint = 1;\n        break;\n\n      case C:\n        nPoint = 3;\n        break;\n\n      case Q:\n        nPoint = 2;\n        break;\n\n      case A:\n        var x = m[4];\n        var y = m[5];\n        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n        var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n        data[i] *= sx;\n        data[i++] += x;\n        data[i] *= sy;\n        data[i++] += y;\n        data[i++] *= sx;\n        data[i++] *= sy;\n        data[i++] += angle;\n        data[i++] += angle;\n        i += 2;\n        j = i;\n        break;\n\n      case R:\n        p[0] = data[i++];\n        p[1] = data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1];\n        p[0] += data[i++];\n        p[1] += data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1];\n    }\n\n    for (k = 0; k < nPoint; k++) {\n      var p_1 = points[k];\n      p_1[0] = data[i++];\n      p_1[1] = data[i++];\n      v2ApplyTransform(p_1, p_1, m);\n      data[j++] = p_1[0];\n      data[j++] = p_1[1];\n    }\n  }\n\n  path.increaseVersion();\n}","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/zrender/lib/tool/transformPath.js"],"names":["PathProxy","applyTransform","v2ApplyTransform","CMD","points","mathSqrt","Math","sqrt","mathAtan2","atan2","transformPath","path","m","data","len","cmd","nPoint","i","j","k","p","M","C","L","R","A","Q","x","y","sx","sy","angle","p_1","increaseVersion"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,mBAAtB;AACA,SAASC,cAAc,IAAIC,gBAA3B,QAAmD,gBAAnD;AACA,IAAIC,GAAG,GAAGH,SAAS,CAACG,GAApB;AACA,IAAIC,MAAM,GAAG,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,CAAb;AACA,IAAIC,QAAQ,GAAGC,IAAI,CAACC,IAApB;AACA,IAAIC,SAAS,GAAGF,IAAI,CAACG,KAArB;AACA,eAAe,SAASC,aAAT,CAAuBC,IAAvB,EAA6BC,CAA7B,EAAgC;AAC3C,MAAI,CAACA,CAAL,EAAQ;AACJ;AACH;;AACD,MAAIC,IAAI,GAAGF,IAAI,CAACE,IAAhB;AACA,MAAIC,GAAG,GAAGH,IAAI,CAACG,GAAL,EAAV;AACA,MAAIC,GAAJ;AACA,MAAIC,MAAJ;AACA,MAAIC,CAAJ;AACA,MAAIC,CAAJ;AACA,MAAIC,CAAJ;AACA,MAAIC,CAAJ;AACA,MAAIC,CAAC,GAAGlB,GAAG,CAACkB,CAAZ;AACA,MAAIC,CAAC,GAAGnB,GAAG,CAACmB,CAAZ;AACA,MAAIC,CAAC,GAAGpB,GAAG,CAACoB,CAAZ;AACA,MAAIC,CAAC,GAAGrB,GAAG,CAACqB,CAAZ;AACA,MAAIC,CAAC,GAAGtB,GAAG,CAACsB,CAAZ;AACA,MAAIC,CAAC,GAAGvB,GAAG,CAACuB,CAAZ;;AACA,OAAKT,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAG,CAAhB,EAAmBD,CAAC,GAAGH,GAAvB,GAA6B;AACzBC,IAAAA,GAAG,GAAGF,IAAI,CAACI,CAAC,EAAF,CAAV;AACAC,IAAAA,CAAC,GAAGD,CAAJ;AACAD,IAAAA,MAAM,GAAG,CAAT;;AACA,YAAQD,GAAR;AACI,WAAKM,CAAL;AACIL,QAAAA,MAAM,GAAG,CAAT;AACA;;AACJ,WAAKO,CAAL;AACIP,QAAAA,MAAM,GAAG,CAAT;AACA;;AACJ,WAAKM,CAAL;AACIN,QAAAA,MAAM,GAAG,CAAT;AACA;;AACJ,WAAKU,CAAL;AACIV,QAAAA,MAAM,GAAG,CAAT;AACA;;AACJ,WAAKS,CAAL;AACI,YAAIE,CAAC,GAAGf,CAAC,CAAC,CAAD,CAAT;AACA,YAAIgB,CAAC,GAAGhB,CAAC,CAAC,CAAD,CAAT;AACA,YAAIiB,EAAE,GAAGxB,QAAQ,CAACO,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAR,GAAcA,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAvB,CAAjB;AACA,YAAIkB,EAAE,GAAGzB,QAAQ,CAACO,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAR,GAAcA,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAvB,CAAjB;AACA,YAAImB,KAAK,GAAGvB,SAAS,CAAC,CAACI,CAAC,CAAC,CAAD,CAAF,GAAQkB,EAAT,EAAalB,CAAC,CAAC,CAAD,CAAD,GAAOiB,EAApB,CAArB;AACAhB,QAAAA,IAAI,CAACI,CAAD,CAAJ,IAAWY,EAAX;AACAhB,QAAAA,IAAI,CAACI,CAAC,EAAF,CAAJ,IAAaU,CAAb;AACAd,QAAAA,IAAI,CAACI,CAAD,CAAJ,IAAWa,EAAX;AACAjB,QAAAA,IAAI,CAACI,CAAC,EAAF,CAAJ,IAAaW,CAAb;AACAf,QAAAA,IAAI,CAACI,CAAC,EAAF,CAAJ,IAAaY,EAAb;AACAhB,QAAAA,IAAI,CAACI,CAAC,EAAF,CAAJ,IAAaa,EAAb;AACAjB,QAAAA,IAAI,CAACI,CAAC,EAAF,CAAJ,IAAac,KAAb;AACAlB,QAAAA,IAAI,CAACI,CAAC,EAAF,CAAJ,IAAac,KAAb;AACAd,QAAAA,CAAC,IAAI,CAAL;AACAC,QAAAA,CAAC,GAAGD,CAAJ;AACA;;AACJ,WAAKO,CAAL;AACIJ,QAAAA,CAAC,CAAC,CAAD,CAAD,GAAOP,IAAI,CAACI,CAAC,EAAF,CAAX;AACAG,QAAAA,CAAC,CAAC,CAAD,CAAD,GAAOP,IAAI,CAACI,CAAC,EAAF,CAAX;AACAf,QAAAA,gBAAgB,CAACkB,CAAD,EAAIA,CAAJ,EAAOR,CAAP,CAAhB;AACAC,QAAAA,IAAI,CAACK,CAAC,EAAF,CAAJ,GAAYE,CAAC,CAAC,CAAD,CAAb;AACAP,QAAAA,IAAI,CAACK,CAAC,EAAF,CAAJ,GAAYE,CAAC,CAAC,CAAD,CAAb;AACAA,QAAAA,CAAC,CAAC,CAAD,CAAD,IAAQP,IAAI,CAACI,CAAC,EAAF,CAAZ;AACAG,QAAAA,CAAC,CAAC,CAAD,CAAD,IAAQP,IAAI,CAACI,CAAC,EAAF,CAAZ;AACAf,QAAAA,gBAAgB,CAACkB,CAAD,EAAIA,CAAJ,EAAOR,CAAP,CAAhB;AACAC,QAAAA,IAAI,CAACK,CAAC,EAAF,CAAJ,GAAYE,CAAC,CAAC,CAAD,CAAb;AACAP,QAAAA,IAAI,CAACK,CAAC,EAAF,CAAJ,GAAYE,CAAC,CAAC,CAAD,CAAb;AAxCR;;AA0CA,SAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGH,MAAhB,EAAwBG,CAAC,EAAzB,EAA6B;AACzB,UAAIa,GAAG,GAAG5B,MAAM,CAACe,CAAD,CAAhB;AACAa,MAAAA,GAAG,CAAC,CAAD,CAAH,GAASnB,IAAI,CAACI,CAAC,EAAF,CAAb;AACAe,MAAAA,GAAG,CAAC,CAAD,CAAH,GAASnB,IAAI,CAACI,CAAC,EAAF,CAAb;AACAf,MAAAA,gBAAgB,CAAC8B,GAAD,EAAMA,GAAN,EAAWpB,CAAX,CAAhB;AACAC,MAAAA,IAAI,CAACK,CAAC,EAAF,CAAJ,GAAYc,GAAG,CAAC,CAAD,CAAf;AACAnB,MAAAA,IAAI,CAACK,CAAC,EAAF,CAAJ,GAAYc,GAAG,CAAC,CAAD,CAAf;AACH;AACJ;;AACDrB,EAAAA,IAAI,CAACsB,eAAL;AACH","sourcesContent":["import PathProxy from '../core/PathProxy';\nimport { applyTransform as v2ApplyTransform } from '../core/vector';\nvar CMD = PathProxy.CMD;\nvar points = [[], [], []];\nvar mathSqrt = Math.sqrt;\nvar mathAtan2 = Math.atan2;\nexport default function transformPath(path, m) {\n    if (!m) {\n        return;\n    }\n    var data = path.data;\n    var len = path.len();\n    var cmd;\n    var nPoint;\n    var i;\n    var j;\n    var k;\n    var p;\n    var M = CMD.M;\n    var C = CMD.C;\n    var L = CMD.L;\n    var R = CMD.R;\n    var A = CMD.A;\n    var Q = CMD.Q;\n    for (i = 0, j = 0; i < len;) {\n        cmd = data[i++];\n        j = i;\n        nPoint = 0;\n        switch (cmd) {\n            case M:\n                nPoint = 1;\n                break;\n            case L:\n                nPoint = 1;\n                break;\n            case C:\n                nPoint = 3;\n                break;\n            case Q:\n                nPoint = 2;\n                break;\n            case A:\n                var x = m[4];\n                var y = m[5];\n                var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n                var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n                var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                data[i] *= sx;\n                data[i++] += x;\n                data[i] *= sy;\n                data[i++] += y;\n                data[i++] *= sx;\n                data[i++] *= sy;\n                data[i++] += angle;\n                data[i++] += angle;\n                i += 2;\n                j = i;\n                break;\n            case R:\n                p[0] = data[i++];\n                p[1] = data[i++];\n                v2ApplyTransform(p, p, m);\n                data[j++] = p[0];\n                data[j++] = p[1];\n                p[0] += data[i++];\n                p[1] += data[i++];\n                v2ApplyTransform(p, p, m);\n                data[j++] = p[0];\n                data[j++] = p[1];\n        }\n        for (k = 0; k < nPoint; k++) {\n            var p_1 = points[k];\n            p_1[0] = data[i++];\n            p_1[1] = data[i++];\n            v2ApplyTransform(p_1, p_1, m);\n            data[j++] = p_1[0];\n            data[j++] = p_1[1];\n        }\n    }\n    path.increaseVersion();\n}\n"]},"metadata":{},"sourceType":"module"}