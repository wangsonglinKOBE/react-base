{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { parseConditionalExpression } from '../../util/conditionalExpression';\nimport { hasOwn, createHashMap } from 'zrender/lib/core/util';\nimport { makePrintable, throwError } from '../../util/log';\nexport var filterTransform = {\n  type: 'echarts:filter',\n  // PEDING: enhance to filter by index rather than create new data\n  transform: function (params) {\n    // [Caveat] Fail-Fast:\n    // Do not return the whole dataset unless user config indicate it explicitly.\n    // For example, if no condition specified by mistake, return an empty result\n    // is better than return the entire raw soruce for user to find the mistake.\n    var upstream = params.upstream;\n    var rawItem;\n    var condition = parseConditionalExpression(params.config, {\n      valueGetterAttrMap: createHashMap({\n        dimension: true\n      }),\n      prepareGetValue: function (exprOption) {\n        var errMsg = '';\n        var dimLoose = exprOption.dimension;\n\n        if (!hasOwn(exprOption, 'dimension')) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg = makePrintable('Relation condition must has prop \"dimension\" specified.', 'Illegal condition:', exprOption);\n          }\n\n          throwError(errMsg);\n        }\n\n        var dimInfo = upstream.getDimensionInfo(dimLoose);\n\n        if (!dimInfo) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg = makePrintable('Can not find dimension info via: ' + dimLoose + '.\\n', 'Existing dimensions: ', upstream.cloneAllDimensionInfo(), '.\\n', 'Illegal condition:', exprOption, '.\\n');\n          }\n\n          throwError(errMsg);\n        }\n\n        return {\n          dimIdx: dimInfo.index\n        };\n      },\n      getValue: function (param) {\n        return upstream.retrieveValueFromItem(rawItem, param.dimIdx);\n      }\n    });\n    var resultData = [];\n\n    for (var i = 0, len = upstream.count(); i < len; i++) {\n      rawItem = upstream.getRawDataItem(i);\n\n      if (condition.evaluate()) {\n        resultData.push(rawItem);\n      }\n    }\n\n    return {\n      data: resultData\n    };\n  }\n};","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/component/transform/filterTransform.js"],"names":["parseConditionalExpression","hasOwn","createHashMap","makePrintable","throwError","filterTransform","type","transform","params","upstream","rawItem","condition","config","valueGetterAttrMap","dimension","prepareGetValue","exprOption","errMsg","dimLoose","process","env","NODE_ENV","dimInfo","getDimensionInfo","cloneAllDimensionInfo","dimIdx","index","getValue","param","retrieveValueFromItem","resultData","i","len","count","getRawDataItem","evaluate","push","data"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,0BAAT,QAA2C,kCAA3C;AACA,SAASC,MAAT,EAAiBC,aAAjB,QAAsC,uBAAtC;AACA,SAASC,aAAT,EAAwBC,UAAxB,QAA0C,gBAA1C;AACA,OAAO,IAAIC,eAAe,GAAG;AAC3BC,EAAAA,IAAI,EAAE,gBADqB;AAE3B;AACAC,EAAAA,SAAS,EAAE,UAAUC,MAAV,EAAkB;AAC3B;AACA;AACA;AACA;AACA,QAAIC,QAAQ,GAAGD,MAAM,CAACC,QAAtB;AACA,QAAIC,OAAJ;AACA,QAAIC,SAAS,GAAGX,0BAA0B,CAACQ,MAAM,CAACI,MAAR,EAAgB;AACxDC,MAAAA,kBAAkB,EAAEX,aAAa,CAAC;AAChCY,QAAAA,SAAS,EAAE;AADqB,OAAD,CADuB;AAIxDC,MAAAA,eAAe,EAAE,UAAUC,UAAV,EAAsB;AACrC,YAAIC,MAAM,GAAG,EAAb;AACA,YAAIC,QAAQ,GAAGF,UAAU,CAACF,SAA1B;;AAEA,YAAI,CAACb,MAAM,CAACe,UAAD,EAAa,WAAb,CAAX,EAAsC;AACpC,cAAIG,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCJ,YAAAA,MAAM,GAAGd,aAAa,CAAC,yDAAD,EAA4D,oBAA5D,EAAkFa,UAAlF,CAAtB;AACD;;AAEDZ,UAAAA,UAAU,CAACa,MAAD,CAAV;AACD;;AAED,YAAIK,OAAO,GAAGb,QAAQ,CAACc,gBAAT,CAA0BL,QAA1B,CAAd;;AAEA,YAAI,CAACI,OAAL,EAAc;AACZ,cAAIH,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCJ,YAAAA,MAAM,GAAGd,aAAa,CAAC,sCAAsCe,QAAtC,GAAiD,KAAlD,EAAyD,uBAAzD,EAAkFT,QAAQ,CAACe,qBAAT,EAAlF,EAAoH,KAApH,EAA2H,oBAA3H,EAAiJR,UAAjJ,EAA6J,KAA7J,CAAtB;AACD;;AAEDZ,UAAAA,UAAU,CAACa,MAAD,CAAV;AACD;;AAED,eAAO;AACLQ,UAAAA,MAAM,EAAEH,OAAO,CAACI;AADX,SAAP;AAGD,OA7BuD;AA8BxDC,MAAAA,QAAQ,EAAE,UAAUC,KAAV,EAAiB;AACzB,eAAOnB,QAAQ,CAACoB,qBAAT,CAA+BnB,OAA/B,EAAwCkB,KAAK,CAACH,MAA9C,CAAP;AACD;AAhCuD,KAAhB,CAA1C;AAkCA,QAAIK,UAAU,GAAG,EAAjB;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGvB,QAAQ,CAACwB,KAAT,EAAtB,EAAwCF,CAAC,GAAGC,GAA5C,EAAiDD,CAAC,EAAlD,EAAsD;AACpDrB,MAAAA,OAAO,GAAGD,QAAQ,CAACyB,cAAT,CAAwBH,CAAxB,CAAV;;AAEA,UAAIpB,SAAS,CAACwB,QAAV,EAAJ,EAA0B;AACxBL,QAAAA,UAAU,CAACM,IAAX,CAAgB1B,OAAhB;AACD;AACF;;AAED,WAAO;AACL2B,MAAAA,IAAI,EAAEP;AADD,KAAP;AAGD;AAzD0B,CAAtB","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { parseConditionalExpression } from '../../util/conditionalExpression';\nimport { hasOwn, createHashMap } from 'zrender/lib/core/util';\nimport { makePrintable, throwError } from '../../util/log';\nexport var filterTransform = {\n  type: 'echarts:filter',\n  // PEDING: enhance to filter by index rather than create new data\n  transform: function (params) {\n    // [Caveat] Fail-Fast:\n    // Do not return the whole dataset unless user config indicate it explicitly.\n    // For example, if no condition specified by mistake, return an empty result\n    // is better than return the entire raw soruce for user to find the mistake.\n    var upstream = params.upstream;\n    var rawItem;\n    var condition = parseConditionalExpression(params.config, {\n      valueGetterAttrMap: createHashMap({\n        dimension: true\n      }),\n      prepareGetValue: function (exprOption) {\n        var errMsg = '';\n        var dimLoose = exprOption.dimension;\n\n        if (!hasOwn(exprOption, 'dimension')) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg = makePrintable('Relation condition must has prop \"dimension\" specified.', 'Illegal condition:', exprOption);\n          }\n\n          throwError(errMsg);\n        }\n\n        var dimInfo = upstream.getDimensionInfo(dimLoose);\n\n        if (!dimInfo) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg = makePrintable('Can not find dimension info via: ' + dimLoose + '.\\n', 'Existing dimensions: ', upstream.cloneAllDimensionInfo(), '.\\n', 'Illegal condition:', exprOption, '.\\n');\n          }\n\n          throwError(errMsg);\n        }\n\n        return {\n          dimIdx: dimInfo.index\n        };\n      },\n      getValue: function (param) {\n        return upstream.retrieveValueFromItem(rawItem, param.dimIdx);\n      }\n    });\n    var resultData = [];\n\n    for (var i = 0, len = upstream.count(); i < len; i++) {\n      rawItem = upstream.getRawDataItem(i);\n\n      if (condition.evaluate()) {\n        resultData.push(rawItem);\n      }\n    }\n\n    return {\n      data: resultData\n    };\n  }\n};"]},"metadata":{},"sourceType":"module"}