{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util';\nimport * as graphic from '../../util/graphic';\nimport * as textContain from 'zrender/lib/contain/text';\nimport * as formatUtil from '../../util/format';\nimport * as matrix from 'zrender/lib/core/matrix';\nimport * as axisHelper from '../../coord/axisHelper';\nimport AxisBuilder from '../axis/AxisBuilder';\nimport { createTextStyle } from '../../label/labelStyle';\nexport function buildElStyle(axisPointerModel) {\n  var axisPointerType = axisPointerModel.get('type');\n  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n  var style;\n\n  if (axisPointerType === 'line') {\n    style = styleModel.getLineStyle();\n    style.fill = null;\n  } else if (axisPointerType === 'shadow') {\n    style = styleModel.getAreaStyle();\n    style.stroke = null;\n  }\n\n  return style;\n}\n/**\n * @param {Function} labelPos {align, verticalAlign, position}\n */\n\nexport function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {\n  var value = axisPointerModel.get('value');\n  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {\n    precision: axisPointerModel.get(['label', 'precision']),\n    formatter: axisPointerModel.get(['label', 'formatter'])\n  });\n  var labelModel = axisPointerModel.getModel('label');\n  var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n  var font = labelModel.getFont();\n  var textRect = textContain.getBoundingRect(text, font);\n  var position = labelPos.position;\n  var width = textRect.width + paddings[1] + paddings[3];\n  var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.\n\n  var align = labelPos.align;\n  align === 'right' && (position[0] -= width);\n  align === 'center' && (position[0] -= width / 2);\n  var verticalAlign = labelPos.verticalAlign;\n  verticalAlign === 'bottom' && (position[1] -= height);\n  verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container\n\n  confineInContainer(position, width, height, api);\n  var bgColor = labelModel.get('backgroundColor');\n\n  if (!bgColor || bgColor === 'auto') {\n    bgColor = axisModel.get(['axisLine', 'lineStyle', 'color']);\n  }\n\n  elOption.label = {\n    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},\n    x: position[0],\n    y: position[1],\n    style: createTextStyle(labelModel, {\n      text: text,\n      font: font,\n      fill: labelModel.getTextColor(),\n      padding: paddings,\n      backgroundColor: bgColor\n    }),\n    // Lable should be over axisPointer.\n    z2: 10\n  };\n} // Do not overflow ec container\n\nfunction confineInContainer(position, width, height, api) {\n  var viewWidth = api.getWidth();\n  var viewHeight = api.getHeight();\n  position[0] = Math.min(position[0] + width, viewWidth) - width;\n  position[1] = Math.min(position[1] + height, viewHeight) - height;\n  position[0] = Math.max(position[0], 0);\n  position[1] = Math.max(position[1], 0);\n}\n\nexport function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {\n  value = axis.scale.parse(value);\n  var text = axis.scale.getLabel({\n    value: value\n  }, {\n    // If `precision` is set, width can be fixed (like '12.00500'), which\n    // helps to debounce when when moving label.\n    precision: opt.precision\n  });\n  var formatter = opt.formatter;\n\n  if (formatter) {\n    var params_1 = {\n      value: axisHelper.getAxisRawValue(axis, {\n        value: value\n      }),\n      axisDimension: axis.dim,\n      axisIndex: axis.index,\n      seriesData: []\n    };\n    zrUtil.each(seriesDataIndices, function (idxItem) {\n      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n      var dataIndex = idxItem.dataIndexInside;\n      var dataParams = series && series.getDataParams(dataIndex);\n      dataParams && params_1.seriesData.push(dataParams);\n    });\n\n    if (zrUtil.isString(formatter)) {\n      text = formatter.replace('{value}', text);\n    } else if (zrUtil.isFunction(formatter)) {\n      text = formatter(params_1);\n    }\n  }\n\n  return text;\n}\nexport function getTransformedPosition(axis, value, layoutInfo) {\n  var transform = matrix.create();\n  matrix.rotate(transform, transform, layoutInfo.rotation);\n  matrix.translate(transform, transform, layoutInfo.position);\n  return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);\n}\nexport function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {\n  // @ts-ignore\n  var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);\n  layoutInfo.labelMargin = axisPointerModel.get(['label', 'margin']);\n  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n    position: getTransformedPosition(axisModel.axis, value, layoutInfo),\n    align: textLayout.textAlign,\n    verticalAlign: textLayout.textVerticalAlign\n  });\n}\nexport function makeLineShape(p1, p2, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x1: p1[xDimIndex],\n    y1: p1[1 - xDimIndex],\n    x2: p2[xDimIndex],\n    y2: p2[1 - xDimIndex]\n  };\n}\nexport function makeRectShape(xy, wh, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x: xy[xDimIndex],\n    y: xy[1 - xDimIndex],\n    width: wh[xDimIndex],\n    height: wh[1 - xDimIndex]\n  };\n}\nexport function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n  return {\n    cx: cx,\n    cy: cy,\n    r0: r0,\n    r: r,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    clockwise: true\n  };\n}","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/component/axisPointer/viewHelper.js"],"names":["zrUtil","graphic","textContain","formatUtil","matrix","axisHelper","AxisBuilder","createTextStyle","buildElStyle","axisPointerModel","axisPointerType","get","styleModel","getModel","style","getLineStyle","fill","getAreaStyle","stroke","buildLabelElOption","elOption","axisModel","api","labelPos","value","text","getValueLabel","axis","ecModel","precision","formatter","labelModel","paddings","normalizeCssArray","font","getFont","textRect","getBoundingRect","position","width","height","align","verticalAlign","confineInContainer","bgColor","label","x","y","getTextColor","padding","backgroundColor","z2","viewWidth","getWidth","viewHeight","getHeight","Math","min","max","seriesDataIndices","opt","scale","parse","getLabel","params_1","getAxisRawValue","axisDimension","dim","axisIndex","index","seriesData","each","idxItem","series","getSeriesByIndex","seriesIndex","dataIndex","dataIndexInside","dataParams","getDataParams","push","isString","replace","isFunction","getTransformedPosition","layoutInfo","transform","create","rotate","rotation","translate","applyTransform","dataToCoord","labelOffset","labelDirection","labelMargin","buildCartesianSingleLabelElOption","textLayout","innerTextLayout","textAlign","textVerticalAlign","makeLineShape","p1","p2","xDimIndex","x1","y1","x2","y2","makeRectShape","xy","wh","makeSectorShape","cx","cy","r0","r","startAngle","endAngle","clockwise"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util';\nimport * as graphic from '../../util/graphic';\nimport * as textContain from 'zrender/lib/contain/text';\nimport * as formatUtil from '../../util/format';\nimport * as matrix from 'zrender/lib/core/matrix';\nimport * as axisHelper from '../../coord/axisHelper';\nimport AxisBuilder from '../axis/AxisBuilder';\nimport { createTextStyle } from '../../label/labelStyle';\nexport function buildElStyle(axisPointerModel) {\n  var axisPointerType = axisPointerModel.get('type');\n  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n  var style;\n\n  if (axisPointerType === 'line') {\n    style = styleModel.getLineStyle();\n    style.fill = null;\n  } else if (axisPointerType === 'shadow') {\n    style = styleModel.getAreaStyle();\n    style.stroke = null;\n  }\n\n  return style;\n}\n/**\n * @param {Function} labelPos {align, verticalAlign, position}\n */\n\nexport function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {\n  var value = axisPointerModel.get('value');\n  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {\n    precision: axisPointerModel.get(['label', 'precision']),\n    formatter: axisPointerModel.get(['label', 'formatter'])\n  });\n  var labelModel = axisPointerModel.getModel('label');\n  var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);\n  var font = labelModel.getFont();\n  var textRect = textContain.getBoundingRect(text, font);\n  var position = labelPos.position;\n  var width = textRect.width + paddings[1] + paddings[3];\n  var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align.\n\n  var align = labelPos.align;\n  align === 'right' && (position[0] -= width);\n  align === 'center' && (position[0] -= width / 2);\n  var verticalAlign = labelPos.verticalAlign;\n  verticalAlign === 'bottom' && (position[1] -= height);\n  verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container\n\n  confineInContainer(position, width, height, api);\n  var bgColor = labelModel.get('backgroundColor');\n\n  if (!bgColor || bgColor === 'auto') {\n    bgColor = axisModel.get(['axisLine', 'lineStyle', 'color']);\n  }\n\n  elOption.label = {\n    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},\n    x: position[0],\n    y: position[1],\n    style: createTextStyle(labelModel, {\n      text: text,\n      font: font,\n      fill: labelModel.getTextColor(),\n      padding: paddings,\n      backgroundColor: bgColor\n    }),\n    // Lable should be over axisPointer.\n    z2: 10\n  };\n} // Do not overflow ec container\n\nfunction confineInContainer(position, width, height, api) {\n  var viewWidth = api.getWidth();\n  var viewHeight = api.getHeight();\n  position[0] = Math.min(position[0] + width, viewWidth) - width;\n  position[1] = Math.min(position[1] + height, viewHeight) - height;\n  position[0] = Math.max(position[0], 0);\n  position[1] = Math.max(position[1], 0);\n}\n\nexport function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {\n  value = axis.scale.parse(value);\n  var text = axis.scale.getLabel({\n    value: value\n  }, {\n    // If `precision` is set, width can be fixed (like '12.00500'), which\n    // helps to debounce when when moving label.\n    precision: opt.precision\n  });\n  var formatter = opt.formatter;\n\n  if (formatter) {\n    var params_1 = {\n      value: axisHelper.getAxisRawValue(axis, {\n        value: value\n      }),\n      axisDimension: axis.dim,\n      axisIndex: axis.index,\n      seriesData: []\n    };\n    zrUtil.each(seriesDataIndices, function (idxItem) {\n      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n      var dataIndex = idxItem.dataIndexInside;\n      var dataParams = series && series.getDataParams(dataIndex);\n      dataParams && params_1.seriesData.push(dataParams);\n    });\n\n    if (zrUtil.isString(formatter)) {\n      text = formatter.replace('{value}', text);\n    } else if (zrUtil.isFunction(formatter)) {\n      text = formatter(params_1);\n    }\n  }\n\n  return text;\n}\nexport function getTransformedPosition(axis, value, layoutInfo) {\n  var transform = matrix.create();\n  matrix.rotate(transform, transform, layoutInfo.rotation);\n  matrix.translate(transform, transform, layoutInfo.position);\n  return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);\n}\nexport function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {\n  // @ts-ignore\n  var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);\n  layoutInfo.labelMargin = axisPointerModel.get(['label', 'margin']);\n  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n    position: getTransformedPosition(axisModel.axis, value, layoutInfo),\n    align: textLayout.textAlign,\n    verticalAlign: textLayout.textVerticalAlign\n  });\n}\nexport function makeLineShape(p1, p2, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x1: p1[xDimIndex],\n    y1: p1[1 - xDimIndex],\n    x2: p2[xDimIndex],\n    y2: p2[1 - xDimIndex]\n  };\n}\nexport function makeRectShape(xy, wh, xDimIndex) {\n  xDimIndex = xDimIndex || 0;\n  return {\n    x: xy[xDimIndex],\n    y: xy[1 - xDimIndex],\n    width: wh[xDimIndex],\n    height: wh[1 - xDimIndex]\n  };\n}\nexport function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n  return {\n    cx: cx,\n    cy: cy,\n    r0: r0,\n    r: r,\n    startAngle: startAngle,\n    endAngle: endAngle,\n    clockwise: true\n  };\n}"]},"metadata":{},"sourceType":"module"}