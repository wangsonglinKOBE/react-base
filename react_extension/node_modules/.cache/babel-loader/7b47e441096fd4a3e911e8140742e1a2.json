{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { separateMorph, combineMorph, morphPath, isCombineMorphing } from 'zrender/lib/tool/morphPath';\nimport { Path } from '../util/graphic';\nimport { defaults, isArray } from 'zrender/lib/core/util';\nimport { getAnimationConfig } from './basicTrasition';\nimport { clonePath } from 'zrender/lib/tool/path';\n\nfunction isMultiple(elements) {\n  return isArray(elements[0]);\n}\n\nfunction prepareMorphBatches(one, many) {\n  var batches = [];\n  var batchCount = one.length;\n\n  for (var i = 0; i < batchCount; i++) {\n    batches.push({\n      one: one[i],\n      many: []\n    });\n  }\n\n  for (var i = 0; i < many.length; i++) {\n    var len = many[i].length;\n    var k = void 0;\n\n    for (k = 0; k < len; k++) {\n      batches[k % batchCount].many.push(many[i][k]);\n    }\n  }\n\n  var off = 0; // If one has more paths than each one of many. average them.\n\n  for (var i = batchCount - 1; i >= 0; i--) {\n    if (!batches[i].many.length) {\n      var moveFrom = batches[off].many;\n\n      if (moveFrom.length <= 1) {\n        // Not enough\n        // Start from the first one.\n        if (off) {\n          off = 0;\n        } else {\n          return batches;\n        }\n      }\n\n      var len = moveFrom.length;\n      var mid = Math.ceil(len / 2);\n      batches[i].many = moveFrom.slice(mid, len);\n      batches[off].many = moveFrom.slice(0, mid);\n      off++;\n    }\n  }\n\n  return batches;\n}\n\nvar pathDividers = {\n  clone: function (params) {\n    var ret = []; // Fitting the alpha\n\n    var approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);\n\n    for (var i = 0; i < params.count; i++) {\n      var cloned = clonePath(params.path);\n      cloned.setStyle('opacity', approxOpacity);\n      ret.push(cloned);\n    }\n\n    return ret;\n  },\n  // Use the default divider\n  split: null\n};\nexport function applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {\n  if (!from.length || !to.length) {\n    return;\n  }\n\n  var updateAnimationCfg = getAnimationConfig('update', seriesModel, dataIndex);\n\n  if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {\n    return;\n  }\n\n  var animationDelay = seriesModel.getModel('universalTransition').get('delay');\n  var animationCfg = Object.assign({\n    // Need to setToFinal so the further calculation based on the style can be correct.\n    // Like emphasis color.\n    setToFinal: true\n  }, updateAnimationCfg);\n  var many;\n  var one;\n\n  if (isMultiple(from)) {\n    // manyToOne\n    many = from;\n    one = to;\n  }\n\n  if (isMultiple(to)) {\n    // oneToMany\n    many = to;\n    one = from;\n  }\n\n  function morphOneBatch(batch, fromIsMany, animateIndex, animateCount, forceManyOne) {\n    var batchMany = batch.many;\n    var batchOne = batch.one;\n\n    if (batchMany.length === 1 && !forceManyOne) {\n      // Is one to one\n      var batchFrom = fromIsMany ? batchMany[0] : batchOne;\n      var batchTo = fromIsMany ? batchOne : batchMany[0];\n\n      if (isCombineMorphing(batchFrom)) {\n        // Keep doing combine animation.\n        morphOneBatch({\n          many: [batchFrom],\n          one: batchTo\n        }, true, animateIndex, animateCount, true);\n      } else {\n        var individualAnimationCfg = animationDelay ? defaults({\n          delay: animationDelay(animateIndex, animateCount)\n        }, animationCfg) : animationCfg;\n        morphPath(batchFrom, batchTo, individualAnimationCfg);\n        animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);\n      }\n    } else {\n      var separateAnimationCfg = defaults({\n        dividePath: pathDividers[divideShape],\n        individualDelay: animationDelay && function (idx, count, fromPath, toPath) {\n          return animationDelay(idx + animateIndex, animateCount);\n        }\n      }, animationCfg);\n\n      var _a = fromIsMany ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg),\n          fromIndividuals = _a.fromIndividuals,\n          toIndividuals = _a.toIndividuals;\n\n      var count = fromIndividuals.length;\n\n      for (var k = 0; k < count; k++) {\n        var individualAnimationCfg = animationDelay ? defaults({\n          delay: animationDelay(k, count)\n        }, animationCfg) : animationCfg;\n        animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany ? batchMany[k] : batch.one, fromIsMany ? batch.one : batchMany[k], individualAnimationCfg);\n      }\n    }\n  }\n\n  var fromIsMany = many ? many === from // Is one to one. If the path number not match. also needs do merge and separate morphing.\n  : from.length > to.length;\n  var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);\n  var animateCount = 0;\n\n  for (var i = 0; i < morphBatches.length; i++) {\n    animateCount += morphBatches[i].many.length;\n  }\n\n  var animateIndex = 0;\n\n  for (var i = 0; i < morphBatches.length; i++) {\n    morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount);\n    animateIndex += morphBatches[i].many.length;\n  }\n}\nexport function getPathList(elements) {\n  if (!elements) {\n    return [];\n  }\n\n  if (isArray(elements)) {\n    var pathList_1 = [];\n\n    for (var i = 0; i < elements.length; i++) {\n      pathList_1.push(getPathList(elements[i]));\n    }\n\n    return pathList_1;\n  }\n\n  var pathList = [];\n  elements.traverse(function (el) {\n    if (el instanceof Path && !el.disableMorphing && !el.invisible && !el.ignore) {\n      pathList.push(el);\n    }\n  });\n  return pathList;\n}","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/animation/morphTransitionHelper.js"],"names":["separateMorph","combineMorph","morphPath","isCombineMorphing","Path","defaults","isArray","getAnimationConfig","clonePath","isMultiple","elements","prepareMorphBatches","one","many","batches","batchCount","length","i","push","len","k","off","moveFrom","mid","Math","ceil","slice","pathDividers","clone","params","ret","approxOpacity","pow","path","style","opacity","count","cloned","setStyle","split","applyMorphAnimation","from","to","divideShape","seriesModel","dataIndex","animateOtherProps","updateAnimationCfg","duration","animationDelay","getModel","get","animationCfg","Object","assign","setToFinal","morphOneBatch","batch","fromIsMany","animateIndex","animateCount","forceManyOne","batchMany","batchOne","batchFrom","batchTo","individualAnimationCfg","delay","separateAnimationCfg","dividePath","individualDelay","idx","fromPath","toPath","_a","fromIndividuals","toIndividuals","morphBatches","getPathList","pathList_1","pathList","traverse","el","disableMorphing","invisible","ignore"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { separateMorph, combineMorph, morphPath, isCombineMorphing } from 'zrender/lib/tool/morphPath';\nimport { Path } from '../util/graphic';\nimport { defaults, isArray } from 'zrender/lib/core/util';\nimport { getAnimationConfig } from './basicTrasition';\nimport { clonePath } from 'zrender/lib/tool/path';\n\nfunction isMultiple(elements) {\n  return isArray(elements[0]);\n}\n\nfunction prepareMorphBatches(one, many) {\n  var batches = [];\n  var batchCount = one.length;\n\n  for (var i = 0; i < batchCount; i++) {\n    batches.push({\n      one: one[i],\n      many: []\n    });\n  }\n\n  for (var i = 0; i < many.length; i++) {\n    var len = many[i].length;\n    var k = void 0;\n\n    for (k = 0; k < len; k++) {\n      batches[k % batchCount].many.push(many[i][k]);\n    }\n  }\n\n  var off = 0; // If one has more paths than each one of many. average them.\n\n  for (var i = batchCount - 1; i >= 0; i--) {\n    if (!batches[i].many.length) {\n      var moveFrom = batches[off].many;\n\n      if (moveFrom.length <= 1) {\n        // Not enough\n        // Start from the first one.\n        if (off) {\n          off = 0;\n        } else {\n          return batches;\n        }\n      }\n\n      var len = moveFrom.length;\n      var mid = Math.ceil(len / 2);\n      batches[i].many = moveFrom.slice(mid, len);\n      batches[off].many = moveFrom.slice(0, mid);\n      off++;\n    }\n  }\n\n  return batches;\n}\n\nvar pathDividers = {\n  clone: function (params) {\n    var ret = []; // Fitting the alpha\n\n    var approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);\n\n    for (var i = 0; i < params.count; i++) {\n      var cloned = clonePath(params.path);\n      cloned.setStyle('opacity', approxOpacity);\n      ret.push(cloned);\n    }\n\n    return ret;\n  },\n  // Use the default divider\n  split: null\n};\nexport function applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {\n  if (!from.length || !to.length) {\n    return;\n  }\n\n  var updateAnimationCfg = getAnimationConfig('update', seriesModel, dataIndex);\n\n  if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {\n    return;\n  }\n\n  var animationDelay = seriesModel.getModel('universalTransition').get('delay');\n  var animationCfg = Object.assign({\n    // Need to setToFinal so the further calculation based on the style can be correct.\n    // Like emphasis color.\n    setToFinal: true\n  }, updateAnimationCfg);\n  var many;\n  var one;\n\n  if (isMultiple(from)) {\n    // manyToOne\n    many = from;\n    one = to;\n  }\n\n  if (isMultiple(to)) {\n    // oneToMany\n    many = to;\n    one = from;\n  }\n\n  function morphOneBatch(batch, fromIsMany, animateIndex, animateCount, forceManyOne) {\n    var batchMany = batch.many;\n    var batchOne = batch.one;\n\n    if (batchMany.length === 1 && !forceManyOne) {\n      // Is one to one\n      var batchFrom = fromIsMany ? batchMany[0] : batchOne;\n      var batchTo = fromIsMany ? batchOne : batchMany[0];\n\n      if (isCombineMorphing(batchFrom)) {\n        // Keep doing combine animation.\n        morphOneBatch({\n          many: [batchFrom],\n          one: batchTo\n        }, true, animateIndex, animateCount, true);\n      } else {\n        var individualAnimationCfg = animationDelay ? defaults({\n          delay: animationDelay(animateIndex, animateCount)\n        }, animationCfg) : animationCfg;\n        morphPath(batchFrom, batchTo, individualAnimationCfg);\n        animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);\n      }\n    } else {\n      var separateAnimationCfg = defaults({\n        dividePath: pathDividers[divideShape],\n        individualDelay: animationDelay && function (idx, count, fromPath, toPath) {\n          return animationDelay(idx + animateIndex, animateCount);\n        }\n      }, animationCfg);\n\n      var _a = fromIsMany ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg),\n          fromIndividuals = _a.fromIndividuals,\n          toIndividuals = _a.toIndividuals;\n\n      var count = fromIndividuals.length;\n\n      for (var k = 0; k < count; k++) {\n        var individualAnimationCfg = animationDelay ? defaults({\n          delay: animationDelay(k, count)\n        }, animationCfg) : animationCfg;\n        animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany ? batchMany[k] : batch.one, fromIsMany ? batch.one : batchMany[k], individualAnimationCfg);\n      }\n    }\n  }\n\n  var fromIsMany = many ? many === from // Is one to one. If the path number not match. also needs do merge and separate morphing.\n  : from.length > to.length;\n  var morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);\n  var animateCount = 0;\n\n  for (var i = 0; i < morphBatches.length; i++) {\n    animateCount += morphBatches[i].many.length;\n  }\n\n  var animateIndex = 0;\n\n  for (var i = 0; i < morphBatches.length; i++) {\n    morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount);\n    animateIndex += morphBatches[i].many.length;\n  }\n}\nexport function getPathList(elements) {\n  if (!elements) {\n    return [];\n  }\n\n  if (isArray(elements)) {\n    var pathList_1 = [];\n\n    for (var i = 0; i < elements.length; i++) {\n      pathList_1.push(getPathList(elements[i]));\n    }\n\n    return pathList_1;\n  }\n\n  var pathList = [];\n  elements.traverse(function (el) {\n    if (el instanceof Path && !el.disableMorphing && !el.invisible && !el.ignore) {\n      pathList.push(el);\n    }\n  });\n  return pathList;\n}"]},"metadata":{},"sourceType":"module"}