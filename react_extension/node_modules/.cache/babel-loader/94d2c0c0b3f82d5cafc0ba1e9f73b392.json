{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\n/* global Float32Array */\n// TODO Batch by color\n\nimport * as graphic from '../../util/graphic';\nimport { createSymbol } from '../../util/symbol';\nimport IncrementalDisplayable from 'zrender/lib/graphic/IncrementalDisplayable';\nimport { getECData } from '../../util/innerStore';\nvar BOOST_SIZE_THRESHOLD = 4;\n\nvar LargeSymbolPathShape =\n/** @class */\nfunction () {\n  function LargeSymbolPathShape() {}\n\n  return LargeSymbolPathShape;\n}();\n\nvar LargeSymbolPath =\n/** @class */\nfunction (_super) {\n  __extends(LargeSymbolPath, _super);\n\n  function LargeSymbolPath(opts) {\n    return _super.call(this, opts) || this;\n  }\n\n  LargeSymbolPath.prototype.getDefaultShape = function () {\n    return new LargeSymbolPathShape();\n  };\n\n  LargeSymbolPath.prototype.buildPath = function (path, shape) {\n    var points = shape.points;\n    var size = shape.size;\n    var symbolProxy = this.symbolProxy;\n    var symbolProxyShape = symbolProxy.shape;\n    var ctx = path.getContext ? path.getContext() : path;\n    var canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD; // Do draw in afterBrush.\n\n    if (canBoost) {\n      this._ctx = ctx;\n      return;\n    }\n\n    this._ctx = null;\n\n    for (var i = 0; i < points.length;) {\n      var x = points[i++];\n      var y = points[i++];\n\n      if (isNaN(x) || isNaN(y)) {\n        continue;\n      }\n\n      if (this.softClipShape && !this.softClipShape.contain(x, y)) {\n        continue;\n      }\n\n      symbolProxyShape.x = x - size[0] / 2;\n      symbolProxyShape.y = y - size[1] / 2;\n      symbolProxyShape.width = size[0];\n      symbolProxyShape.height = size[1];\n      symbolProxy.buildPath(path, symbolProxyShape, true);\n    }\n  };\n\n  LargeSymbolPath.prototype.afterBrush = function () {\n    var shape = this.shape;\n    var points = shape.points;\n    var size = shape.size;\n    var ctx = this._ctx;\n\n    if (!ctx) {\n      return;\n    } // PENDING If style or other canvas status changed?\n\n\n    for (var i = 0; i < points.length;) {\n      var x = points[i++];\n      var y = points[i++];\n\n      if (isNaN(x) || isNaN(y)) {\n        continue;\n      }\n\n      if (this.softClipShape && !this.softClipShape.contain(x, y)) {\n        continue;\n      } // fillRect is faster than building a rect path and draw.\n      // And it support light globalCompositeOperation.\n\n\n      ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);\n    }\n  };\n\n  LargeSymbolPath.prototype.findDataIndex = function (x, y) {\n    // TODO ???\n    // Consider transform\n    var shape = this.shape;\n    var points = shape.points;\n    var size = shape.size;\n    var w = Math.max(size[0], 4);\n    var h = Math.max(size[1], 4); // Not consider transform\n    // Treat each element as a rect\n    // top down traverse\n\n    for (var idx = points.length / 2 - 1; idx >= 0; idx--) {\n      var i = idx * 2;\n      var x0 = points[i] - w / 2;\n      var y0 = points[i + 1] - h / 2;\n\n      if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {\n        return idx;\n      }\n    }\n\n    return -1;\n  };\n\n  return LargeSymbolPath;\n}(graphic.Path);\n\nvar LargeSymbolDraw =\n/** @class */\nfunction () {\n  function LargeSymbolDraw() {\n    this.group = new graphic.Group();\n  }\n\n  LargeSymbolDraw.prototype.isPersistent = function () {\n    return !this._incremental;\n  };\n\n  ;\n  /**\n   * Update symbols draw by new data\n   */\n\n  LargeSymbolDraw.prototype.updateData = function (data, opt) {\n    this.group.removeAll();\n    var symbolEl = new LargeSymbolPath({\n      rectHover: true,\n      cursor: 'default'\n    });\n    symbolEl.setShape({\n      points: data.getLayout('points')\n    });\n\n    this._setCommon(symbolEl, data, false, opt);\n\n    this.group.add(symbolEl);\n    this._incremental = null;\n  };\n\n  LargeSymbolDraw.prototype.updateLayout = function (data) {\n    if (this._incremental) {\n      return;\n    }\n\n    var points = data.getLayout('points');\n    this.group.eachChild(function (child) {\n      if (child.startIndex != null) {\n        var len = (child.endIndex - child.startIndex) * 2;\n        var byteOffset = child.startIndex * 4 * 2;\n        points = new Float32Array(points.buffer, byteOffset, len);\n      }\n\n      child.setShape('points', points);\n    });\n  };\n\n  LargeSymbolDraw.prototype.incrementalPrepareUpdate = function (data) {\n    this.group.removeAll();\n\n    this._clearIncremental(); // Only use incremental displayables when data amount is larger than 2 million.\n    // PENDING Incremental data?\n\n\n    if (data.count() > 2e6) {\n      if (!this._incremental) {\n        this._incremental = new IncrementalDisplayable({\n          silent: true\n        });\n      }\n\n      this.group.add(this._incremental);\n    } else {\n      this._incremental = null;\n    }\n  };\n\n  LargeSymbolDraw.prototype.incrementalUpdate = function (taskParams, data, opt) {\n    var symbolEl;\n\n    if (this._incremental) {\n      symbolEl = new LargeSymbolPath();\n\n      this._incremental.addDisplayable(symbolEl, true);\n    } else {\n      symbolEl = new LargeSymbolPath({\n        rectHover: true,\n        cursor: 'default',\n        startIndex: taskParams.start,\n        endIndex: taskParams.end\n      });\n      symbolEl.incremental = true;\n      this.group.add(symbolEl);\n    }\n\n    symbolEl.setShape({\n      points: data.getLayout('points')\n    });\n\n    this._setCommon(symbolEl, data, !!this._incremental, opt);\n  };\n\n  LargeSymbolDraw.prototype._setCommon = function (symbolEl, data, isIncremental, opt) {\n    var hostModel = data.hostModel;\n    opt = opt || {};\n    var size = data.getVisual('symbolSize');\n    symbolEl.setShape('size', size instanceof Array ? size : [size, size]);\n    symbolEl.softClipShape = opt.clipShape || null; // Create symbolProxy to build path for each data\n\n    symbolEl.symbolProxy = createSymbol(data.getVisual('symbol'), 0, 0, 0, 0); // Use symbolProxy setColor method\n\n    symbolEl.setColor = symbolEl.symbolProxy.setColor;\n    var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;\n    symbolEl.useStyle( // Draw shadow when doing fillRect is extremely slow.\n    hostModel.getModel('itemStyle').getItemStyle(extrudeShadow ? ['color', 'shadowBlur', 'shadowColor'] : ['color']));\n    var globalStyle = data.getVisual('style');\n    var visualColor = globalStyle && globalStyle.fill;\n\n    if (visualColor) {\n      symbolEl.setColor(visualColor);\n    }\n\n    if (!isIncremental) {\n      var ecData_1 = getECData(symbolEl); // Enable tooltip\n      // PENDING May have performance issue when path is extremely large\n\n      ecData_1.seriesIndex = hostModel.seriesIndex;\n      symbolEl.on('mousemove', function (e) {\n        ecData_1.dataIndex = null;\n        var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);\n\n        if (dataIndex >= 0) {\n          // Provide dataIndex for tooltip\n          ecData_1.dataIndex = dataIndex + (symbolEl.startIndex || 0);\n        }\n      });\n    }\n  };\n\n  LargeSymbolDraw.prototype.remove = function () {\n    this._clearIncremental();\n\n    this._incremental = null;\n    this.group.removeAll();\n  };\n\n  LargeSymbolDraw.prototype._clearIncremental = function () {\n    var incremental = this._incremental;\n\n    if (incremental) {\n      incremental.clearDisplaybles();\n    }\n  };\n\n  return LargeSymbolDraw;\n}();\n\nexport default LargeSymbolDraw;","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/chart/helper/LargeSymbolDraw.js"],"names":["__extends","graphic","createSymbol","IncrementalDisplayable","getECData","BOOST_SIZE_THRESHOLD","LargeSymbolPathShape","LargeSymbolPath","_super","opts","call","prototype","getDefaultShape","buildPath","path","shape","points","size","symbolProxy","symbolProxyShape","ctx","getContext","canBoost","_ctx","i","length","x","y","isNaN","softClipShape","contain","width","height","afterBrush","fillRect","findDataIndex","w","Math","max","h","idx","x0","y0","Path","LargeSymbolDraw","group","Group","isPersistent","_incremental","updateData","data","opt","removeAll","symbolEl","rectHover","cursor","setShape","getLayout","_setCommon","add","updateLayout","eachChild","child","startIndex","len","endIndex","byteOffset","Float32Array","buffer","incrementalPrepareUpdate","_clearIncremental","count","silent","incrementalUpdate","taskParams","addDisplayable","start","end","incremental","isIncremental","hostModel","getVisual","Array","clipShape","setColor","extrudeShadow","useStyle","getModel","getItemStyle","globalStyle","visualColor","fill","ecData_1","seriesIndex","on","e","dataIndex","offsetX","offsetY","remove","clearDisplaybles"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\n/* global Float32Array */\n// TODO Batch by color\n\nimport * as graphic from '../../util/graphic';\nimport { createSymbol } from '../../util/symbol';\nimport IncrementalDisplayable from 'zrender/lib/graphic/IncrementalDisplayable';\nimport { getECData } from '../../util/innerStore';\nvar BOOST_SIZE_THRESHOLD = 4;\n\nvar LargeSymbolPathShape =\n/** @class */\nfunction () {\n  function LargeSymbolPathShape() {}\n\n  return LargeSymbolPathShape;\n}();\n\nvar LargeSymbolPath =\n/** @class */\nfunction (_super) {\n  __extends(LargeSymbolPath, _super);\n\n  function LargeSymbolPath(opts) {\n    return _super.call(this, opts) || this;\n  }\n\n  LargeSymbolPath.prototype.getDefaultShape = function () {\n    return new LargeSymbolPathShape();\n  };\n\n  LargeSymbolPath.prototype.buildPath = function (path, shape) {\n    var points = shape.points;\n    var size = shape.size;\n    var symbolProxy = this.symbolProxy;\n    var symbolProxyShape = symbolProxy.shape;\n    var ctx = path.getContext ? path.getContext() : path;\n    var canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD; // Do draw in afterBrush.\n\n    if (canBoost) {\n      this._ctx = ctx;\n      return;\n    }\n\n    this._ctx = null;\n\n    for (var i = 0; i < points.length;) {\n      var x = points[i++];\n      var y = points[i++];\n\n      if (isNaN(x) || isNaN(y)) {\n        continue;\n      }\n\n      if (this.softClipShape && !this.softClipShape.contain(x, y)) {\n        continue;\n      }\n\n      symbolProxyShape.x = x - size[0] / 2;\n      symbolProxyShape.y = y - size[1] / 2;\n      symbolProxyShape.width = size[0];\n      symbolProxyShape.height = size[1];\n      symbolProxy.buildPath(path, symbolProxyShape, true);\n    }\n  };\n\n  LargeSymbolPath.prototype.afterBrush = function () {\n    var shape = this.shape;\n    var points = shape.points;\n    var size = shape.size;\n    var ctx = this._ctx;\n\n    if (!ctx) {\n      return;\n    } // PENDING If style or other canvas status changed?\n\n\n    for (var i = 0; i < points.length;) {\n      var x = points[i++];\n      var y = points[i++];\n\n      if (isNaN(x) || isNaN(y)) {\n        continue;\n      }\n\n      if (this.softClipShape && !this.softClipShape.contain(x, y)) {\n        continue;\n      } // fillRect is faster than building a rect path and draw.\n      // And it support light globalCompositeOperation.\n\n\n      ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);\n    }\n  };\n\n  LargeSymbolPath.prototype.findDataIndex = function (x, y) {\n    // TODO ???\n    // Consider transform\n    var shape = this.shape;\n    var points = shape.points;\n    var size = shape.size;\n    var w = Math.max(size[0], 4);\n    var h = Math.max(size[1], 4); // Not consider transform\n    // Treat each element as a rect\n    // top down traverse\n\n    for (var idx = points.length / 2 - 1; idx >= 0; idx--) {\n      var i = idx * 2;\n      var x0 = points[i] - w / 2;\n      var y0 = points[i + 1] - h / 2;\n\n      if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {\n        return idx;\n      }\n    }\n\n    return -1;\n  };\n\n  return LargeSymbolPath;\n}(graphic.Path);\n\nvar LargeSymbolDraw =\n/** @class */\nfunction () {\n  function LargeSymbolDraw() {\n    this.group = new graphic.Group();\n  }\n\n  LargeSymbolDraw.prototype.isPersistent = function () {\n    return !this._incremental;\n  };\n\n  ;\n  /**\n   * Update symbols draw by new data\n   */\n\n  LargeSymbolDraw.prototype.updateData = function (data, opt) {\n    this.group.removeAll();\n    var symbolEl = new LargeSymbolPath({\n      rectHover: true,\n      cursor: 'default'\n    });\n    symbolEl.setShape({\n      points: data.getLayout('points')\n    });\n\n    this._setCommon(symbolEl, data, false, opt);\n\n    this.group.add(symbolEl);\n    this._incremental = null;\n  };\n\n  LargeSymbolDraw.prototype.updateLayout = function (data) {\n    if (this._incremental) {\n      return;\n    }\n\n    var points = data.getLayout('points');\n    this.group.eachChild(function (child) {\n      if (child.startIndex != null) {\n        var len = (child.endIndex - child.startIndex) * 2;\n        var byteOffset = child.startIndex * 4 * 2;\n        points = new Float32Array(points.buffer, byteOffset, len);\n      }\n\n      child.setShape('points', points);\n    });\n  };\n\n  LargeSymbolDraw.prototype.incrementalPrepareUpdate = function (data) {\n    this.group.removeAll();\n\n    this._clearIncremental(); // Only use incremental displayables when data amount is larger than 2 million.\n    // PENDING Incremental data?\n\n\n    if (data.count() > 2e6) {\n      if (!this._incremental) {\n        this._incremental = new IncrementalDisplayable({\n          silent: true\n        });\n      }\n\n      this.group.add(this._incremental);\n    } else {\n      this._incremental = null;\n    }\n  };\n\n  LargeSymbolDraw.prototype.incrementalUpdate = function (taskParams, data, opt) {\n    var symbolEl;\n\n    if (this._incremental) {\n      symbolEl = new LargeSymbolPath();\n\n      this._incremental.addDisplayable(symbolEl, true);\n    } else {\n      symbolEl = new LargeSymbolPath({\n        rectHover: true,\n        cursor: 'default',\n        startIndex: taskParams.start,\n        endIndex: taskParams.end\n      });\n      symbolEl.incremental = true;\n      this.group.add(symbolEl);\n    }\n\n    symbolEl.setShape({\n      points: data.getLayout('points')\n    });\n\n    this._setCommon(symbolEl, data, !!this._incremental, opt);\n  };\n\n  LargeSymbolDraw.prototype._setCommon = function (symbolEl, data, isIncremental, opt) {\n    var hostModel = data.hostModel;\n    opt = opt || {};\n    var size = data.getVisual('symbolSize');\n    symbolEl.setShape('size', size instanceof Array ? size : [size, size]);\n    symbolEl.softClipShape = opt.clipShape || null; // Create symbolProxy to build path for each data\n\n    symbolEl.symbolProxy = createSymbol(data.getVisual('symbol'), 0, 0, 0, 0); // Use symbolProxy setColor method\n\n    symbolEl.setColor = symbolEl.symbolProxy.setColor;\n    var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;\n    symbolEl.useStyle( // Draw shadow when doing fillRect is extremely slow.\n    hostModel.getModel('itemStyle').getItemStyle(extrudeShadow ? ['color', 'shadowBlur', 'shadowColor'] : ['color']));\n    var globalStyle = data.getVisual('style');\n    var visualColor = globalStyle && globalStyle.fill;\n\n    if (visualColor) {\n      symbolEl.setColor(visualColor);\n    }\n\n    if (!isIncremental) {\n      var ecData_1 = getECData(symbolEl); // Enable tooltip\n      // PENDING May have performance issue when path is extremely large\n\n      ecData_1.seriesIndex = hostModel.seriesIndex;\n      symbolEl.on('mousemove', function (e) {\n        ecData_1.dataIndex = null;\n        var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);\n\n        if (dataIndex >= 0) {\n          // Provide dataIndex for tooltip\n          ecData_1.dataIndex = dataIndex + (symbolEl.startIndex || 0);\n        }\n      });\n    }\n  };\n\n  LargeSymbolDraw.prototype.remove = function () {\n    this._clearIncremental();\n\n    this._incremental = null;\n    this.group.removeAll();\n  };\n\n  LargeSymbolDraw.prototype._clearIncremental = function () {\n    var incremental = this._incremental;\n\n    if (incremental) {\n      incremental.clearDisplaybles();\n    }\n  };\n\n  return LargeSymbolDraw;\n}();\n\nexport default LargeSymbolDraw;"]},"metadata":{},"sourceType":"module"}