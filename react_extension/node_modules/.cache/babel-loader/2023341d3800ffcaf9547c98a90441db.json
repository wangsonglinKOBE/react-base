{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _a, _b, _c; // TODO\n// ??? refactor? check the outer usage of data provider.\n// merge with defaultDimValueGetter?\n\n\nimport { isTypedArray, extend, assert, each, isObject, bind } from 'zrender/lib/core/util';\nimport { getDataItemValue } from '../../util/model';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source';\nimport { SOURCE_FORMAT_ORIGINAL, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_KEYED_COLUMNS, SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ARRAY_ROWS, SERIES_LAYOUT_BY_COLUMN, SERIES_LAYOUT_BY_ROW } from '../../util/types';\nvar providerMethods;\nvar mountMethods;\n/**\n * If normal array used, mutable chunk size is supported.\n * If typed array used, chunk size must be fixed.\n */\n\nvar DefaultDataProvider =\n/** @class */\nfunction () {\n  function DefaultDataProvider(sourceParam, dimSize) {\n    // let source: Source;\n    var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam; // declare source is Source;\n\n    this._source = source;\n    var data = this._data = source.data; // Typed array. TODO IE10+?\n\n    if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (dimSize == null) {\n          throw new Error('Typed array data must specify dimension size');\n        }\n      }\n\n      this._offset = 0;\n      this._dimSize = dimSize;\n      this._data = data;\n    }\n\n    mountMethods(this, data, source);\n  }\n\n  DefaultDataProvider.prototype.getSource = function () {\n    return this._source;\n  };\n\n  DefaultDataProvider.prototype.count = function () {\n    return 0;\n  };\n\n  DefaultDataProvider.prototype.getItem = function (idx, out) {\n    return;\n  };\n\n  DefaultDataProvider.prototype.appendData = function (newData) {};\n\n  DefaultDataProvider.prototype.clean = function () {};\n\n  DefaultDataProvider.protoInitialize = function () {\n    // PENDING: To avoid potential incompat (e.g., prototype\n    // is visited somewhere), still init them on prototype.\n    var proto = DefaultDataProvider.prototype;\n    proto.pure = false;\n    proto.persistent = true;\n  }();\n\n  DefaultDataProvider.internalField = function () {\n    var _a;\n\n    mountMethods = function (provider, data, source) {\n      var sourceFormat = source.sourceFormat;\n      var seriesLayoutBy = source.seriesLayoutBy;\n      var startIndex = source.startIndex;\n      var dimsDef = source.dimensionsDefine;\n      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert(methods, 'Invalide sourceFormat: ' + sourceFormat);\n      }\n\n      extend(provider, methods);\n\n      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n        provider.getItem = getItemForTypedArray;\n        provider.count = countForTypedArray;\n        provider.fillStorage = fillStorageForTypedArray;\n      } else {\n        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);\n        provider.getItem = bind(rawItemGetter, null, data, startIndex, dimsDef);\n        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);\n        provider.count = bind(rawCounter, null, data, startIndex, dimsDef);\n      }\n    };\n\n    var getItemForTypedArray = function (idx, out) {\n      idx = idx - this._offset;\n      out = out || [];\n      var data = this._data;\n      var dimSize = this._dimSize;\n      var offset = dimSize * idx;\n\n      for (var i = 0; i < dimSize; i++) {\n        out[i] = data[offset + i];\n      }\n\n      return out;\n    };\n\n    var fillStorageForTypedArray = function (start, end, storage, extent) {\n      var data = this._data;\n      var dimSize = this._dimSize;\n\n      for (var dim = 0; dim < dimSize; dim++) {\n        var dimExtent = extent[dim];\n        var min = dimExtent[0] == null ? Infinity : dimExtent[0];\n        var max = dimExtent[1] == null ? -Infinity : dimExtent[1];\n        var count = end - start;\n        var arr = storage[dim];\n\n        for (var i = 0; i < count; i++) {\n          // appendData with TypedArray will always do replace in provider.\n          var val = data[i * dimSize + dim];\n          arr[start + i] = val;\n          val < min && (min = val);\n          val > max && (max = val);\n        }\n\n        dimExtent[0] = min;\n        dimExtent[1] = max;\n      }\n    };\n\n    var countForTypedArray = function () {\n      return this._data ? this._data.length / this._dimSize : 0;\n    };\n\n    providerMethods = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = {\n      pure: true,\n      appendData: function () {\n        throw new Error('Do not support appendData when set seriesLayoutBy: \"row\".');\n      }\n    }, _a[SOURCE_FORMAT_OBJECT_ROWS] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_KEYED_COLUMNS] = {\n      pure: true,\n      appendData: function (newData) {\n        var data = this._data;\n        each(newData, function (newCol, key) {\n          var oldCol = data[key] || (data[key] = []);\n\n          for (var i = 0; i < (newCol || []).length; i++) {\n            oldCol.push(newCol[i]);\n          }\n        });\n      }\n    }, _a[SOURCE_FORMAT_ORIGINAL] = {\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_TYPED_ARRAY] = {\n      persistent: false,\n      pure: true,\n      appendData: function (newData) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(isTypedArray(newData), 'Added data must be TypedArray if data in initialization is TypedArray');\n        }\n\n        this._data = newData;\n      },\n      // Clean self if data is already used.\n      clean: function () {\n        // PENDING\n        this._offset += this.count();\n        this._data = null;\n      }\n    }, _a);\n\n    function appendDataSimply(newData) {\n      for (var i = 0; i < newData.length; i++) {\n        this._data.push(newData[i]);\n      }\n    }\n  }();\n\n  return DefaultDataProvider;\n}();\n\nexport { DefaultDataProvider };\n\nvar getItemSimply = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx];\n};\n\nvar rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx + startIndex];\n}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef, idx, out) {\n  idx += startIndex;\n  var item = out || [];\n  var data = rawData;\n\n  for (var i = 0; i < data.length; i++) {\n    var row = data[i];\n    item[i] = row ? row[idx] : null;\n  }\n\n  return item;\n}, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef, idx, out) {\n  var item = out || [];\n\n  for (var i = 0; i < dimsDef.length; i++) {\n    var dimName = dimsDef[i].name;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimName == null) {\n        throw new Error();\n      }\n    }\n\n    var col = rawData[dimName];\n    item[i] = col ? col[idx] : null;\n  }\n\n  return item;\n}, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);\nexport function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not support get item on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n\n  return method;\n}\n\nvar countSimply = function (rawData, startIndex, dimsDef) {\n  return rawData.length;\n};\n\nvar rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef) {\n  return Math.max(0, rawData.length - startIndex);\n}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef) {\n  var row = rawData[0];\n  return row ? Math.max(0, row.length - startIndex) : 0;\n}, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef) {\n  var dimName = dimsDef[0].name;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (dimName == null) {\n      throw new Error();\n    }\n  }\n\n  var col = rawData[dimName];\n  return col ? col.length : 0;\n}, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);\nexport function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not suppport count on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n\n  return method;\n}\n\nvar getRawValueSimply = function (dataItem, dimIndex, property) {\n  return dataItem[dimIndex];\n};\n\nvar rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function (dataItem, dimIndex, property) {\n  return dataItem[property];\n}, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function (dataItem, dimIndex, property) {\n  // FIXME: In some case (markpoint in geo (geo-map.html)),\n  // dataItem is {coord: [...]}\n  var value = getDataItemValue(dataItem);\n  return !(value instanceof Array) ? value : value[dimIndex];\n}, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);\nexport function getRawSourceValueGetter(sourceFormat) {\n  var method = rawSourceValueGetterMap[sourceFormat];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not suppport get value on \"' + sourceFormat + '\".');\n  }\n\n  return method;\n}\n\nfunction getMethodMapKey(sourceFormat, seriesLayoutBy) {\n  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + seriesLayoutBy : sourceFormat;\n} // ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,\n// Consider persistent.\n// Caution: why use raw value to display on label or tooltip?\n// A reason is to avoid format. For example time value we do not know\n// how to format is expected. More over, if stack is used, calculated\n// value may be 0.91000000001, which have brings trouble to display.\n// TODO: consider how to treat null/undefined/NaN when display?\n\n\nexport function retrieveRawValue(data, dataIndex, // If dimIndex is null/undefined, return OptionDataItem.\n// Otherwise, return OptionDataValue.\ndim) {\n  if (!data) {\n    return;\n  } // Consider data may be not persistent.\n\n\n  var dataItem = data.getRawDataItem(dataIndex);\n\n  if (dataItem == null) {\n    return;\n  }\n\n  var store = data.getStore();\n  var sourceFormat = store.getSource().sourceFormat;\n\n  if (dim != null) {\n    var dimIndex = data.getDimensionIndex(dim);\n    var property = store.getDimensionProperty(dimIndex);\n    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);\n  } else {\n    var result = dataItem;\n\n    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n      result = getDataItemValue(dataItem);\n    }\n\n    return result;\n  }\n}\n/**\n * Compatible with some cases (in pie, map) like:\n * data: [{name: 'xx', value: 5, selected: true}, ...]\n * where only sourceFormat is 'original' and 'objectRows' supported.\n *\n * // TODO\n * Supported detail options in data item when using 'arrayRows'.\n *\n * @param data\n * @param dataIndex\n * @param attr like 'selected'\n */\n\nexport function retrieveRawAttr(data, dataIndex, attr) {\n  if (!data) {\n    return;\n  }\n\n  var sourceFormat = data.getStore().getSource().sourceFormat;\n\n  if (sourceFormat !== SOURCE_FORMAT_ORIGINAL && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {\n    return;\n  }\n\n  var dataItem = data.getRawDataItem(dataIndex);\n\n  if (sourceFormat === SOURCE_FORMAT_ORIGINAL && !isObject(dataItem)) {\n    dataItem = null;\n  }\n\n  if (dataItem) {\n    return dataItem[attr];\n  }\n}","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/data/helper/dataProvider.js"],"names":["_a","_b","_c","isTypedArray","extend","assert","each","isObject","bind","getDataItemValue","createSourceFromSeriesDataOption","isSourceInstance","SOURCE_FORMAT_ORIGINAL","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_KEYED_COLUMNS","SOURCE_FORMAT_TYPED_ARRAY","SOURCE_FORMAT_ARRAY_ROWS","SERIES_LAYOUT_BY_COLUMN","SERIES_LAYOUT_BY_ROW","providerMethods","mountMethods","DefaultDataProvider","sourceParam","dimSize","source","_source","data","_data","sourceFormat","process","env","NODE_ENV","Error","_offset","_dimSize","prototype","getSource","count","getItem","idx","out","appendData","newData","clean","protoInitialize","proto","pure","persistent","internalField","provider","seriesLayoutBy","startIndex","dimsDef","dimensionsDefine","methods","getMethodMapKey","getItemForTypedArray","countForTypedArray","fillStorage","fillStorageForTypedArray","rawItemGetter","getRawSourceItemGetter","rawCounter","getRawSourceDataCounter","offset","i","start","end","storage","extent","dim","dimExtent","min","Infinity","max","arr","val","length","appendDataSimply","newCol","key","oldCol","push","getItemSimply","rawData","rawSourceItemGetterMap","item","row","dimName","name","col","method","countSimply","rawSourceDataCounterMap","Math","getRawValueSimply","dataItem","dimIndex","property","rawSourceValueGetterMap","value","Array","getRawSourceValueGetter","retrieveRawValue","dataIndex","getRawDataItem","store","getStore","getDimensionIndex","getDimensionProperty","result","retrieveRawAttr","attr"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,C,CAAgB;AAChB;AACA;;;AAGA,SAASC,YAAT,EAAuBC,MAAvB,EAA+BC,MAA/B,EAAuCC,IAAvC,EAA6CC,QAA7C,EAAuDC,IAAvD,QAAmE,uBAAnE;AACA,SAASC,gBAAT,QAAiC,kBAAjC;AACA,SAASC,gCAAT,EAA2CC,gBAA3C,QAAmE,WAAnE;AACA,SAASC,sBAAT,EAAiCC,yBAAjC,EAA4DC,2BAA5D,EAAyFC,yBAAzF,EAAoHC,wBAApH,EAA8IC,uBAA9I,EAAuKC,oBAAvK,QAAmM,kBAAnM;AACA,IAAIC,eAAJ;AACA,IAAIC,YAAJ;AACA;AACA;AACA;AACA;;AAEA,IAAIC,mBAAmB;AACvB;AACA,YAAY;AACV,WAASA,mBAAT,CAA6BC,WAA7B,EAA0CC,OAA1C,EAAmD;AACjD;AACA,QAAIC,MAAM,GAAG,CAACb,gBAAgB,CAACW,WAAD,CAAjB,GAAiCZ,gCAAgC,CAACY,WAAD,CAAjE,GAAiFA,WAA9F,CAFiD,CAE0D;;AAE3G,SAAKG,OAAL,GAAeD,MAAf;AACA,QAAIE,IAAI,GAAG,KAAKC,KAAL,GAAaH,MAAM,CAACE,IAA/B,CALiD,CAKZ;;AAErC,QAAIF,MAAM,CAACI,YAAP,KAAwBb,yBAA5B,EAAuD;AACrD,UAAIc,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,YAAIR,OAAO,IAAI,IAAf,EAAqB;AACnB,gBAAM,IAAIS,KAAJ,CAAU,8CAAV,CAAN;AACD;AACF;;AAED,WAAKC,OAAL,GAAe,CAAf;AACA,WAAKC,QAAL,GAAgBX,OAAhB;AACA,WAAKI,KAAL,GAAaD,IAAb;AACD;;AAEDN,IAAAA,YAAY,CAAC,IAAD,EAAOM,IAAP,EAAaF,MAAb,CAAZ;AACD;;AAEDH,EAAAA,mBAAmB,CAACc,SAApB,CAA8BC,SAA9B,GAA0C,YAAY;AACpD,WAAO,KAAKX,OAAZ;AACD,GAFD;;AAIAJ,EAAAA,mBAAmB,CAACc,SAApB,CAA8BE,KAA9B,GAAsC,YAAY;AAChD,WAAO,CAAP;AACD,GAFD;;AAIAhB,EAAAA,mBAAmB,CAACc,SAApB,CAA8BG,OAA9B,GAAwC,UAAUC,GAAV,EAAeC,GAAf,EAAoB;AAC1D;AACD,GAFD;;AAIAnB,EAAAA,mBAAmB,CAACc,SAApB,CAA8BM,UAA9B,GAA2C,UAAUC,OAAV,EAAmB,CAAE,CAAhE;;AAEArB,EAAAA,mBAAmB,CAACc,SAApB,CAA8BQ,KAA9B,GAAsC,YAAY,CAAE,CAApD;;AAEAtB,EAAAA,mBAAmB,CAACuB,eAApB,GAAsC,YAAY;AAChD;AACA;AACA,QAAIC,KAAK,GAAGxB,mBAAmB,CAACc,SAAhC;AACAU,IAAAA,KAAK,CAACC,IAAN,GAAa,KAAb;AACAD,IAAAA,KAAK,CAACE,UAAN,GAAmB,IAAnB;AACD,GANqC,EAAtC;;AAQA1B,EAAAA,mBAAmB,CAAC2B,aAApB,GAAoC,YAAY;AAC9C,QAAIhD,EAAJ;;AAEAoB,IAAAA,YAAY,GAAG,UAAU6B,QAAV,EAAoBvB,IAApB,EAA0BF,MAA1B,EAAkC;AAC/C,UAAII,YAAY,GAAGJ,MAAM,CAACI,YAA1B;AACA,UAAIsB,cAAc,GAAG1B,MAAM,CAAC0B,cAA5B;AACA,UAAIC,UAAU,GAAG3B,MAAM,CAAC2B,UAAxB;AACA,UAAIC,OAAO,GAAG5B,MAAM,CAAC6B,gBAArB;AACA,UAAIC,OAAO,GAAGnC,eAAe,CAACoC,eAAe,CAAC3B,YAAD,EAAesB,cAAf,CAAhB,CAA7B;;AAEA,UAAIrB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC1B,QAAAA,MAAM,CAACiD,OAAD,EAAU,4BAA4B1B,YAAtC,CAAN;AACD;;AAEDxB,MAAAA,MAAM,CAAC6C,QAAD,EAAWK,OAAX,CAAN;;AAEA,UAAI1B,YAAY,KAAKb,yBAArB,EAAgD;AAC9CkC,QAAAA,QAAQ,CAACX,OAAT,GAAmBkB,oBAAnB;AACAP,QAAAA,QAAQ,CAACZ,KAAT,GAAiBoB,kBAAjB;AACAR,QAAAA,QAAQ,CAACS,WAAT,GAAuBC,wBAAvB;AACD,OAJD,MAIO;AACL,YAAIC,aAAa,GAAGC,sBAAsB,CAACjC,YAAD,EAAesB,cAAf,CAA1C;AACAD,QAAAA,QAAQ,CAACX,OAAT,GAAmB9B,IAAI,CAACoD,aAAD,EAAgB,IAAhB,EAAsBlC,IAAtB,EAA4ByB,UAA5B,EAAwCC,OAAxC,CAAvB;AACA,YAAIU,UAAU,GAAGC,uBAAuB,CAACnC,YAAD,EAAesB,cAAf,CAAxC;AACAD,QAAAA,QAAQ,CAACZ,KAAT,GAAiB7B,IAAI,CAACsD,UAAD,EAAa,IAAb,EAAmBpC,IAAnB,EAAyByB,UAAzB,EAAqCC,OAArC,CAArB;AACD;AACF,KAvBD;;AAyBA,QAAII,oBAAoB,GAAG,UAAUjB,GAAV,EAAeC,GAAf,EAAoB;AAC7CD,MAAAA,GAAG,GAAGA,GAAG,GAAG,KAAKN,OAAjB;AACAO,MAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;AACA,UAAId,IAAI,GAAG,KAAKC,KAAhB;AACA,UAAIJ,OAAO,GAAG,KAAKW,QAAnB;AACA,UAAI8B,MAAM,GAAGzC,OAAO,GAAGgB,GAAvB;;AAEA,WAAK,IAAI0B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1C,OAApB,EAA6B0C,CAAC,EAA9B,EAAkC;AAChCzB,QAAAA,GAAG,CAACyB,CAAD,CAAH,GAASvC,IAAI,CAACsC,MAAM,GAAGC,CAAV,CAAb;AACD;;AAED,aAAOzB,GAAP;AACD,KAZD;;AAcA,QAAImB,wBAAwB,GAAG,UAAUO,KAAV,EAAiBC,GAAjB,EAAsBC,OAAtB,EAA+BC,MAA/B,EAAuC;AACpE,UAAI3C,IAAI,GAAG,KAAKC,KAAhB;AACA,UAAIJ,OAAO,GAAG,KAAKW,QAAnB;;AAEA,WAAK,IAAIoC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG/C,OAAxB,EAAiC+C,GAAG,EAApC,EAAwC;AACtC,YAAIC,SAAS,GAAGF,MAAM,CAACC,GAAD,CAAtB;AACA,YAAIE,GAAG,GAAGD,SAAS,CAAC,CAAD,CAAT,IAAgB,IAAhB,GAAuBE,QAAvB,GAAkCF,SAAS,CAAC,CAAD,CAArD;AACA,YAAIG,GAAG,GAAGH,SAAS,CAAC,CAAD,CAAT,IAAgB,IAAhB,GAAuB,CAACE,QAAxB,GAAmCF,SAAS,CAAC,CAAD,CAAtD;AACA,YAAIlC,KAAK,GAAG8B,GAAG,GAAGD,KAAlB;AACA,YAAIS,GAAG,GAAGP,OAAO,CAACE,GAAD,CAAjB;;AAEA,aAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5B,KAApB,EAA2B4B,CAAC,EAA5B,EAAgC;AAC9B;AACA,cAAIW,GAAG,GAAGlD,IAAI,CAACuC,CAAC,GAAG1C,OAAJ,GAAc+C,GAAf,CAAd;AACAK,UAAAA,GAAG,CAACT,KAAK,GAAGD,CAAT,CAAH,GAAiBW,GAAjB;AACAA,UAAAA,GAAG,GAAGJ,GAAN,KAAcA,GAAG,GAAGI,GAApB;AACAA,UAAAA,GAAG,GAAGF,GAAN,KAAcA,GAAG,GAAGE,GAApB;AACD;;AAEDL,QAAAA,SAAS,CAAC,CAAD,CAAT,GAAeC,GAAf;AACAD,QAAAA,SAAS,CAAC,CAAD,CAAT,GAAeG,GAAf;AACD;AACF,KAtBD;;AAwBA,QAAIjB,kBAAkB,GAAG,YAAY;AACnC,aAAO,KAAK9B,KAAL,GAAa,KAAKA,KAAL,CAAWkD,MAAX,GAAoB,KAAK3C,QAAtC,GAAiD,CAAxD;AACD,KAFD;;AAIAf,IAAAA,eAAe,IAAInB,EAAE,GAAG,EAAL,EAASA,EAAE,CAACgB,wBAAwB,GAAG,GAA3B,GAAiCC,uBAAlC,CAAF,GAA+D;AACzF6B,MAAAA,IAAI,EAAE,IADmF;AAEzFL,MAAAA,UAAU,EAAEqC;AAF6E,KAAxE,EAGhB9E,EAAE,CAACgB,wBAAwB,GAAG,GAA3B,GAAiCE,oBAAlC,CAAF,GAA4D;AAC7D4B,MAAAA,IAAI,EAAE,IADuD;AAE7DL,MAAAA,UAAU,EAAE,YAAY;AACtB,cAAM,IAAIT,KAAJ,CAAU,2DAAV,CAAN;AACD;AAJ4D,KAH5C,EAQhBhC,EAAE,CAACa,yBAAD,CAAF,GAAgC;AACjCiC,MAAAA,IAAI,EAAE,IAD2B;AAEjCL,MAAAA,UAAU,EAAEqC;AAFqB,KARhB,EAWhB9E,EAAE,CAACc,2BAAD,CAAF,GAAkC;AACnCgC,MAAAA,IAAI,EAAE,IAD6B;AAEnCL,MAAAA,UAAU,EAAE,UAAUC,OAAV,EAAmB;AAC7B,YAAIhB,IAAI,GAAG,KAAKC,KAAhB;AACArB,QAAAA,IAAI,CAACoC,OAAD,EAAU,UAAUqC,MAAV,EAAkBC,GAAlB,EAAuB;AACnC,cAAIC,MAAM,GAAGvD,IAAI,CAACsD,GAAD,CAAJ,KAActD,IAAI,CAACsD,GAAD,CAAJ,GAAY,EAA1B,CAAb;;AAEA,eAAK,IAAIf,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAACc,MAAM,IAAI,EAAX,EAAeF,MAAnC,EAA2CZ,CAAC,EAA5C,EAAgD;AAC9CgB,YAAAA,MAAM,CAACC,IAAP,CAAYH,MAAM,CAACd,CAAD,CAAlB;AACD;AACF,SANG,CAAJ;AAOD;AAXkC,KAXlB,EAuBhBjE,EAAE,CAACY,sBAAD,CAAF,GAA6B;AAC9B6B,MAAAA,UAAU,EAAEqC;AADkB,KAvBb,EAyBhB9E,EAAE,CAACe,yBAAD,CAAF,GAAgC;AACjCgC,MAAAA,UAAU,EAAE,KADqB;AAEjCD,MAAAA,IAAI,EAAE,IAF2B;AAGjCL,MAAAA,UAAU,EAAE,UAAUC,OAAV,EAAmB;AAC7B,YAAIb,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC1B,UAAAA,MAAM,CAACF,YAAY,CAACuC,OAAD,CAAb,EAAwB,uEAAxB,CAAN;AACD;;AAED,aAAKf,KAAL,GAAae,OAAb;AACD,OATgC;AAUjC;AACAC,MAAAA,KAAK,EAAE,YAAY;AACjB;AACA,aAAKV,OAAL,IAAgB,KAAKI,KAAL,EAAhB;AACA,aAAKV,KAAL,GAAa,IAAb;AACD;AAfgC,KAzBhB,EAyChB3B,EAzCY,CAAf;;AA2CA,aAAS8E,gBAAT,CAA0BpC,OAA1B,EAAmC;AACjC,WAAK,IAAIuB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvB,OAAO,CAACmC,MAA5B,EAAoCZ,CAAC,EAArC,EAAyC;AACvC,aAAKtC,KAAL,CAAWuD,IAAX,CAAgBxC,OAAO,CAACuB,CAAD,CAAvB;AACD;AACF;AACF,GAtHmC,EAApC;;AAwHA,SAAO5C,mBAAP;AACD,CAxKD,EAFA;;AA4KA,SAASA,mBAAT;;AAEA,IAAI8D,aAAa,GAAG,UAAUC,OAAV,EAAmBjC,UAAnB,EAA+BC,OAA/B,EAAwCb,GAAxC,EAA6C;AAC/D,SAAO6C,OAAO,CAAC7C,GAAD,CAAd;AACD,CAFD;;AAIA,IAAI8C,sBAAsB,IAAIrF,EAAE,GAAG,EAAL,EAASA,EAAE,CAACgB,wBAAwB,GAAG,GAA3B,GAAiCC,uBAAlC,CAAF,GAA+D,UAAUmE,OAAV,EAAmBjC,UAAnB,EAA+BC,OAA/B,EAAwCb,GAAxC,EAA6C;AACjJ,SAAO6C,OAAO,CAAC7C,GAAG,GAAGY,UAAP,CAAd;AACD,CAF6B,EAE3BnD,EAAE,CAACgB,wBAAwB,GAAG,GAA3B,GAAiCE,oBAAlC,CAAF,GAA4D,UAAUkE,OAAV,EAAmBjC,UAAnB,EAA+BC,OAA/B,EAAwCb,GAAxC,EAA6CC,GAA7C,EAAkD;AAC/GD,EAAAA,GAAG,IAAIY,UAAP;AACA,MAAImC,IAAI,GAAG9C,GAAG,IAAI,EAAlB;AACA,MAAId,IAAI,GAAG0D,OAAX;;AAEA,OAAK,IAAInB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGvC,IAAI,CAACmD,MAAzB,EAAiCZ,CAAC,EAAlC,EAAsC;AACpC,QAAIsB,GAAG,GAAG7D,IAAI,CAACuC,CAAD,CAAd;AACAqB,IAAAA,IAAI,CAACrB,CAAD,CAAJ,GAAUsB,GAAG,GAAGA,GAAG,CAAChD,GAAD,CAAN,GAAc,IAA3B;AACD;;AAED,SAAO+C,IAAP;AACD,CAb6B,EAa3BtF,EAAE,CAACa,yBAAD,CAAF,GAAgCsE,aAbL,EAaoBnF,EAAE,CAACc,2BAAD,CAAF,GAAkC,UAAUsE,OAAV,EAAmBjC,UAAnB,EAA+BC,OAA/B,EAAwCb,GAAxC,EAA6CC,GAA7C,EAAkD;AACpI,MAAI8C,IAAI,GAAG9C,GAAG,IAAI,EAAlB;;AAEA,OAAK,IAAIyB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGb,OAAO,CAACyB,MAA5B,EAAoCZ,CAAC,EAArC,EAAyC;AACvC,QAAIuB,OAAO,GAAGpC,OAAO,CAACa,CAAD,CAAP,CAAWwB,IAAzB;;AAEA,QAAI5D,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,UAAIyD,OAAO,IAAI,IAAf,EAAqB;AACnB,cAAM,IAAIxD,KAAJ,EAAN;AACD;AACF;;AAED,QAAI0D,GAAG,GAAGN,OAAO,CAACI,OAAD,CAAjB;AACAF,IAAAA,IAAI,CAACrB,CAAD,CAAJ,GAAUyB,GAAG,GAAGA,GAAG,CAACnD,GAAD,CAAN,GAAc,IAA3B;AACD;;AAED,SAAO+C,IAAP;AACD,CA9B6B,EA8B3BtF,EAAE,CAACY,sBAAD,CAAF,GAA6BuE,aA9BF,EA8BiBnF,EA9BrB,CAA1B;AA+BA,OAAO,SAAS6D,sBAAT,CAAgCjC,YAAhC,EAA8CsB,cAA9C,EAA8D;AACnE,MAAIyC,MAAM,GAAGN,sBAAsB,CAAC9B,eAAe,CAAC3B,YAAD,EAAesB,cAAf,CAAhB,CAAnC;;AAEA,MAAIrB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC1B,IAAAA,MAAM,CAACsF,MAAD,EAAS,iCAAiC/D,YAAjC,GAAgD,MAAhD,GAAyDsB,cAAzD,GAA0E,IAAnF,CAAN;AACD;;AAED,SAAOyC,MAAP;AACD;;AAED,IAAIC,WAAW,GAAG,UAAUR,OAAV,EAAmBjC,UAAnB,EAA+BC,OAA/B,EAAwC;AACxD,SAAOgC,OAAO,CAACP,MAAf;AACD,CAFD;;AAIA,IAAIgB,uBAAuB,IAAI5F,EAAE,GAAG,EAAL,EAASA,EAAE,CAACe,wBAAwB,GAAG,GAA3B,GAAiCC,uBAAlC,CAAF,GAA+D,UAAUmE,OAAV,EAAmBjC,UAAnB,EAA+BC,OAA/B,EAAwC;AAC7I,SAAO0C,IAAI,CAACpB,GAAL,CAAS,CAAT,EAAYU,OAAO,CAACP,MAAR,GAAiB1B,UAA7B,CAAP;AACD,CAF8B,EAE5BlD,EAAE,CAACe,wBAAwB,GAAG,GAA3B,GAAiCE,oBAAlC,CAAF,GAA4D,UAAUkE,OAAV,EAAmBjC,UAAnB,EAA+BC,OAA/B,EAAwC;AACrG,MAAImC,GAAG,GAAGH,OAAO,CAAC,CAAD,CAAjB;AACA,SAAOG,GAAG,GAAGO,IAAI,CAACpB,GAAL,CAAS,CAAT,EAAYa,GAAG,CAACV,MAAJ,GAAa1B,UAAzB,CAAH,GAA0C,CAApD;AACD,CAL8B,EAK5BlD,EAAE,CAACY,yBAAD,CAAF,GAAgC+E,WALJ,EAKiB3F,EAAE,CAACa,2BAAD,CAAF,GAAkC,UAAUsE,OAAV,EAAmBjC,UAAnB,EAA+BC,OAA/B,EAAwC;AACxH,MAAIoC,OAAO,GAAGpC,OAAO,CAAC,CAAD,CAAP,CAAWqC,IAAzB;;AAEA,MAAI5D,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,QAAIyD,OAAO,IAAI,IAAf,EAAqB;AACnB,YAAM,IAAIxD,KAAJ,EAAN;AACD;AACF;;AAED,MAAI0D,GAAG,GAAGN,OAAO,CAACI,OAAD,CAAjB;AACA,SAAOE,GAAG,GAAGA,GAAG,CAACb,MAAP,GAAgB,CAA1B;AACD,CAhB8B,EAgB5B5E,EAAE,CAACW,sBAAD,CAAF,GAA6BgF,WAhBD,EAgBc3F,EAhBlB,CAA3B;AAiBA,OAAO,SAAS8D,uBAAT,CAAiCnC,YAAjC,EAA+CsB,cAA/C,EAA+D;AACpE,MAAIyC,MAAM,GAAGE,uBAAuB,CAACtC,eAAe,CAAC3B,YAAD,EAAesB,cAAf,CAAhB,CAApC;;AAEA,MAAIrB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC1B,IAAAA,MAAM,CAACsF,MAAD,EAAS,+BAA+B/D,YAA/B,GAA8C,MAA9C,GAAuDsB,cAAvD,GAAwE,IAAjF,CAAN;AACD;;AAED,SAAOyC,MAAP;AACD;;AAED,IAAII,iBAAiB,GAAG,UAAUC,QAAV,EAAoBC,QAApB,EAA8BC,QAA9B,EAAwC;AAC9D,SAAOF,QAAQ,CAACC,QAAD,CAAf;AACD,CAFD;;AAIA,IAAIE,uBAAuB,IAAIjG,EAAE,GAAG,EAAL,EAASA,EAAE,CAACc,wBAAD,CAAF,GAA+B+E,iBAAxC,EAA2D7F,EAAE,CAACW,yBAAD,CAAF,GAAgC,UAAUmF,QAAV,EAAoBC,QAApB,EAA8BC,QAA9B,EAAwC;AAChK,SAAOF,QAAQ,CAACE,QAAD,CAAf;AACD,CAF8B,EAE5BhG,EAAE,CAACY,2BAAD,CAAF,GAAkCiF,iBAFN,EAEyB7F,EAAE,CAACU,sBAAD,CAAF,GAA6B,UAAUoF,QAAV,EAAoBC,QAApB,EAA8BC,QAA9B,EAAwC;AAC3H;AACA;AACA,MAAIE,KAAK,GAAG3F,gBAAgB,CAACuF,QAAD,CAA5B;AACA,SAAO,EAAEI,KAAK,YAAYC,KAAnB,IAA4BD,KAA5B,GAAoCA,KAAK,CAACH,QAAD,CAAhD;AACD,CAP8B,EAO5B/F,EAAE,CAACa,yBAAD,CAAF,GAAgCgF,iBAPJ,EAOuB7F,EAP3B,CAA3B;AAQA,OAAO,SAASoG,uBAAT,CAAiC1E,YAAjC,EAA+C;AACpD,MAAI+D,MAAM,GAAGQ,uBAAuB,CAACvE,YAAD,CAApC;;AAEA,MAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC1B,IAAAA,MAAM,CAACsF,MAAD,EAAS,mCAAmC/D,YAAnC,GAAkD,IAA3D,CAAN;AACD;;AAED,SAAO+D,MAAP;AACD;;AAED,SAASpC,eAAT,CAAyB3B,YAAzB,EAAuCsB,cAAvC,EAAuD;AACrD,SAAOtB,YAAY,KAAKZ,wBAAjB,GAA4CY,YAAY,GAAG,GAAf,GAAqBsB,cAAjE,GAAkFtB,YAAzF;AACD,C,CAAC;AACF;AACA;AACA;AACA;AACA;AACA;;;AAGA,OAAO,SAAS2E,gBAAT,CAA0B7E,IAA1B,EAAgC8E,SAAhC,EAA2C;AAClD;AACAlC,GAFO,EAEF;AACH,MAAI,CAAC5C,IAAL,EAAW;AACT;AACD,GAHE,CAGD;;;AAGF,MAAIsE,QAAQ,GAAGtE,IAAI,CAAC+E,cAAL,CAAoBD,SAApB,CAAf;;AAEA,MAAIR,QAAQ,IAAI,IAAhB,EAAsB;AACpB;AACD;;AAED,MAAIU,KAAK,GAAGhF,IAAI,CAACiF,QAAL,EAAZ;AACA,MAAI/E,YAAY,GAAG8E,KAAK,CAACtE,SAAN,GAAkBR,YAArC;;AAEA,MAAI0C,GAAG,IAAI,IAAX,EAAiB;AACf,QAAI2B,QAAQ,GAAGvE,IAAI,CAACkF,iBAAL,CAAuBtC,GAAvB,CAAf;AACA,QAAI4B,QAAQ,GAAGQ,KAAK,CAACG,oBAAN,CAA2BZ,QAA3B,CAAf;AACA,WAAOK,uBAAuB,CAAC1E,YAAD,CAAvB,CAAsCoE,QAAtC,EAAgDC,QAAhD,EAA0DC,QAA1D,CAAP;AACD,GAJD,MAIO;AACL,QAAIY,MAAM,GAAGd,QAAb;;AAEA,QAAIpE,YAAY,KAAKhB,sBAArB,EAA6C;AAC3CkG,MAAAA,MAAM,GAAGrG,gBAAgB,CAACuF,QAAD,CAAzB;AACD;;AAED,WAAOc,MAAP;AACD;AACF;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,eAAT,CAAyBrF,IAAzB,EAA+B8E,SAA/B,EAA0CQ,IAA1C,EAAgD;AACrD,MAAI,CAACtF,IAAL,EAAW;AACT;AACD;;AAED,MAAIE,YAAY,GAAGF,IAAI,CAACiF,QAAL,GAAgBvE,SAAhB,GAA4BR,YAA/C;;AAEA,MAAIA,YAAY,KAAKhB,sBAAjB,IAA2CgB,YAAY,KAAKf,yBAAhE,EAA2F;AACzF;AACD;;AAED,MAAImF,QAAQ,GAAGtE,IAAI,CAAC+E,cAAL,CAAoBD,SAApB,CAAf;;AAEA,MAAI5E,YAAY,KAAKhB,sBAAjB,IAA2C,CAACL,QAAQ,CAACyF,QAAD,CAAxD,EAAoE;AAClEA,IAAAA,QAAQ,GAAG,IAAX;AACD;;AAED,MAAIA,QAAJ,EAAc;AACZ,WAAOA,QAAQ,CAACgB,IAAD,CAAf;AACD;AACF","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _a, _b, _c; // TODO\n// ??? refactor? check the outer usage of data provider.\n// merge with defaultDimValueGetter?\n\n\nimport { isTypedArray, extend, assert, each, isObject, bind } from 'zrender/lib/core/util';\nimport { getDataItemValue } from '../../util/model';\nimport { createSourceFromSeriesDataOption, isSourceInstance } from '../Source';\nimport { SOURCE_FORMAT_ORIGINAL, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_KEYED_COLUMNS, SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ARRAY_ROWS, SERIES_LAYOUT_BY_COLUMN, SERIES_LAYOUT_BY_ROW } from '../../util/types';\nvar providerMethods;\nvar mountMethods;\n/**\n * If normal array used, mutable chunk size is supported.\n * If typed array used, chunk size must be fixed.\n */\n\nvar DefaultDataProvider =\n/** @class */\nfunction () {\n  function DefaultDataProvider(sourceParam, dimSize) {\n    // let source: Source;\n    var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam; // declare source is Source;\n\n    this._source = source;\n    var data = this._data = source.data; // Typed array. TODO IE10+?\n\n    if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (dimSize == null) {\n          throw new Error('Typed array data must specify dimension size');\n        }\n      }\n\n      this._offset = 0;\n      this._dimSize = dimSize;\n      this._data = data;\n    }\n\n    mountMethods(this, data, source);\n  }\n\n  DefaultDataProvider.prototype.getSource = function () {\n    return this._source;\n  };\n\n  DefaultDataProvider.prototype.count = function () {\n    return 0;\n  };\n\n  DefaultDataProvider.prototype.getItem = function (idx, out) {\n    return;\n  };\n\n  DefaultDataProvider.prototype.appendData = function (newData) {};\n\n  DefaultDataProvider.prototype.clean = function () {};\n\n  DefaultDataProvider.protoInitialize = function () {\n    // PENDING: To avoid potential incompat (e.g., prototype\n    // is visited somewhere), still init them on prototype.\n    var proto = DefaultDataProvider.prototype;\n    proto.pure = false;\n    proto.persistent = true;\n  }();\n\n  DefaultDataProvider.internalField = function () {\n    var _a;\n\n    mountMethods = function (provider, data, source) {\n      var sourceFormat = source.sourceFormat;\n      var seriesLayoutBy = source.seriesLayoutBy;\n      var startIndex = source.startIndex;\n      var dimsDef = source.dimensionsDefine;\n      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert(methods, 'Invalide sourceFormat: ' + sourceFormat);\n      }\n\n      extend(provider, methods);\n\n      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n        provider.getItem = getItemForTypedArray;\n        provider.count = countForTypedArray;\n        provider.fillStorage = fillStorageForTypedArray;\n      } else {\n        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);\n        provider.getItem = bind(rawItemGetter, null, data, startIndex, dimsDef);\n        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);\n        provider.count = bind(rawCounter, null, data, startIndex, dimsDef);\n      }\n    };\n\n    var getItemForTypedArray = function (idx, out) {\n      idx = idx - this._offset;\n      out = out || [];\n      var data = this._data;\n      var dimSize = this._dimSize;\n      var offset = dimSize * idx;\n\n      for (var i = 0; i < dimSize; i++) {\n        out[i] = data[offset + i];\n      }\n\n      return out;\n    };\n\n    var fillStorageForTypedArray = function (start, end, storage, extent) {\n      var data = this._data;\n      var dimSize = this._dimSize;\n\n      for (var dim = 0; dim < dimSize; dim++) {\n        var dimExtent = extent[dim];\n        var min = dimExtent[0] == null ? Infinity : dimExtent[0];\n        var max = dimExtent[1] == null ? -Infinity : dimExtent[1];\n        var count = end - start;\n        var arr = storage[dim];\n\n        for (var i = 0; i < count; i++) {\n          // appendData with TypedArray will always do replace in provider.\n          var val = data[i * dimSize + dim];\n          arr[start + i] = val;\n          val < min && (min = val);\n          val > max && (max = val);\n        }\n\n        dimExtent[0] = min;\n        dimExtent[1] = max;\n      }\n    };\n\n    var countForTypedArray = function () {\n      return this._data ? this._data.length / this._dimSize : 0;\n    };\n\n    providerMethods = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = {\n      pure: true,\n      appendData: function () {\n        throw new Error('Do not support appendData when set seriesLayoutBy: \"row\".');\n      }\n    }, _a[SOURCE_FORMAT_OBJECT_ROWS] = {\n      pure: true,\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_KEYED_COLUMNS] = {\n      pure: true,\n      appendData: function (newData) {\n        var data = this._data;\n        each(newData, function (newCol, key) {\n          var oldCol = data[key] || (data[key] = []);\n\n          for (var i = 0; i < (newCol || []).length; i++) {\n            oldCol.push(newCol[i]);\n          }\n        });\n      }\n    }, _a[SOURCE_FORMAT_ORIGINAL] = {\n      appendData: appendDataSimply\n    }, _a[SOURCE_FORMAT_TYPED_ARRAY] = {\n      persistent: false,\n      pure: true,\n      appendData: function (newData) {\n        if (process.env.NODE_ENV !== 'production') {\n          assert(isTypedArray(newData), 'Added data must be TypedArray if data in initialization is TypedArray');\n        }\n\n        this._data = newData;\n      },\n      // Clean self if data is already used.\n      clean: function () {\n        // PENDING\n        this._offset += this.count();\n        this._data = null;\n      }\n    }, _a);\n\n    function appendDataSimply(newData) {\n      for (var i = 0; i < newData.length; i++) {\n        this._data.push(newData[i]);\n      }\n    }\n  }();\n\n  return DefaultDataProvider;\n}();\n\nexport { DefaultDataProvider };\n\nvar getItemSimply = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx];\n};\n\nvar rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef, idx) {\n  return rawData[idx + startIndex];\n}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef, idx, out) {\n  idx += startIndex;\n  var item = out || [];\n  var data = rawData;\n\n  for (var i = 0; i < data.length; i++) {\n    var row = data[i];\n    item[i] = row ? row[idx] : null;\n  }\n\n  return item;\n}, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef, idx, out) {\n  var item = out || [];\n\n  for (var i = 0; i < dimsDef.length; i++) {\n    var dimName = dimsDef[i].name;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (dimName == null) {\n        throw new Error();\n      }\n    }\n\n    var col = rawData[dimName];\n    item[i] = col ? col[idx] : null;\n  }\n\n  return item;\n}, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);\nexport function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not support get item on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n\n  return method;\n}\n\nvar countSimply = function (rawData, startIndex, dimsDef) {\n  return rawData.length;\n};\n\nvar rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef) {\n  return Math.max(0, rawData.length - startIndex);\n}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef) {\n  var row = rawData[0];\n  return row ? Math.max(0, row.length - startIndex) : 0;\n}, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef) {\n  var dimName = dimsDef[0].name;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (dimName == null) {\n      throw new Error();\n    }\n  }\n\n  var col = rawData[dimName];\n  return col ? col.length : 0;\n}, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);\nexport function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {\n  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not suppport count on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n  }\n\n  return method;\n}\n\nvar getRawValueSimply = function (dataItem, dimIndex, property) {\n  return dataItem[dimIndex];\n};\n\nvar rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function (dataItem, dimIndex, property) {\n  return dataItem[property];\n}, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function (dataItem, dimIndex, property) {\n  // FIXME: In some case (markpoint in geo (geo-map.html)),\n  // dataItem is {coord: [...]}\n  var value = getDataItemValue(dataItem);\n  return !(value instanceof Array) ? value : value[dimIndex];\n}, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);\nexport function getRawSourceValueGetter(sourceFormat) {\n  var method = rawSourceValueGetterMap[sourceFormat];\n\n  if (process.env.NODE_ENV !== 'production') {\n    assert(method, 'Do not suppport get value on \"' + sourceFormat + '\".');\n  }\n\n  return method;\n}\n\nfunction getMethodMapKey(sourceFormat, seriesLayoutBy) {\n  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + seriesLayoutBy : sourceFormat;\n} // ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,\n// Consider persistent.\n// Caution: why use raw value to display on label or tooltip?\n// A reason is to avoid format. For example time value we do not know\n// how to format is expected. More over, if stack is used, calculated\n// value may be 0.91000000001, which have brings trouble to display.\n// TODO: consider how to treat null/undefined/NaN when display?\n\n\nexport function retrieveRawValue(data, dataIndex, // If dimIndex is null/undefined, return OptionDataItem.\n// Otherwise, return OptionDataValue.\ndim) {\n  if (!data) {\n    return;\n  } // Consider data may be not persistent.\n\n\n  var dataItem = data.getRawDataItem(dataIndex);\n\n  if (dataItem == null) {\n    return;\n  }\n\n  var store = data.getStore();\n  var sourceFormat = store.getSource().sourceFormat;\n\n  if (dim != null) {\n    var dimIndex = data.getDimensionIndex(dim);\n    var property = store.getDimensionProperty(dimIndex);\n    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);\n  } else {\n    var result = dataItem;\n\n    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n      result = getDataItemValue(dataItem);\n    }\n\n    return result;\n  }\n}\n/**\n * Compatible with some cases (in pie, map) like:\n * data: [{name: 'xx', value: 5, selected: true}, ...]\n * where only sourceFormat is 'original' and 'objectRows' supported.\n *\n * // TODO\n * Supported detail options in data item when using 'arrayRows'.\n *\n * @param data\n * @param dataIndex\n * @param attr like 'selected'\n */\n\nexport function retrieveRawAttr(data, dataIndex, attr) {\n  if (!data) {\n    return;\n  }\n\n  var sourceFormat = data.getStore().getSource().sourceFormat;\n\n  if (sourceFormat !== SOURCE_FORMAT_ORIGINAL && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {\n    return;\n  }\n\n  var dataItem = data.getRawDataItem(dataIndex);\n\n  if (sourceFormat === SOURCE_FORMAT_ORIGINAL && !isObject(dataItem)) {\n    dataItem = null;\n  }\n\n  if (dataItem) {\n    return dataItem[attr];\n  }\n}"]},"metadata":{},"sourceType":"module"}