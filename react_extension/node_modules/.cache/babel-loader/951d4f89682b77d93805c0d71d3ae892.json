{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {\n  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;\n}\n\nfunction defaultKeyGetter(item) {\n  return item;\n}\n\nvar DataDiffer =\n/** @class */\nfunction () {\n  /**\n   * @param context Can be visited by this.context in callback.\n   */\n  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context, // By default: 'oneToOne'.\n  diffMode) {\n    this._old = oldArr;\n    this._new = newArr;\n    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n    this._newKeyGetter = newKeyGetter || defaultKeyGetter; // Visible in callback via `this.context`;\n\n    this.context = context;\n    this._diffModeMultiple = diffMode === 'multiple';\n  }\n  /**\n   * Callback function when add a data\n   */\n\n\n  DataDiffer.prototype.add = function (func) {\n    this._add = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data\n   */\n\n\n  DataDiffer.prototype.update = function (func) {\n    this._update = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateManyToOne = function (func) {\n    this._updateManyToOne = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateOneToMany = function (func) {\n    this._updateOneToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateManyToMany = function (func) {\n    this._updateManyToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when remove a data\n   */\n\n\n  DataDiffer.prototype.remove = function (func) {\n    this._remove = func;\n    return this;\n  };\n\n  DataDiffer.prototype.execute = function () {\n    this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']();\n  };\n\n  DataDiffer.prototype._executeOneToOne = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var newDataIndexMap = {};\n    var oldDataKeyArr = new Array(oldArr.length);\n    var newDataKeyArr = new Array(newArr.length);\n\n    this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter');\n\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n    for (var i = 0; i < oldArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal); // idx can never be empty array here. see 'set null' logic below.\n\n      if (newIdxMapValLen > 1) {\n        // Consider there is duplicate key (for example, use dataItem.name as key).\n        // We should make sure every item in newArr and oldArr can be visited.\n        var newIdx = newIdxMapVal.shift();\n\n        if (newIdxMapVal.length === 1) {\n          newDataIndexMap[oldKey] = newIdxMapVal[0];\n        }\n\n        this._update && this._update(newIdx, i);\n      } else if (newIdxMapValLen === 1) {\n        newDataIndexMap[oldKey] = null;\n        this._update && this._update(newIdxMapVal, i);\n      } else {\n        this._remove && this._remove(i);\n      }\n    }\n\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n  /**\n   * For example, consider the case:\n   * oldData: [o0, o1, o2, o3, o4, o5, o6, o7],\n   * newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],\n   * Where:\n   *     o0, o1, n0 has key 'a' (many to one)\n   *     o5, n4, n5, n6 has key 'b' (one to many)\n   *     o2, n1 has key 'c' (one to one)\n   *     n2, n3 has key 'd' (add)\n   *     o3, o4 has key 'e' (remove)\n   *     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)\n   * Then:\n   *     (The order of the following directives are not ensured.)\n   *     this._updateManyToOne(n0, [o0, o1]);\n   *     this._updateOneToMany([n4, n5, n6], o5);\n   *     this._update(n1, o2);\n   *     this._remove(o3);\n   *     this._remove(o4);\n   *     this._remove(o6);\n   *     this._remove(o7);\n   *     this._add(n2);\n   *     this._add(n3);\n   *     this._add(n7);\n   *     this._add(n8);\n   */\n\n\n  DataDiffer.prototype._executeMultiple = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var oldDataIndexMap = {};\n    var newDataIndexMap = {};\n    var oldDataKeyArr = [];\n    var newDataKeyArr = [];\n\n    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter');\n\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n    for (var i = 0; i < oldDataKeyArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var oldIdxMapVal = oldDataIndexMap[oldKey];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {\n        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {\n        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {\n        this._update && this._update(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {\n        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1) {\n        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {\n          this._remove && this._remove(oldIdxMapVal[i_1]);\n        }\n      } else {\n        this._remove && this._remove(oldIdxMapVal);\n      }\n    }\n\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n\n  DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {\n    for (var i = 0; i < newDataKeyArr.length; i++) {\n      var newKey = newDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[newKey];\n      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n      if (idxMapValLen > 1) {\n        for (var j = 0; j < idxMapValLen; j++) {\n          this._add && this._add(newIdxMapVal[j]);\n        }\n      } else if (idxMapValLen === 1) {\n        this._add && this._add(newIdxMapVal);\n      } // Support both `newDataKeyArr` are duplication removed or not removed.\n\n\n      newDataIndexMap[newKey] = null;\n    }\n  };\n\n  DataDiffer.prototype._initIndexMap = function (arr, // Can be null.\n  map, // In 'byKey', the output `keyArr` is duplication removed.\n  // In 'byIndex', the output `keyArr` is not duplication removed and\n  //     its indices are accurately corresponding to `arr`.\n  keyArr, keyGetterName) {\n    var cbModeMultiple = this._diffModeMultiple;\n\n    for (var i = 0; i < arr.length; i++) {\n      // Add prefix to avoid conflict with Object.prototype.\n      var key = '_ec_' + this[keyGetterName](arr[i], i);\n\n      if (!cbModeMultiple) {\n        keyArr[i] = key;\n      }\n\n      if (!map) {\n        continue;\n      }\n\n      var idxMapVal = map[key];\n      var idxMapValLen = dataIndexMapValueLength(idxMapVal);\n\n      if (idxMapValLen === 0) {\n        // Simple optimize: in most cases, one index has one key,\n        // do not need array.\n        map[key] = i;\n\n        if (cbModeMultiple) {\n          keyArr.push(key);\n        }\n      } else if (idxMapValLen === 1) {\n        map[key] = [idxMapVal, i];\n      } else {\n        idxMapVal.push(i);\n      }\n    }\n  };\n\n  return DataDiffer;\n}();\n\nexport default DataDiffer;","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/data/DataDiffer.js"],"names":["dataIndexMapValueLength","valNumOrArrLengthMoreThan2","length","defaultKeyGetter","item","DataDiffer","oldArr","newArr","oldKeyGetter","newKeyGetter","context","diffMode","_old","_new","_oldKeyGetter","_newKeyGetter","_diffModeMultiple","prototype","add","func","_add","update","_update","updateManyToOne","_updateManyToOne","updateOneToMany","_updateOneToMany","updateManyToMany","_updateManyToMany","remove","_remove","execute","_executeOneToOne","newDataIndexMap","oldDataKeyArr","Array","newDataKeyArr","_initIndexMap","i","oldKey","newIdxMapVal","newIdxMapValLen","newIdx","shift","_performRestAdd","_executeMultiple","oldDataIndexMap","oldIdxMapVal","oldIdxMapValLen","i_1","newKey","idxMapValLen","j","arr","map","keyArr","keyGetterName","cbModeMultiple","key","idxMapVal","push"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {\n  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;\n}\n\nfunction defaultKeyGetter(item) {\n  return item;\n}\n\nvar DataDiffer =\n/** @class */\nfunction () {\n  /**\n   * @param context Can be visited by this.context in callback.\n   */\n  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context, // By default: 'oneToOne'.\n  diffMode) {\n    this._old = oldArr;\n    this._new = newArr;\n    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n    this._newKeyGetter = newKeyGetter || defaultKeyGetter; // Visible in callback via `this.context`;\n\n    this.context = context;\n    this._diffModeMultiple = diffMode === 'multiple';\n  }\n  /**\n   * Callback function when add a data\n   */\n\n\n  DataDiffer.prototype.add = function (func) {\n    this._add = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data\n   */\n\n\n  DataDiffer.prototype.update = function (func) {\n    this._update = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateManyToOne = function (func) {\n    this._updateManyToOne = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateOneToMany = function (func) {\n    this._updateOneToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when update a data and only work in `cbMode: 'byKey'`.\n   */\n\n\n  DataDiffer.prototype.updateManyToMany = function (func) {\n    this._updateManyToMany = func;\n    return this;\n  };\n  /**\n   * Callback function when remove a data\n   */\n\n\n  DataDiffer.prototype.remove = function (func) {\n    this._remove = func;\n    return this;\n  };\n\n  DataDiffer.prototype.execute = function () {\n    this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']();\n  };\n\n  DataDiffer.prototype._executeOneToOne = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var newDataIndexMap = {};\n    var oldDataKeyArr = new Array(oldArr.length);\n    var newDataKeyArr = new Array(newArr.length);\n\n    this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter');\n\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n    for (var i = 0; i < oldArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal); // idx can never be empty array here. see 'set null' logic below.\n\n      if (newIdxMapValLen > 1) {\n        // Consider there is duplicate key (for example, use dataItem.name as key).\n        // We should make sure every item in newArr and oldArr can be visited.\n        var newIdx = newIdxMapVal.shift();\n\n        if (newIdxMapVal.length === 1) {\n          newDataIndexMap[oldKey] = newIdxMapVal[0];\n        }\n\n        this._update && this._update(newIdx, i);\n      } else if (newIdxMapValLen === 1) {\n        newDataIndexMap[oldKey] = null;\n        this._update && this._update(newIdxMapVal, i);\n      } else {\n        this._remove && this._remove(i);\n      }\n    }\n\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n  /**\n   * For example, consider the case:\n   * oldData: [o0, o1, o2, o3, o4, o5, o6, o7],\n   * newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],\n   * Where:\n   *     o0, o1, n0 has key 'a' (many to one)\n   *     o5, n4, n5, n6 has key 'b' (one to many)\n   *     o2, n1 has key 'c' (one to one)\n   *     n2, n3 has key 'd' (add)\n   *     o3, o4 has key 'e' (remove)\n   *     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)\n   * Then:\n   *     (The order of the following directives are not ensured.)\n   *     this._updateManyToOne(n0, [o0, o1]);\n   *     this._updateOneToMany([n4, n5, n6], o5);\n   *     this._update(n1, o2);\n   *     this._remove(o3);\n   *     this._remove(o4);\n   *     this._remove(o6);\n   *     this._remove(o7);\n   *     this._add(n2);\n   *     this._add(n3);\n   *     this._add(n7);\n   *     this._add(n8);\n   */\n\n\n  DataDiffer.prototype._executeMultiple = function () {\n    var oldArr = this._old;\n    var newArr = this._new;\n    var oldDataIndexMap = {};\n    var newDataIndexMap = {};\n    var oldDataKeyArr = [];\n    var newDataKeyArr = [];\n\n    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter');\n\n    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n    for (var i = 0; i < oldDataKeyArr.length; i++) {\n      var oldKey = oldDataKeyArr[i];\n      var oldIdxMapVal = oldDataIndexMap[oldKey];\n      var newIdxMapVal = newDataIndexMap[oldKey];\n      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);\n      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {\n        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {\n        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {\n        this._update && this._update(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {\n        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);\n        newDataIndexMap[oldKey] = null;\n      } else if (oldIdxMapValLen > 1) {\n        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {\n          this._remove && this._remove(oldIdxMapVal[i_1]);\n        }\n      } else {\n        this._remove && this._remove(oldIdxMapVal);\n      }\n    }\n\n    this._performRestAdd(newDataKeyArr, newDataIndexMap);\n  };\n\n  DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {\n    for (var i = 0; i < newDataKeyArr.length; i++) {\n      var newKey = newDataKeyArr[i];\n      var newIdxMapVal = newDataIndexMap[newKey];\n      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n      if (idxMapValLen > 1) {\n        for (var j = 0; j < idxMapValLen; j++) {\n          this._add && this._add(newIdxMapVal[j]);\n        }\n      } else if (idxMapValLen === 1) {\n        this._add && this._add(newIdxMapVal);\n      } // Support both `newDataKeyArr` are duplication removed or not removed.\n\n\n      newDataIndexMap[newKey] = null;\n    }\n  };\n\n  DataDiffer.prototype._initIndexMap = function (arr, // Can be null.\n  map, // In 'byKey', the output `keyArr` is duplication removed.\n  // In 'byIndex', the output `keyArr` is not duplication removed and\n  //     its indices are accurately corresponding to `arr`.\n  keyArr, keyGetterName) {\n    var cbModeMultiple = this._diffModeMultiple;\n\n    for (var i = 0; i < arr.length; i++) {\n      // Add prefix to avoid conflict with Object.prototype.\n      var key = '_ec_' + this[keyGetterName](arr[i], i);\n\n      if (!cbModeMultiple) {\n        keyArr[i] = key;\n      }\n\n      if (!map) {\n        continue;\n      }\n\n      var idxMapVal = map[key];\n      var idxMapValLen = dataIndexMapValueLength(idxMapVal);\n\n      if (idxMapValLen === 0) {\n        // Simple optimize: in most cases, one index has one key,\n        // do not need array.\n        map[key] = i;\n\n        if (cbModeMultiple) {\n          keyArr.push(key);\n        }\n      } else if (idxMapValLen === 1) {\n        map[key] = [idxMapVal, i];\n      } else {\n        idxMapVal.push(i);\n      }\n    }\n  };\n\n  return DataDiffer;\n}();\n\nexport default DataDiffer;"]},"metadata":{},"sourceType":"module"}