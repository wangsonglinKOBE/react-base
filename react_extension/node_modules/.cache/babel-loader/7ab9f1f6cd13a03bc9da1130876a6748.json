{"ast":null,"code":"import * as matrix from './matrix';\nimport Point from './Point';\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar lt = new Point();\nvar rb = new Point();\nvar lb = new Point();\nvar rt = new Point();\nvar minTv = new Point();\nvar maxTv = new Point();\n\nvar BoundingRect = function () {\n  function BoundingRect(x, y, width, height) {\n    if (width < 0) {\n      x = x + width;\n      width = -width;\n    }\n\n    if (height < 0) {\n      y = y + height;\n      height = -height;\n    }\n\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  BoundingRect.prototype.union = function (other) {\n    var x = mathMin(other.x, this.x);\n    var y = mathMin(other.y, this.y);\n\n    if (isFinite(this.x) && isFinite(this.width)) {\n      this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n    } else {\n      this.width = other.width;\n    }\n\n    if (isFinite(this.y) && isFinite(this.height)) {\n      this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n    } else {\n      this.height = other.height;\n    }\n\n    this.x = x;\n    this.y = y;\n  };\n\n  BoundingRect.prototype.applyTransform = function (m) {\n    BoundingRect.applyTransform(this, this, m);\n  };\n\n  BoundingRect.prototype.calculateTransform = function (b) {\n    var a = this;\n    var sx = b.width / a.width;\n    var sy = b.height / a.height;\n    var m = matrix.create();\n    matrix.translate(m, m, [-a.x, -a.y]);\n    matrix.scale(m, m, [sx, sy]);\n    matrix.translate(m, m, [b.x, b.y]);\n    return m;\n  };\n\n  BoundingRect.prototype.intersect = function (b, mtv) {\n    if (!b) {\n      return false;\n    }\n\n    if (!(b instanceof BoundingRect)) {\n      b = BoundingRect.create(b);\n    }\n\n    var a = this;\n    var ax0 = a.x;\n    var ax1 = a.x + a.width;\n    var ay0 = a.y;\n    var ay1 = a.y + a.height;\n    var bx0 = b.x;\n    var bx1 = b.x + b.width;\n    var by0 = b.y;\n    var by1 = b.y + b.height;\n    var overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n\n    if (mtv) {\n      var dMin = Infinity;\n      var dMax = 0;\n      var d0 = Math.abs(ax1 - bx0);\n      var d1 = Math.abs(bx1 - ax0);\n      var d2 = Math.abs(ay1 - by0);\n      var d3 = Math.abs(by1 - ay0);\n      var dx = Math.min(d0, d1);\n      var dy = Math.min(d2, d3);\n\n      if (ax1 < bx0 || bx1 < ax0) {\n        if (dx > dMax) {\n          dMax = dx;\n\n          if (d0 < d1) {\n            Point.set(maxTv, -d0, 0);\n          } else {\n            Point.set(maxTv, d1, 0);\n          }\n        }\n      } else {\n        if (dx < dMin) {\n          dMin = dx;\n\n          if (d0 < d1) {\n            Point.set(minTv, d0, 0);\n          } else {\n            Point.set(minTv, -d1, 0);\n          }\n        }\n      }\n\n      if (ay1 < by0 || by1 < ay0) {\n        if (dy > dMax) {\n          dMax = dy;\n\n          if (d2 < d3) {\n            Point.set(maxTv, 0, -d2);\n          } else {\n            Point.set(maxTv, 0, d3);\n          }\n        }\n      } else {\n        if (dx < dMin) {\n          dMin = dx;\n\n          if (d2 < d3) {\n            Point.set(minTv, 0, d2);\n          } else {\n            Point.set(minTv, 0, -d3);\n          }\n        }\n      }\n    }\n\n    if (mtv) {\n      Point.copy(mtv, overlap ? minTv : maxTv);\n    }\n\n    return overlap;\n  };\n\n  BoundingRect.prototype.contain = function (x, y) {\n    var rect = this;\n    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n  };\n\n  BoundingRect.prototype.clone = function () {\n    return new BoundingRect(this.x, this.y, this.width, this.height);\n  };\n\n  BoundingRect.prototype.copy = function (other) {\n    BoundingRect.copy(this, other);\n  };\n\n  BoundingRect.prototype.plain = function () {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  };\n\n  BoundingRect.prototype.isFinite = function () {\n    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);\n  };\n\n  BoundingRect.prototype.isZero = function () {\n    return this.width === 0 || this.height === 0;\n  };\n\n  BoundingRect.create = function (rect) {\n    return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n  };\n\n  BoundingRect.copy = function (target, source) {\n    target.x = source.x;\n    target.y = source.y;\n    target.width = source.width;\n    target.height = source.height;\n  };\n\n  BoundingRect.applyTransform = function (target, source, m) {\n    if (!m) {\n      if (target !== source) {\n        BoundingRect.copy(target, source);\n      }\n\n      return;\n    }\n\n    if (m[1] < 1e-5 && m[1] > -1e-5 && m[2] < 1e-5 && m[2] > -1e-5) {\n      var sx = m[0];\n      var sy = m[3];\n      var tx = m[4];\n      var ty = m[5];\n      target.x = source.x * sx + tx;\n      target.y = source.y * sy + ty;\n      target.width = source.width * sx;\n      target.height = source.height * sy;\n\n      if (target.width < 0) {\n        target.x += target.width;\n        target.width = -target.width;\n      }\n\n      if (target.height < 0) {\n        target.y += target.height;\n        target.height = -target.height;\n      }\n\n      return;\n    }\n\n    lt.x = lb.x = source.x;\n    lt.y = rt.y = source.y;\n    rb.x = rt.x = source.x + source.width;\n    rb.y = lb.y = source.y + source.height;\n    lt.transform(m);\n    rt.transform(m);\n    rb.transform(m);\n    lb.transform(m);\n    target.x = mathMin(lt.x, rb.x, lb.x, rt.x);\n    target.y = mathMin(lt.y, rb.y, lb.y, rt.y);\n    var maxX = mathMax(lt.x, rb.x, lb.x, rt.x);\n    var maxY = mathMax(lt.y, rb.y, lb.y, rt.y);\n    target.width = maxX - target.x;\n    target.height = maxY - target.y;\n  };\n\n  return BoundingRect;\n}();\n\nexport default BoundingRect;","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/zrender/lib/core/BoundingRect.js"],"names":["matrix","Point","mathMin","Math","min","mathMax","max","lt","rb","lb","rt","minTv","maxTv","BoundingRect","x","y","width","height","prototype","union","other","isFinite","applyTransform","m","calculateTransform","b","a","sx","sy","create","translate","scale","intersect","mtv","ax0","ax1","ay0","ay1","bx0","bx1","by0","by1","overlap","dMin","Infinity","dMax","d0","abs","d1","d2","d3","dx","dy","set","copy","contain","rect","clone","plain","isZero","target","source","tx","ty","transform","maxX","maxY"],"mappings":"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","sourcesContent":["import * as matrix from './matrix';\nimport Point from './Point';\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar lt = new Point();\nvar rb = new Point();\nvar lb = new Point();\nvar rt = new Point();\nvar minTv = new Point();\nvar maxTv = new Point();\nvar BoundingRect = (function () {\n    function BoundingRect(x, y, width, height) {\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    BoundingRect.prototype.union = function (other) {\n        var x = mathMin(other.x, this.x);\n        var y = mathMin(other.y, this.y);\n        if (isFinite(this.x) && isFinite(this.width)) {\n            this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n        }\n        else {\n            this.width = other.width;\n        }\n        if (isFinite(this.y) && isFinite(this.height)) {\n            this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n        }\n        else {\n            this.height = other.height;\n        }\n        this.x = x;\n        this.y = y;\n    };\n    BoundingRect.prototype.applyTransform = function (m) {\n        BoundingRect.applyTransform(this, this, m);\n    };\n    BoundingRect.prototype.calculateTransform = function (b) {\n        var a = this;\n        var sx = b.width / a.width;\n        var sy = b.height / a.height;\n        var m = matrix.create();\n        matrix.translate(m, m, [-a.x, -a.y]);\n        matrix.scale(m, m, [sx, sy]);\n        matrix.translate(m, m, [b.x, b.y]);\n        return m;\n    };\n    BoundingRect.prototype.intersect = function (b, mtv) {\n        if (!b) {\n            return false;\n        }\n        if (!(b instanceof BoundingRect)) {\n            b = BoundingRect.create(b);\n        }\n        var a = this;\n        var ax0 = a.x;\n        var ax1 = a.x + a.width;\n        var ay0 = a.y;\n        var ay1 = a.y + a.height;\n        var bx0 = b.x;\n        var bx1 = b.x + b.width;\n        var by0 = b.y;\n        var by1 = b.y + b.height;\n        var overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n        if (mtv) {\n            var dMin = Infinity;\n            var dMax = 0;\n            var d0 = Math.abs(ax1 - bx0);\n            var d1 = Math.abs(bx1 - ax0);\n            var d2 = Math.abs(ay1 - by0);\n            var d3 = Math.abs(by1 - ay0);\n            var dx = Math.min(d0, d1);\n            var dy = Math.min(d2, d3);\n            if (ax1 < bx0 || bx1 < ax0) {\n                if (dx > dMax) {\n                    dMax = dx;\n                    if (d0 < d1) {\n                        Point.set(maxTv, -d0, 0);\n                    }\n                    else {\n                        Point.set(maxTv, d1, 0);\n                    }\n                }\n            }\n            else {\n                if (dx < dMin) {\n                    dMin = dx;\n                    if (d0 < d1) {\n                        Point.set(minTv, d0, 0);\n                    }\n                    else {\n                        Point.set(minTv, -d1, 0);\n                    }\n                }\n            }\n            if (ay1 < by0 || by1 < ay0) {\n                if (dy > dMax) {\n                    dMax = dy;\n                    if (d2 < d3) {\n                        Point.set(maxTv, 0, -d2);\n                    }\n                    else {\n                        Point.set(maxTv, 0, d3);\n                    }\n                }\n            }\n            else {\n                if (dx < dMin) {\n                    dMin = dx;\n                    if (d2 < d3) {\n                        Point.set(minTv, 0, d2);\n                    }\n                    else {\n                        Point.set(minTv, 0, -d3);\n                    }\n                }\n            }\n        }\n        if (mtv) {\n            Point.copy(mtv, overlap ? minTv : maxTv);\n        }\n        return overlap;\n    };\n    BoundingRect.prototype.contain = function (x, y) {\n        var rect = this;\n        return x >= rect.x\n            && x <= (rect.x + rect.width)\n            && y >= rect.y\n            && y <= (rect.y + rect.height);\n    };\n    BoundingRect.prototype.clone = function () {\n        return new BoundingRect(this.x, this.y, this.width, this.height);\n    };\n    BoundingRect.prototype.copy = function (other) {\n        BoundingRect.copy(this, other);\n    };\n    BoundingRect.prototype.plain = function () {\n        return {\n            x: this.x,\n            y: this.y,\n            width: this.width,\n            height: this.height\n        };\n    };\n    BoundingRect.prototype.isFinite = function () {\n        return isFinite(this.x)\n            && isFinite(this.y)\n            && isFinite(this.width)\n            && isFinite(this.height);\n    };\n    BoundingRect.prototype.isZero = function () {\n        return this.width === 0 || this.height === 0;\n    };\n    BoundingRect.create = function (rect) {\n        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n    };\n    BoundingRect.copy = function (target, source) {\n        target.x = source.x;\n        target.y = source.y;\n        target.width = source.width;\n        target.height = source.height;\n    };\n    BoundingRect.applyTransform = function (target, source, m) {\n        if (!m) {\n            if (target !== source) {\n                BoundingRect.copy(target, source);\n            }\n            return;\n        }\n        if (m[1] < 1e-5 && m[1] > -1e-5 && m[2] < 1e-5 && m[2] > -1e-5) {\n            var sx = m[0];\n            var sy = m[3];\n            var tx = m[4];\n            var ty = m[5];\n            target.x = source.x * sx + tx;\n            target.y = source.y * sy + ty;\n            target.width = source.width * sx;\n            target.height = source.height * sy;\n            if (target.width < 0) {\n                target.x += target.width;\n                target.width = -target.width;\n            }\n            if (target.height < 0) {\n                target.y += target.height;\n                target.height = -target.height;\n            }\n            return;\n        }\n        lt.x = lb.x = source.x;\n        lt.y = rt.y = source.y;\n        rb.x = rt.x = source.x + source.width;\n        rb.y = lb.y = source.y + source.height;\n        lt.transform(m);\n        rt.transform(m);\n        rb.transform(m);\n        lb.transform(m);\n        target.x = mathMin(lt.x, rb.x, lb.x, rt.x);\n        target.y = mathMin(lt.y, rb.y, lb.y, rt.y);\n        var maxX = mathMax(lt.x, rb.x, lb.x, rt.x);\n        var maxY = mathMax(lt.y, rb.y, lb.y, rt.y);\n        target.width = maxX - target.x;\n        target.height = maxY - target.y;\n    };\n    return BoundingRect;\n}());\nexport default BoundingRect;\n"]},"metadata":{},"sourceType":"module"}