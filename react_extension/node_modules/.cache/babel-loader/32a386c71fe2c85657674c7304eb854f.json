{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, indexOf, curry, assert, map, createHashMap } from 'zrender/lib/core/util';\nimport * as graphic from '../../util/graphic';\nimport * as brushHelper from './brushHelper';\nimport { parseFinder as modelUtilParseFinder } from '../../util/model'; // FIXME\n// how to genarialize to more coordinate systems.\n\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n\nvar BrushTargetManager =\n/** @class */\nfunction () {\n  /**\n   * @param finder contains Index/Id/Name of xAxis/yAxis/geo/grid\n   *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n   * @param opt.include include coordinate system types.\n   */\n  function BrushTargetManager(finder, ecModel, opt) {\n    var _this = this;\n\n    this._targetInfoList = [];\n    var foundCpts = parseFinder(ecModel, finder);\n    each(targetInfoBuilders, function (builder, type) {\n      if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n        builder(foundCpts, _this._targetInfoList);\n      }\n    });\n  }\n\n  BrushTargetManager.prototype.setOutputRanges = function (areas, ecModel) {\n    this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n      (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n      if (!area.coordRange) {\n        area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n        // rebuild range by coordRange accrately, which may bring trouble when\n        // brushing only one item. So we use __rangeOffset to rebuilding range\n        // by coordRange. And this it only used in brush component so it is no\n        // need to be adapted to coordRanges.\n\n        var result = coordConvert[area.brushType](0, coordSys, coordRange);\n        area.__rangeOffset = {\n          offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n          xyMinMax: result.xyMinMax\n        };\n      }\n    });\n    return areas;\n  };\n\n  BrushTargetManager.prototype.matchOutputRanges = function (areas, ecModel, cb) {\n    each(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n\n      if (targetInfo && targetInfo !== true) {\n        each(targetInfo.coordSyses, function (coordSys) {\n          var result = coordConvert[area.brushType](1, coordSys, area.range, true);\n          cb(area, result.values, coordSys, ecModel);\n        });\n      }\n    }, this);\n  };\n  /**\n   * the `areas` is `BrushModel.areas`.\n   * Called in layout stage.\n   * convert `area.coordRange` to global range and set panelId to `area.range`.\n   */\n\n\n  BrushTargetManager.prototype.setInputRanges = function (areas, ecModel) {\n    each(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert(!targetInfo || targetInfo === true || area.coordRange, 'coordRange must be specified when coord index specified.');\n        assert(!targetInfo || targetInfo !== true || area.range, 'range must be specified in global brush.');\n      }\n\n      area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n      if (targetInfo && targetInfo !== true) {\n        area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n        // not keep its original value, for the sake of the dataZoom scenario,\n        // where area.coordRange remains unchanged but area.range may be changed.\n        // (2) Only support converting one coordRange to pixel range in brush\n        // component. So do not consider `coordRanges`.\n        // (3) About __rangeOffset, see comment above.\n\n        var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n        var rangeOffset = area.__rangeOffset;\n        area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n      }\n    }, this);\n  };\n\n  BrushTargetManager.prototype.makePanelOpts = function (api, getDefaultBrushType) {\n    return map(this._targetInfoList, function (targetInfo) {\n      var rect = targetInfo.getPanelRect();\n      return {\n        panelId: targetInfo.panelId,\n        defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,\n        clipPath: brushHelper.makeRectPanelClipPath(rect),\n        isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n        getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n      };\n    });\n  };\n\n  BrushTargetManager.prototype.controlSeries = function (area, seriesModel, ecModel) {\n    // Check whether area is bound in coord, and series do not belong to that coord.\n    // If do not do this check, some brush (like lineX) will controll all axes.\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n  };\n  /**\n   * If return Object, a coord found.\n   * If reutrn true, global found.\n   * Otherwise nothing found.\n   */\n\n\n  BrushTargetManager.prototype.findTargetInfo = function (area, ecModel) {\n    var targetInfoList = this._targetInfoList;\n    var foundCpts = parseFinder(ecModel, area);\n\n    for (var i = 0; i < targetInfoList.length; i++) {\n      var targetInfo = targetInfoList[i];\n      var areaPanelId = area.panelId;\n\n      if (areaPanelId) {\n        if (targetInfo.panelId === areaPanelId) {\n          return targetInfo;\n        }\n      } else {\n        for (var j = 0; j < targetInfoMatchers.length; j++) {\n          if (targetInfoMatchers[j](foundCpts, targetInfo)) {\n            return targetInfo;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  return BrushTargetManager;\n}();\n\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\n\nfunction parseFinder(ecModel, finder) {\n  return modelUtilParseFinder(ecModel, finder, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\n\nvar targetInfoBuilders = {\n  grid: function (foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = createHashMap();\n    var xAxesHas = {};\n    var yAxesHas = {};\n\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n\n    each(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    each(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    each(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      each(grid.getCartesians(), function (cartesian, index) {\n        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilders.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function (foundCpts, targetInfoList) {\n    each(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilders.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n}, // geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilders = {\n  grid: function () {\n    // grid is not Transformable.\n    return this.coordSys.master.getRect().clone();\n  },\n  geo: function () {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: curry(axisConvert, 0),\n  lineY: curry(axisConvert, 1),\n  rect: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp);\n    var xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = map(rangeOrCoordRange, function (item) {\n      var p = to ? coordSys.pointToData(item, clamp) : coordSys.dataToPoint(item, clamp);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(coordSys.type === 'cartesian2d', 'lineX/lineY brush is available only in cartesian2d.');\n  }\n\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax(map([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\n\nvar diffProcessor = {\n  lineX: curry(axisDiffProcessor, 0),\n  lineY: curry(axisDiffProcessor, 1),\n  rect: function (values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function (values, refer, scales) {\n    return map(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n// Return [0~1, 0~1]\n\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\n\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n\nexport default BrushTargetManager;","map":{"version":3,"sources":["D:/桌面/react基础原理分析/react_extension/node_modules/echarts/lib/component/helper/BrushTargetManager.js"],"names":["each","indexOf","curry","assert","map","createHashMap","graphic","brushHelper","parseFinder","modelUtilParseFinder","INCLUDE_FINDER_MAIN_TYPES","BrushTargetManager","finder","ecModel","opt","_this","_targetInfoList","foundCpts","targetInfoBuilders","builder","type","include","prototype","setOutputRanges","areas","matchOutputRanges","area","coordRange","coordSys","coordRanges","push","result","coordConvert","brushType","__rangeOffset","offset","diffProcessor","values","range","xyMinMax","cb","targetInfo","findTargetInfo","coordSyses","setInputRanges","process","env","NODE_ENV","panelId","rangeOffset","getScales","makePanelOpts","api","getDefaultBrushType","rect","getPanelRect","defaultBrushType","clipPath","makeRectPanelClipPath","isTargetByCursor","makeRectIsTargetByCursor","coordSysModel","getLinearBrushOtherExtent","makeLinearBrushOtherExtent","controlSeries","seriesModel","coordinateSystem","targetInfoList","i","length","areaPanelId","j","targetInfoMatchers","formatMinMax","minMax","reverse","includeMainTypes","grid","xAxisModels","yAxisModels","gridModels","gridModelMap","xAxesHas","yAxesHas","axisModel","gridModel","axis","model","set","id","cartesians","getCartesians","cartesian","index","getAxis","panelRectBuilders","xAxisDeclared","yAxisDeclared","geo","geoModels","geoModel","xAxisModel","yAxisModel","master","getRect","clone","getBoundingRect","applyTransform","getTransform","lineX","axisConvert","lineY","to","rangeOrCoordRange","clamp","xminymin","pointToData","dataToPoint","xmaxymax","polygon","Infinity","item","p","Math","min","max","axisNameIndex","coordToData","toLocalCoord","toGlobalCoord","dataToCoord","NaN","axisDiffProcessor","refer","scales","idx","xyMinMaxCurr","xyMinMaxOrigin","sizeCurr","getSize","sizeOrigin","isNaN"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { each, indexOf, curry, assert, map, createHashMap } from 'zrender/lib/core/util';\nimport * as graphic from '../../util/graphic';\nimport * as brushHelper from './brushHelper';\nimport { parseFinder as modelUtilParseFinder } from '../../util/model'; // FIXME\n// how to genarialize to more coordinate systems.\n\nvar INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n\nvar BrushTargetManager =\n/** @class */\nfunction () {\n  /**\n   * @param finder contains Index/Id/Name of xAxis/yAxis/geo/grid\n   *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}\n   * @param opt.include include coordinate system types.\n   */\n  function BrushTargetManager(finder, ecModel, opt) {\n    var _this = this;\n\n    this._targetInfoList = [];\n    var foundCpts = parseFinder(ecModel, finder);\n    each(targetInfoBuilders, function (builder, type) {\n      if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n        builder(foundCpts, _this._targetInfoList);\n      }\n    });\n  }\n\n  BrushTargetManager.prototype.setOutputRanges = function (areas, ecModel) {\n    this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n      (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges\n\n      if (!area.coordRange) {\n        area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not\n        // rebuild range by coordRange accrately, which may bring trouble when\n        // brushing only one item. So we use __rangeOffset to rebuilding range\n        // by coordRange. And this it only used in brush component so it is no\n        // need to be adapted to coordRanges.\n\n        var result = coordConvert[area.brushType](0, coordSys, coordRange);\n        area.__rangeOffset = {\n          offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n          xyMinMax: result.xyMinMax\n        };\n      }\n    });\n    return areas;\n  };\n\n  BrushTargetManager.prototype.matchOutputRanges = function (areas, ecModel, cb) {\n    each(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n\n      if (targetInfo && targetInfo !== true) {\n        each(targetInfo.coordSyses, function (coordSys) {\n          var result = coordConvert[area.brushType](1, coordSys, area.range, true);\n          cb(area, result.values, coordSys, ecModel);\n        });\n      }\n    }, this);\n  };\n  /**\n   * the `areas` is `BrushModel.areas`.\n   * Called in layout stage.\n   * convert `area.coordRange` to global range and set panelId to `area.range`.\n   */\n\n\n  BrushTargetManager.prototype.setInputRanges = function (areas, ecModel) {\n    each(areas, function (area) {\n      var targetInfo = this.findTargetInfo(area, ecModel);\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert(!targetInfo || targetInfo === true || area.coordRange, 'coordRange must be specified when coord index specified.');\n        assert(!targetInfo || targetInfo !== true || area.range, 'range must be specified in global brush.');\n      }\n\n      area.range = area.range || []; // convert coordRange to global range and set panelId.\n\n      if (targetInfo && targetInfo !== true) {\n        area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does\n        // not keep its original value, for the sake of the dataZoom scenario,\n        // where area.coordRange remains unchanged but area.range may be changed.\n        // (2) Only support converting one coordRange to pixel range in brush\n        // component. So do not consider `coordRanges`.\n        // (3) About __rangeOffset, see comment above.\n\n        var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n        var rangeOffset = area.__rangeOffset;\n        area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n      }\n    }, this);\n  };\n\n  BrushTargetManager.prototype.makePanelOpts = function (api, getDefaultBrushType) {\n    return map(this._targetInfoList, function (targetInfo) {\n      var rect = targetInfo.getPanelRect();\n      return {\n        panelId: targetInfo.panelId,\n        defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,\n        clipPath: brushHelper.makeRectPanelClipPath(rect),\n        isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n        getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)\n      };\n    });\n  };\n\n  BrushTargetManager.prototype.controlSeries = function (area, seriesModel, ecModel) {\n    // Check whether area is bound in coord, and series do not belong to that coord.\n    // If do not do this check, some brush (like lineX) will controll all axes.\n    var targetInfo = this.findTargetInfo(area, ecModel);\n    return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n  };\n  /**\n   * If return Object, a coord found.\n   * If reutrn true, global found.\n   * Otherwise nothing found.\n   */\n\n\n  BrushTargetManager.prototype.findTargetInfo = function (area, ecModel) {\n    var targetInfoList = this._targetInfoList;\n    var foundCpts = parseFinder(ecModel, area);\n\n    for (var i = 0; i < targetInfoList.length; i++) {\n      var targetInfo = targetInfoList[i];\n      var areaPanelId = area.panelId;\n\n      if (areaPanelId) {\n        if (targetInfo.panelId === areaPanelId) {\n          return targetInfo;\n        }\n      } else {\n        for (var j = 0; j < targetInfoMatchers.length; j++) {\n          if (targetInfoMatchers[j](foundCpts, targetInfo)) {\n            return targetInfo;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  return BrushTargetManager;\n}();\n\nfunction formatMinMax(minMax) {\n  minMax[0] > minMax[1] && minMax.reverse();\n  return minMax;\n}\n\nfunction parseFinder(ecModel, finder) {\n  return modelUtilParseFinder(ecModel, finder, {\n    includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n  });\n}\n\nvar targetInfoBuilders = {\n  grid: function (foundCpts, targetInfoList) {\n    var xAxisModels = foundCpts.xAxisModels;\n    var yAxisModels = foundCpts.yAxisModels;\n    var gridModels = foundCpts.gridModels; // Remove duplicated.\n\n    var gridModelMap = createHashMap();\n    var xAxesHas = {};\n    var yAxesHas = {};\n\n    if (!xAxisModels && !yAxisModels && !gridModels) {\n      return;\n    }\n\n    each(xAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n    });\n    each(yAxisModels, function (axisModel) {\n      var gridModel = axisModel.axis.grid.model;\n      gridModelMap.set(gridModel.id, gridModel);\n      yAxesHas[gridModel.id] = true;\n    });\n    each(gridModels, function (gridModel) {\n      gridModelMap.set(gridModel.id, gridModel);\n      xAxesHas[gridModel.id] = true;\n      yAxesHas[gridModel.id] = true;\n    });\n    gridModelMap.each(function (gridModel) {\n      var grid = gridModel.coordinateSystem;\n      var cartesians = [];\n      each(grid.getCartesians(), function (cartesian, index) {\n        if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n          cartesians.push(cartesian);\n        }\n      });\n      targetInfoList.push({\n        panelId: 'grid--' + gridModel.id,\n        gridModel: gridModel,\n        coordSysModel: gridModel,\n        // Use the first one as the representitive coordSys.\n        coordSys: cartesians[0],\n        coordSyses: cartesians,\n        getPanelRect: panelRectBuilders.grid,\n        xAxisDeclared: xAxesHas[gridModel.id],\n        yAxisDeclared: yAxesHas[gridModel.id]\n      });\n    });\n  },\n  geo: function (foundCpts, targetInfoList) {\n    each(foundCpts.geoModels, function (geoModel) {\n      var coordSys = geoModel.coordinateSystem;\n      targetInfoList.push({\n        panelId: 'geo--' + geoModel.id,\n        geoModel: geoModel,\n        coordSysModel: geoModel,\n        coordSys: coordSys,\n        coordSyses: [coordSys],\n        getPanelRect: panelRectBuilders.geo\n      });\n    });\n  }\n};\nvar targetInfoMatchers = [// grid\nfunction (foundCpts, targetInfo) {\n  var xAxisModel = foundCpts.xAxisModel;\n  var yAxisModel = foundCpts.yAxisModel;\n  var gridModel = foundCpts.gridModel;\n  !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n  !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n  return gridModel && gridModel === targetInfo.gridModel;\n}, // geo\nfunction (foundCpts, targetInfo) {\n  var geoModel = foundCpts.geoModel;\n  return geoModel && geoModel === targetInfo.geoModel;\n}];\nvar panelRectBuilders = {\n  grid: function () {\n    // grid is not Transformable.\n    return this.coordSys.master.getRect().clone();\n  },\n  geo: function () {\n    var coordSys = this.coordSys;\n    var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform\n\n    rect.applyTransform(graphic.getTransform(coordSys));\n    return rect;\n  }\n};\nvar coordConvert = {\n  lineX: curry(axisConvert, 0),\n  lineY: curry(axisConvert, 1),\n  rect: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp);\n    var xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp);\n    var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n    return {\n      values: values,\n      xyMinMax: values\n    };\n  },\n  polygon: function (to, coordSys, rangeOrCoordRange, clamp) {\n    var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n    var values = map(rangeOrCoordRange, function (item) {\n      var p = to ? coordSys.pointToData(item, clamp) : coordSys.dataToPoint(item, clamp);\n      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n      return p;\n    });\n    return {\n      values: values,\n      xyMinMax: xyMinMax\n    };\n  }\n};\n\nfunction axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(coordSys.type === 'cartesian2d', 'lineX/lineY brush is available only in cartesian2d.');\n  }\n\n  var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n  var values = formatMinMax(map([0, 1], function (i) {\n    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n  }));\n  var xyMinMax = [];\n  xyMinMax[axisNameIndex] = values;\n  xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n  return {\n    values: values,\n    xyMinMax: xyMinMax\n  };\n}\n\nvar diffProcessor = {\n  lineX: curry(axisDiffProcessor, 0),\n  lineY: curry(axisDiffProcessor, 1),\n  rect: function (values, refer, scales) {\n    return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n  },\n  polygon: function (values, refer, scales) {\n    return map(values, function (item, idx) {\n      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n    });\n  }\n};\n\nfunction axisDiffProcessor(axisNameIndex, values, refer, scales) {\n  return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n} // We have to process scale caused by dataZoom manually,\n// although it might be not accurate.\n// Return [0~1, 0~1]\n\n\nfunction getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n  var sizeCurr = getSize(xyMinMaxCurr);\n  var sizeOrigin = getSize(xyMinMaxOrigin);\n  var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n  isNaN(scales[0]) && (scales[0] = 1);\n  isNaN(scales[1]) && (scales[1] = 1);\n  return scales;\n}\n\nfunction getSize(xyMinMax) {\n  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n}\n\nexport default BrushTargetManager;"]},"metadata":{},"sourceType":"module"}