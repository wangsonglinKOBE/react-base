<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>

    // 冒泡排序
    // 冒泡排序是一种非常基础的排序方法，原理就是从把一个数组中的每一个数从前往后依次
    // 进行比较，然后根据大小交换位置，每一轮的比较都确定出一个当轮比较的最大值，
    // 最终实现数组的大小排序
    function kobe(arr) {
      let len = arr.length;
      for (let i = 0; i < len - 1; i++) { // 确定轮数
        for (let j = 0; j < len - 1 - i; j++) { // 确定比较次数
          if (arr[j] > arr[j + 1]) {
            let num = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = num;
          }
          console.log("第" + j + "次排序" + arr);
        }
        console.log("第" + i + "论排序" + arr);
      }
      console.log("最终排序" + arr);
      return arr;
    }

    console.log(kobe([2, 3, 1, 5, 4, 0, 8, 6]));



    // sort排序，不知道小伙伴们是否知道 stor排序有一个问题，这里称作bug吧，来看看是什么Bug
    // bug
    const ooo = [3, 2, 1]; //我们对数组ooo进行排序
    console.log(ooo.sort()); //输出 [1, 2, 3],没什么问题

    const ppp = [10, 3, 2, 1]; //bug来了哦
    console.log(ppp.sort()); //输出[1, 10, 2, 3] 是不是觉得没有实现从小到大的排序呢，10没有在最后一位

    // 那针对这个bug应该怎么解决呢，看下面
    ppp.sort((a, b) => a - b);
    console.log(ppp); //输出[1, 2, 3, 10] 学会了吗

    // 对字母进行排序
    const uuu = ['c', 'b', 'a'];
    uuu.sort((a, b) => {
      if (a > b) return 1;
      else if (a < b) return -1;
      else return 0;
    });
    console.log(uuu); //输出 ['a', 'b', 'c']

    // 所以学会了冒泡排序和sort 排序了吗，赶紧去试试吧

    // render 0
    // 0
    // 0
    // render 3
    // render 4
    // promise 4
    // render 5
    // pormise 5
    // render 6
    // timeout 6
    // render 7
    // timeout 7



  </script>
</body>

</html>